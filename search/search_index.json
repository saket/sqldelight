{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SQLDelight SQLDelight generates typesafe APIs from your SQL statements. It compile-time verifies your schema, statements, and migrations and provides IDE features like autocomplete and refactoring which make writing and maintaining SQL simple. SQLDelight currently supports the SQLite dialect and there are supported SQLite drivers on Android, JVM, iOS, and Windows. Android iOS JVM SQLite \u2705 \u2705 \u2705 MySQL \u26d4\ufe0f \u26d4\ufe0f \u2705","title":"Overview"},{"location":"#sqldelight","text":"SQLDelight generates typesafe APIs from your SQL statements. It compile-time verifies your schema, statements, and migrations and provides IDE features like autocomplete and refactoring which make writing and maintaining SQL simple. SQLDelight currently supports the SQLite dialect and there are supported SQLite drivers on Android, JVM, iOS, and Windows. Android iOS JVM SQLite \u2705 \u2705 \u2705 MySQL \u26d4\ufe0f \u26d4\ufe0f \u2705","title":"SQLDelight"},{"location":"CHANGELOG/","text":"Change Log Version 1.2.2 (2020-01-22) New: [Runtime] Support for Windows (mingW), tvOS, watchOS, and macOS architectures. Fix: [Compiler] Return type of sum() should be nullable. Fix: [Paging] Pass Transacter into QueryDataSourceFactory to avoid race conditions. Fix: [IntelliJ Plugin] Don't search through dependencies when looking for a file's package name. Fix: [Gradle] #862 Change validator logs in Gradle to debug level. Enhancement: [Gradle] Convert GenerateSchemaTask to use Gradle worker. Note: sqldelight-runtime artifact renamed to runtime. Version 1.2.1 (2019-12-11) Fix: [Gradle] Kotlin Native 1.3.60 support. Fix: [Gradle] #1287 Warning when syncing. Fix: [Compiler] #1469 SynetheticAccessor creation for query. Fix: [JVM Driver] Fixed memory leak. NOTE: The coroutine extension artifact requires kotlinx bintray maven repository be added to your buildscript. Version 1.2.0 (2019-08-30) New: [Runtime] Stable Flow api. Fix: [Gradle] Kotlin Native 1.3.50 support. Fix: [Gradle] #1380 Clean build sometimes fails. Fix: [Gradle] #1348 Running verify tasks prints \"Could not retrieve functions\". Fix: [Compile] #1405 Can't build project if query contains FTS table joined. Fix: [Gradle] #1266 Sporadic gradle build failure while having multiple database modules. Version 1.1.4 (2019-07-11) New: [Runtime] Experimental kotlin Flow api. Fix: [Gradle] Kotlin/Native 1.3.40 compatibility. Fix: [Gradle] #1243 Fix for usage of SQLDelight with Gradle configure on demand. Fix: [Gradle] #1385 Fix for usage of SQLDelight with incremental annotation processing. Fix: [Gradle] Allow gradle tasks to cache. Fix: [Gradle] #1274 Enable usage of sqldelight extension with kotlin dsl. Fix: [Compiler] Unique ids are generated for each query deterministically. Fix: [Compiler] Only notify listening queries when a transaction is complete. Fix: [JVM Driver] #1370 Force JdbcSqliteDriver users to supply a DB URL. Version 1.1.3 (2019-04-14) Gradle Metadata 1.0 release. Version 1.1.2 (2019-04-14) New: [Runtime] #1267 Logging driver decorator. Fix: [Compiler] #1254 Split string literals which are longer than 2^16 characters. Fix: [Gradle] #1260 generated sources are recognized as iOS source in Multiplatform Project. Fix: [IDE] #1290 kotlin.KotlinNullPointerException in CopyAsSqliteAction.kt:43. Fix: [Gradle] #1268 Running linkDebugFrameworkIos* tasks fail in recent versions. Version 1.1.1 (2019-03-01) Fix: [Gradle] Fix module dependency compilation for android projects. Fix: [Gradle] #1246 Set up api dependencies in afterEvaluate. Fix: [Compiler] Array types are properly printed. Version 1.1.0 (2019-02-27) New: [Gradle] #502 Allow specifying schema module dependencies. Enhancement: [Compiler] #1111 Table errors are sorted before other errors. Fix: [Compiler] #1225 Return the correct type for REAL literals. Fix: [Compiler] #1218 docid propagates through triggers. Version 1.0.3 (2019-01-30) Enhancement: [Runtime] #1195 Native Driver/Runtime Arm32. Enhancement: [Runtime] #1190 Expose the mapper from the Query type. Version 1.0.2 (2019-01-26) Fix: [Gradle Plugin] Update to kotlin 1.3.20. Fix: [Runtime] Transactions no longer swallow exceptions. Version 1.0.1 (2019-01-21) Enhancement: [Native Driver] Allow passing directory name to DatabaseConfiguration. Enhancement: [Compiler] #1173 Files without a package fail compilation. Fix: [IDE] Properly report IDE errors to Square. Fix: [IDE] #1162 Types in the same package show as error but work fine. Fix: [IDE] #1166 Renaming a table fails with NPE. Fix: [Compiler] #1167 Throws an exception when trying to parse complex SQL statements with UNION and SELECT. Version 1.0.0 (2019-01-08) New: Complete overhaul of generated code, now in kotlin. New: RxJava2 extensions artifact. New: Android Paging extensions artifact. New: Kotlin Multiplatform support. New: Android, iOS and JVM SQLite driver artifacts. New: Transaction API. Version 0.7.0 (2018-02-12) New: Generated code has been updated to use the Support SQLite library only. All queries now generate statement objects instead of a raw strings. New: Statement folding in the IDE. New: Boolean types are now automatically handled. Fix: Remove deprecated marshals from code generation. Fix: Correct 'avg' SQL function type mapping to be REAL. Fix: Correctly detect 'julianday' SQL function. Version 0.6.1 (2017-03-22) New: Delete Update and Insert statements without arguments get compiled statements generated. Fix: Using clause within a view used in a subquery doesn't error. Fix: Duplicate types on generated Mapper removed. Fix: Subqueries can be used in expressions that check against arguments. Version 0.6.0 (2017-03-06) New: Select queries are now exposed as a SqlDelightStatement factory instead of string constants. New: Query JavaDoc is now copied to statement and mapper factories. New: Emit string constants for view names. Fix: Queries on views which require factories now correctly require those factories are arguments. Fix: Validate the number of arguments to an insert matches the number of columns specified. Fix: Properly encode blob literals used in where clauses. Gradle 3.3 or newer is required for this release. Version 0.5.1 (2016-10-24) New: Compiled statements extend an abstract type. Fix: Primitive types in parameters will be boxed if nullable. Fix: All required factories for bind args are present in factory method. Fix: Escaped column names are marshalled correctly. Version 0.5.0 (2016-10-19) New: SQLite arguments can be passed typesafely through the Factory New: IntelliJ plugin performs formatting on .sq files New: Support for SQLite timestamp literals Fix: Parameterized types can be clicked through in IntelliJ Fix: Escaped column names no longer throw RuntimeExceptions if grabbed from Cursor. Fix: Gradle plugin doesn't crash trying to print exceptions. Version 0.4.4 (2016-07-20) New: Native support for shorts as column java type New: Javadoc on generated mappers and factory methods Fix: group_concat and nullif functions have proper nullability Fix: Compatibility with Android Studio 2.2-alpha Fix: WITH RECURSIVE no longer crashes plugin Version 0.4.3 (2016-07-07) New: Compilation errors link to source file. New: Right-click to copy SQLDelight code as valid SQLite. New: Javadoc on named statements will appear on generated Strings. Fix: Generated view models include nullability annotations. Fix: Generated code from unions has proper type and nullability to support all possible columns. Fix: sum and round SQLite functions have proper type in generated code. Fix: CAST's, inner selects bugfixes. Fix: Autocomplete in CREATE TABLE statements. Fix: SQLite keywords can be used in packages. Version 0.4.2 (2016-06-16) New: Marshal can be created from the factory. Fix: IntelliJ plugin generates factory methods with proper generic order. Fix: Function names can use any casing. Version 0.4.1 (2016-06-14) Fix: IntelliJ plugin generates classes with proper generic order. Fix: Column definitions can use any casing. Version 0.4.0 (2016-06-14) New: Mappers are generated per query instead of per table. New: Java types can be imported in .sq files. New: SQLite functions are validated. Fix: Remove duplicate errors. Fix: Uppercase column names and java keyword column names do not error. Version 0.3.2 (2016-05-14) New: Autocompletion and find usages now work for views and aliases. Fix: Compile-time validation now allows functions to be used in selects. Fix: Support insert statements which only declare default values. Fix: Plugin no longer crashes when a project not using SQLDelight is imported. Version 0.3.1 (2016-04-27) Fix: Interface visibility changed back to public to avoid Illegal Access runtime exceptions from method references. Fix: Subexpressions are evaluated properly. Version 0.3.0 (2016-04-26) New: Column definitions use SQLite types and can have additional 'AS' constraint to specify java type. New: Bug reports can be sent from the IDE. Fix: Autocomplete functions properly. Fix: SQLDelight model files update on .sq file edit. Removed: Attached databases no longer supported. Version 0.2.2 (2016-03-07) New: Compile-time validation of the columns used by insert, update, delete, index, and trigger statements. Fix: Don't crash IDE plugin on file move/create. Version 0.2.1 (2016-03-07) New: Ctrl+ / (Cmd+ / on OSX) toggles comment of the selected line(s). New: Compile-time validation of the columns used by SQL queries. Fix: Support Windows paths in both the IDE and Gradle plugin. Version 0.2.0 (2016-02-29) New: Added copy constructor to Marshal class. New: Update to Kotlin 1.0 final. Fix: Report 'sqldelight' folder structure problems in a non-failing way. Fix: Forbid columns named table_name . Their generated constant clashes with the table name constant. Fix: Ensure IDE plugin generates model classes immediately and regardless of whether .sq files were opened. Fix: Support Windows paths in both the IDE and Gradle plugin. Version 0.1.2 (2016-02-13) Fix: Remove code which prevented the Gradle plugin from being used in most projects. Fix: Add missing compiler dependency on the Antlr runtime. Version 0.1.1 (2016-02-12) Fix: Ensure the Gradle plugin points to the same version of the runtime as itself. Version 0.1.0 (2016-02-12) Initial release.","title":"Change Log"},{"location":"CHANGELOG/#change-log","text":"","title":"Change Log"},{"location":"CHANGELOG/#version-122-2020-01-22","text":"New: [Runtime] Support for Windows (mingW), tvOS, watchOS, and macOS architectures. Fix: [Compiler] Return type of sum() should be nullable. Fix: [Paging] Pass Transacter into QueryDataSourceFactory to avoid race conditions. Fix: [IntelliJ Plugin] Don't search through dependencies when looking for a file's package name. Fix: [Gradle] #862 Change validator logs in Gradle to debug level. Enhancement: [Gradle] Convert GenerateSchemaTask to use Gradle worker. Note: sqldelight-runtime artifact renamed to runtime.","title":"Version 1.2.2 (2020-01-22)"},{"location":"CHANGELOG/#version-121-2019-12-11","text":"Fix: [Gradle] Kotlin Native 1.3.60 support. Fix: [Gradle] #1287 Warning when syncing. Fix: [Compiler] #1469 SynetheticAccessor creation for query. Fix: [JVM Driver] Fixed memory leak. NOTE: The coroutine extension artifact requires kotlinx bintray maven repository be added to your buildscript.","title":"Version 1.2.1 (2019-12-11)"},{"location":"CHANGELOG/#version-120-2019-08-30","text":"New: [Runtime] Stable Flow api. Fix: [Gradle] Kotlin Native 1.3.50 support. Fix: [Gradle] #1380 Clean build sometimes fails. Fix: [Gradle] #1348 Running verify tasks prints \"Could not retrieve functions\". Fix: [Compile] #1405 Can't build project if query contains FTS table joined. Fix: [Gradle] #1266 Sporadic gradle build failure while having multiple database modules.","title":"Version 1.2.0 (2019-08-30)"},{"location":"CHANGELOG/#version-114-2019-07-11","text":"New: [Runtime] Experimental kotlin Flow api. Fix: [Gradle] Kotlin/Native 1.3.40 compatibility. Fix: [Gradle] #1243 Fix for usage of SQLDelight with Gradle configure on demand. Fix: [Gradle] #1385 Fix for usage of SQLDelight with incremental annotation processing. Fix: [Gradle] Allow gradle tasks to cache. Fix: [Gradle] #1274 Enable usage of sqldelight extension with kotlin dsl. Fix: [Compiler] Unique ids are generated for each query deterministically. Fix: [Compiler] Only notify listening queries when a transaction is complete. Fix: [JVM Driver] #1370 Force JdbcSqliteDriver users to supply a DB URL.","title":"Version 1.1.4 (2019-07-11)"},{"location":"CHANGELOG/#version-113-2019-04-14","text":"Gradle Metadata 1.0 release.","title":"Version 1.1.3 (2019-04-14)"},{"location":"CHANGELOG/#version-112-2019-04-14","text":"New: [Runtime] #1267 Logging driver decorator. Fix: [Compiler] #1254 Split string literals which are longer than 2^16 characters. Fix: [Gradle] #1260 generated sources are recognized as iOS source in Multiplatform Project. Fix: [IDE] #1290 kotlin.KotlinNullPointerException in CopyAsSqliteAction.kt:43. Fix: [Gradle] #1268 Running linkDebugFrameworkIos* tasks fail in recent versions.","title":"Version 1.1.2 (2019-04-14)"},{"location":"CHANGELOG/#version-111-2019-03-01","text":"Fix: [Gradle] Fix module dependency compilation for android projects. Fix: [Gradle] #1246 Set up api dependencies in afterEvaluate. Fix: [Compiler] Array types are properly printed.","title":"Version 1.1.1 (2019-03-01)"},{"location":"CHANGELOG/#version-110-2019-02-27","text":"New: [Gradle] #502 Allow specifying schema module dependencies. Enhancement: [Compiler] #1111 Table errors are sorted before other errors. Fix: [Compiler] #1225 Return the correct type for REAL literals. Fix: [Compiler] #1218 docid propagates through triggers.","title":"Version 1.1.0 (2019-02-27)"},{"location":"CHANGELOG/#version-103-2019-01-30","text":"Enhancement: [Runtime] #1195 Native Driver/Runtime Arm32. Enhancement: [Runtime] #1190 Expose the mapper from the Query type.","title":"Version 1.0.3 (2019-01-30)"},{"location":"CHANGELOG/#version-102-2019-01-26","text":"Fix: [Gradle Plugin] Update to kotlin 1.3.20. Fix: [Runtime] Transactions no longer swallow exceptions.","title":"Version 1.0.2 (2019-01-26)"},{"location":"CHANGELOG/#version-101-2019-01-21","text":"Enhancement: [Native Driver] Allow passing directory name to DatabaseConfiguration. Enhancement: [Compiler] #1173 Files without a package fail compilation. Fix: [IDE] Properly report IDE errors to Square. Fix: [IDE] #1162 Types in the same package show as error but work fine. Fix: [IDE] #1166 Renaming a table fails with NPE. Fix: [Compiler] #1167 Throws an exception when trying to parse complex SQL statements with UNION and SELECT.","title":"Version 1.0.1 (2019-01-21)"},{"location":"CHANGELOG/#version-100-2019-01-08","text":"New: Complete overhaul of generated code, now in kotlin. New: RxJava2 extensions artifact. New: Android Paging extensions artifact. New: Kotlin Multiplatform support. New: Android, iOS and JVM SQLite driver artifacts. New: Transaction API.","title":"Version 1.0.0 (2019-01-08)"},{"location":"CHANGELOG/#version-070-2018-02-12","text":"New: Generated code has been updated to use the Support SQLite library only. All queries now generate statement objects instead of a raw strings. New: Statement folding in the IDE. New: Boolean types are now automatically handled. Fix: Remove deprecated marshals from code generation. Fix: Correct 'avg' SQL function type mapping to be REAL. Fix: Correctly detect 'julianday' SQL function.","title":"Version 0.7.0 (2018-02-12)"},{"location":"CHANGELOG/#version-061-2017-03-22","text":"New: Delete Update and Insert statements without arguments get compiled statements generated. Fix: Using clause within a view used in a subquery doesn't error. Fix: Duplicate types on generated Mapper removed. Fix: Subqueries can be used in expressions that check against arguments.","title":"Version 0.6.1 (2017-03-22)"},{"location":"CHANGELOG/#version-060-2017-03-06","text":"New: Select queries are now exposed as a SqlDelightStatement factory instead of string constants. New: Query JavaDoc is now copied to statement and mapper factories. New: Emit string constants for view names. Fix: Queries on views which require factories now correctly require those factories are arguments. Fix: Validate the number of arguments to an insert matches the number of columns specified. Fix: Properly encode blob literals used in where clauses. Gradle 3.3 or newer is required for this release.","title":"Version 0.6.0 (2017-03-06)"},{"location":"CHANGELOG/#version-051-2016-10-24","text":"New: Compiled statements extend an abstract type. Fix: Primitive types in parameters will be boxed if nullable. Fix: All required factories for bind args are present in factory method. Fix: Escaped column names are marshalled correctly.","title":"Version 0.5.1 (2016-10-24)"},{"location":"CHANGELOG/#version-050-2016-10-19","text":"New: SQLite arguments can be passed typesafely through the Factory New: IntelliJ plugin performs formatting on .sq files New: Support for SQLite timestamp literals Fix: Parameterized types can be clicked through in IntelliJ Fix: Escaped column names no longer throw RuntimeExceptions if grabbed from Cursor. Fix: Gradle plugin doesn't crash trying to print exceptions.","title":"Version 0.5.0 (2016-10-19)"},{"location":"CHANGELOG/#version-044-2016-07-20","text":"New: Native support for shorts as column java type New: Javadoc on generated mappers and factory methods Fix: group_concat and nullif functions have proper nullability Fix: Compatibility with Android Studio 2.2-alpha Fix: WITH RECURSIVE no longer crashes plugin","title":"Version 0.4.4 (2016-07-20)"},{"location":"CHANGELOG/#version-043-2016-07-07","text":"New: Compilation errors link to source file. New: Right-click to copy SQLDelight code as valid SQLite. New: Javadoc on named statements will appear on generated Strings. Fix: Generated view models include nullability annotations. Fix: Generated code from unions has proper type and nullability to support all possible columns. Fix: sum and round SQLite functions have proper type in generated code. Fix: CAST's, inner selects bugfixes. Fix: Autocomplete in CREATE TABLE statements. Fix: SQLite keywords can be used in packages.","title":"Version 0.4.3 (2016-07-07)"},{"location":"CHANGELOG/#version-042-2016-06-16","text":"New: Marshal can be created from the factory. Fix: IntelliJ plugin generates factory methods with proper generic order. Fix: Function names can use any casing.","title":"Version 0.4.2 (2016-06-16)"},{"location":"CHANGELOG/#version-041-2016-06-14","text":"Fix: IntelliJ plugin generates classes with proper generic order. Fix: Column definitions can use any casing.","title":"Version 0.4.1 (2016-06-14)"},{"location":"CHANGELOG/#version-040-2016-06-14","text":"New: Mappers are generated per query instead of per table. New: Java types can be imported in .sq files. New: SQLite functions are validated. Fix: Remove duplicate errors. Fix: Uppercase column names and java keyword column names do not error.","title":"Version 0.4.0 (2016-06-14)"},{"location":"CHANGELOG/#version-032-2016-05-14","text":"New: Autocompletion and find usages now work for views and aliases. Fix: Compile-time validation now allows functions to be used in selects. Fix: Support insert statements which only declare default values. Fix: Plugin no longer crashes when a project not using SQLDelight is imported.","title":"Version 0.3.2 (2016-05-14)"},{"location":"CHANGELOG/#version-031-2016-04-27","text":"Fix: Interface visibility changed back to public to avoid Illegal Access runtime exceptions from method references. Fix: Subexpressions are evaluated properly.","title":"Version 0.3.1 (2016-04-27)"},{"location":"CHANGELOG/#version-030-2016-04-26","text":"New: Column definitions use SQLite types and can have additional 'AS' constraint to specify java type. New: Bug reports can be sent from the IDE. Fix: Autocomplete functions properly. Fix: SQLDelight model files update on .sq file edit. Removed: Attached databases no longer supported.","title":"Version 0.3.0 (2016-04-26)"},{"location":"CHANGELOG/#version-022-2016-03-07","text":"New: Compile-time validation of the columns used by insert, update, delete, index, and trigger statements. Fix: Don't crash IDE plugin on file move/create.","title":"Version 0.2.2 (2016-03-07)"},{"location":"CHANGELOG/#version-021-2016-03-07","text":"New: Ctrl+ / (Cmd+ / on OSX) toggles comment of the selected line(s). New: Compile-time validation of the columns used by SQL queries. Fix: Support Windows paths in both the IDE and Gradle plugin.","title":"Version 0.2.1 (2016-03-07)"},{"location":"CHANGELOG/#version-020-2016-02-29","text":"New: Added copy constructor to Marshal class. New: Update to Kotlin 1.0 final. Fix: Report 'sqldelight' folder structure problems in a non-failing way. Fix: Forbid columns named table_name . Their generated constant clashes with the table name constant. Fix: Ensure IDE plugin generates model classes immediately and regardless of whether .sq files were opened. Fix: Support Windows paths in both the IDE and Gradle plugin.","title":"Version 0.2.0 (2016-02-29)"},{"location":"CHANGELOG/#version-012-2016-02-13","text":"Fix: Remove code which prevented the Gradle plugin from being used in most projects. Fix: Add missing compiler dependency on the Antlr runtime.","title":"Version 0.1.2 (2016-02-13)"},{"location":"CHANGELOG/#version-011-2016-02-12","text":"Fix: Ensure the Gradle plugin points to the same version of the runtime as itself.","title":"Version 0.1.1 (2016-02-12)"},{"location":"CHANGELOG/#version-010-2016-02-12","text":"Initial release.","title":"Version 0.1.0 (2016-02-12)"},{"location":"android/","text":"SQLDelight SQLDelight generates typesafe APIs from your SQL statements. It compile-time verifies your schema, statements, and migrations and provides IDE features like autocomplete and refactoring which make writing and maintaining SQL simple. SQLDelight currently supports the SQLite dialect and there are supported SQLite drivers on Android, JVM, iOS, and Windows. Example To use SQLDelight, apply the gradle plugin and put your SQL statements in a .sq file in src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: Android dependencies { implementation \"com.squareup.sqldelight:android-driver:1.2.1\" } val driver : SqlDriver = AndroidSqliteDriver ( Database . Schema , context , \"test.db\" ) iOS, or Windows (Using Kotlin/Native) dependencies { implementation \"com.squareup.sqldelight:native-driver:1.2.1\" } val driver : SqlDriver = NativeSqliteDriver ( Database . Schema , \"test.db\" ) JVM dependencies { implementation \"com.squareup.sqldelight:sqlite-driver:1.2.1\" } val driver : SqlDriver = JdbcSqliteDriver ( JdbcSqliteDriver . IN_MEMORY ) Database . Schema . create ( driver ) SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer.Impl(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer.Impl(15, \"Ryan Getzlaf\"), HockeyPlayer.Impl(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player )","title":"SQLDelight"},{"location":"android/#sqldelight","text":"SQLDelight generates typesafe APIs from your SQL statements. It compile-time verifies your schema, statements, and migrations and provides IDE features like autocomplete and refactoring which make writing and maintaining SQL simple. SQLDelight currently supports the SQLite dialect and there are supported SQLite drivers on Android, JVM, iOS, and Windows.","title":"SQLDelight"},{"location":"android/#example","text":"To use SQLDelight, apply the gradle plugin and put your SQL statements in a .sq file in src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of:","title":"Example"},{"location":"android/#android","text":"dependencies { implementation \"com.squareup.sqldelight:android-driver:1.2.1\" } val driver : SqlDriver = AndroidSqliteDriver ( Database . Schema , context , \"test.db\" )","title":"Android"},{"location":"android/#ios-or-windows-using-kotlinnative","text":"dependencies { implementation \"com.squareup.sqldelight:native-driver:1.2.1\" } val driver : SqlDriver = NativeSqliteDriver ( Database . Schema , \"test.db\" )","title":"iOS, or Windows (Using Kotlin/Native)"},{"location":"android/#jvm","text":"dependencies { implementation \"com.squareup.sqldelight:sqlite-driver:1.2.1\" } val driver : SqlDriver = JdbcSqliteDriver ( JdbcSqliteDriver . IN_MEMORY ) Database . Schema . create ( driver ) SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer.Impl(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer.Impl(15, \"Ryan Getzlaf\"), HockeyPlayer.Impl(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player )","title":"JVM"},{"location":"android/android_paging/","text":"Android Paging To use SQLDelight with Android's Paging Library add a dependency on the paging extension artifact. dependencies { implementation \"com.squareup.sqldelight:android-paging-extensions:1.2.1\" } To create a DataSource write a query to get the number of rows and a query that takes an offset and a limit. countPlayers : SELECT count ( * ) FROM hockeyPlayer ; players : SELECT * FROM hockeyPlayer LIMIT : limit OFFSET : offset ; val dataSource = QueryDataSourceFactory ( queryProvider = playerQueries :: players , countQuery = playerQueries . countPlayers (), transacter = playerQueries ). create ()","title":"Android Paging"},{"location":"android/android_paging/#android-paging","text":"To use SQLDelight with Android's Paging Library add a dependency on the paging extension artifact. dependencies { implementation \"com.squareup.sqldelight:android-paging-extensions:1.2.1\" } To create a DataSource write a query to get the number of rows and a query that takes an offset and a limit. countPlayers : SELECT count ( * ) FROM hockeyPlayer ; players : SELECT * FROM hockeyPlayer LIMIT : limit OFFSET : offset ; val dataSource = QueryDataSourceFactory ( queryProvider = playerQueries :: players , countQuery = playerQueries . countPlayers (), transacter = playerQueries ). create ()","title":"Android Paging"},{"location":"android/code_of_conduct/","text":"Open Source Code of Conduct At Square, we are committed to contributing to the open source community and simplifying the process of releasing and managing open source software. We\u2019ve seen incredible support and enthusiasm from thousands of people who have already contributed to our projects\u200a\u2014\u200aand we want to ensure our community continues to be truly open for everyone. This code of conduct outlines our expectations for participants, as well as steps to reporting unacceptable behavior. We are committed to providing a welcoming and inspiring community for all and expect our code of conduct to be honored. Square\u2019s open source community strives to: Be open : We invite anyone to participate in any aspect of our projects. Our community is open, and any responsibility can be carried by a contributor who demonstrates the required capacity and competence. Be considerate : People use our work, and we depend on the work of others. Consider users and colleagues before taking action. For example, changes to code, infrastructure, policy, and documentation may negatively impact others. Be respectful : We expect people to work together to resolve conflict, assume good intentions, and act with empathy. Do not turn disagreements into personal attacks. Be collaborative : Collaboration reduces redundancy and improves the quality of our work. We strive for transparency within our open source community, and we work closely with upstream developers and others in the free software community to coordinate our efforts. Be pragmatic : Questions are encouraged and should be asked early in the process to avoid problems later. Be thoughtful and considerate when seeking out the appropriate forum for your questions. Those who are asked should be responsive and helpful. Step down considerately : Members of every project come and go. When somebody leaves or disengages from the project, they should make it known and take the proper steps to ensure that others can pick up where they left off. This code is not exhaustive or complete. It serves to distill our common understanding of a collaborative, shared environment, and goals. We expect it to be followed in spirit as much as in the letter. Diversity Statement We encourage everyone to participate and are committed to building a community for all. Although we may not be able to satisfy everyone, we all agree that everyone is equal. Whenever a participant has made a mistake, we expect them to take responsibility for it. If someone has been harmed or offended, it is our responsibility to listen carefully and respectfully, and do our best to right the wrong. Although this list cannot be exhaustive, we explicitly honor diversity in age, culture, ethnicity, gender identity or expression, language, national origin, political beliefs, profession, race, religion, sexual orientation, socioeconomic status, and technical ability. We will not tolerate discrimination based on any of the protected characteristics above, including participants with disabilities. Reporting Issues If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . For more details, please see our Reporting Guidelines below. Thanks Some of the ideas and wording for the statements and guidelines above were based on work by the Twitter , Ubuntu , GDC , and Django communities. We are thankful for their work. Reporting Guide If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . All reports will be handled with discretion. In your report please include: Your contact information. Names (real, nicknames, or pseudonyms) of any individuals involved. If there are additional witnesses, please include them as well. Your account of what occurred, and if you believe the incident is ongoing. If there is a publicly available record (e.g. a mailing list archive or a public IRC logger), please include a link. Any additional information that may be helpful. After filing a report, a representative from the Square Code of Conduct committee will contact you personally. The committee will then review the incident, follow up with any additional questions, and make a decision as to how to respond. Anyone asked to stop unacceptable behavior is expected to comply immediately. If an individual engages in unacceptable behavior, the Square Code of Conduct committee may take any action they deem appropriate, up to and including a permanent ban from all of Square spaces without warning.","title":"Open Source Code of Conduct"},{"location":"android/code_of_conduct/#open-source-code-of-conduct","text":"At Square, we are committed to contributing to the open source community and simplifying the process of releasing and managing open source software. We\u2019ve seen incredible support and enthusiasm from thousands of people who have already contributed to our projects\u200a\u2014\u200aand we want to ensure our community continues to be truly open for everyone. This code of conduct outlines our expectations for participants, as well as steps to reporting unacceptable behavior. We are committed to providing a welcoming and inspiring community for all and expect our code of conduct to be honored. Square\u2019s open source community strives to: Be open : We invite anyone to participate in any aspect of our projects. Our community is open, and any responsibility can be carried by a contributor who demonstrates the required capacity and competence. Be considerate : People use our work, and we depend on the work of others. Consider users and colleagues before taking action. For example, changes to code, infrastructure, policy, and documentation may negatively impact others. Be respectful : We expect people to work together to resolve conflict, assume good intentions, and act with empathy. Do not turn disagreements into personal attacks. Be collaborative : Collaboration reduces redundancy and improves the quality of our work. We strive for transparency within our open source community, and we work closely with upstream developers and others in the free software community to coordinate our efforts. Be pragmatic : Questions are encouraged and should be asked early in the process to avoid problems later. Be thoughtful and considerate when seeking out the appropriate forum for your questions. Those who are asked should be responsive and helpful. Step down considerately : Members of every project come and go. When somebody leaves or disengages from the project, they should make it known and take the proper steps to ensure that others can pick up where they left off. This code is not exhaustive or complete. It serves to distill our common understanding of a collaborative, shared environment, and goals. We expect it to be followed in spirit as much as in the letter.","title":"Open Source Code of Conduct"},{"location":"android/code_of_conduct/#diversity-statement","text":"We encourage everyone to participate and are committed to building a community for all. Although we may not be able to satisfy everyone, we all agree that everyone is equal. Whenever a participant has made a mistake, we expect them to take responsibility for it. If someone has been harmed or offended, it is our responsibility to listen carefully and respectfully, and do our best to right the wrong. Although this list cannot be exhaustive, we explicitly honor diversity in age, culture, ethnicity, gender identity or expression, language, national origin, political beliefs, profession, race, religion, sexual orientation, socioeconomic status, and technical ability. We will not tolerate discrimination based on any of the protected characteristics above, including participants with disabilities.","title":"Diversity Statement"},{"location":"android/code_of_conduct/#reporting-issues","text":"If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . For more details, please see our Reporting Guidelines below.","title":"Reporting Issues"},{"location":"android/code_of_conduct/#thanks","text":"Some of the ideas and wording for the statements and guidelines above were based on work by the Twitter , Ubuntu , GDC , and Django communities. We are thankful for their work.","title":"Thanks"},{"location":"android/code_of_conduct/#reporting-guide","text":"If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . All reports will be handled with discretion. In your report please include: Your contact information. Names (real, nicknames, or pseudonyms) of any individuals involved. If there are additional witnesses, please include them as well. Your account of what occurred, and if you believe the incident is ongoing. If there is a publicly available record (e.g. a mailing list archive or a public IRC logger), please include a link. Any additional information that may be helpful. After filing a report, a representative from the Square Code of Conduct committee will contact you personally. The committee will then review the incident, follow up with any additional questions, and make a decision as to how to respond. Anyone asked to stop unacceptable behavior is expected to comply immediately. If an individual engages in unacceptable behavior, the Square Code of Conduct committee may take any action they deem appropriate, up to and including a permanent ban from all of Square spaces without warning.","title":"Reporting Guide"},{"location":"android/custom_column_types/","text":"Custom Column Types If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) ) Enums As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as TEXT. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Custom Column Types"},{"location":"android/custom_column_types/#custom-column-types","text":"If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) )","title":"Custom Column Types"},{"location":"android/custom_column_types/#enums","text":"As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as TEXT. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Enums"},{"location":"android/custom_projections/","text":"Custom Projections By default queries will return a data class implementation of the table schema. To override this behavior pass a custom mapper to the query function. Your custom mapper will receive typesafe parameters which are the projection of your select statement. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () }) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] But the custom mapping is there when this isn't possible, for example getting a Parcelable type for query results on Android.","title":"Custom Projections"},{"location":"android/custom_projections/#custom-projections","text":"By default queries will return a data class implementation of the table schema. To override this behavior pass a custom mapper to the query function. Your custom mapper will receive typesafe parameters which are the projection of your select statement. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () }) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] But the custom mapping is there when this isn't possible, for example getting a Parcelable type for query results on Android.","title":"Custom Projections"},{"location":"android/gradle/","text":"Gradle buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.2.1' } } apply plugin: 'com.squareup.sqldelight' For Android projects, the plugin will create a default database called Database using the project package name. For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) } // For native targets, whether sqlite should be automatically linked. // Defaults to true. linkSqlite = false } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) } linkSqlite = false } Snapshots Snapshots of the development version (including the IDE plugin zip) are available in Sonatype's snapshots repository . Upgrading From Previous Versions There's a separate guide for upgrading from 0.7 and other pre-1.0 versions here","title":"Gradle"},{"location":"android/gradle/#gradle","text":"buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.2.1' } } apply plugin: 'com.squareup.sqldelight' For Android projects, the plugin will create a default database called Database using the project package name. For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) } // For native targets, whether sqlite should be automatically linked. // Defaults to true. linkSqlite = false } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) } linkSqlite = false }","title":"Gradle"},{"location":"android/gradle/#snapshots","text":"Snapshots of the development version (including the IDE plugin zip) are available in Sonatype's snapshots repository .","title":"Snapshots"},{"location":"android/gradle/#upgrading-from-previous-versions","text":"There's a separate guide for upgrading from 0.7 and other pre-1.0 versions here","title":"Upgrading From Previous Versions"},{"location":"android/intellij_plugin/","text":"IntelliJ Plugin The IntelliJ plugin provides language-level features for .sq files, including: - Syntax highlighting - Refactoring/Find usages - Code autocompletion - Generate Queries files after edits - Right click to copy as valid SQLite - Compiler errors in IDE click through to file It can be installed from Android Studio by navigating Android Studio -> Preferences -> Plugins -> Browse repositories -> Search for SQLDelight","title":"IntelliJ Plugin"},{"location":"android/intellij_plugin/#intellij-plugin","text":"The IntelliJ plugin provides language-level features for .sq files, including: - Syntax highlighting - Refactoring/Find usages - Code autocompletion - Generate Queries files after edits - Right click to copy as valid SQLite - Compiler errors in IDE click through to file It can be installed from Android Studio by navigating Android Studio -> Preferences -> Plugins -> Browse repositories -> Search for SQLDelight","title":"IntelliJ Plugin"},{"location":"android/migrations/","text":"Migrations The .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; Migration files go in the src/main/sqldelight folder. These SQL statements are run by Database.Schema.migrate() . This is automatic for the Android and iOS drivers. You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task. You should probably do this before you create your first migration.","title":"Migrations"},{"location":"android/migrations/#migrations","text":"The .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; Migration files go in the src/main/sqldelight folder. These SQL statements are run by Database.Schema.migrate() . This is automatic for the Android and iOS drivers. You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task. You should probably do this before you create your first migration.","title":"Migrations"},{"location":"android/multiplatform/","text":"Multiplatform To use SQLDelight in Kotlin multiplatform configure the Gradle plugin with a package to generate code into. apply plugin: \"org.jetbrains.kotlin.multiplatform\" apply plugin: \"com.squareup.sqldelight\" sqldelight { MyDatabase { packageName = \"com.example.hockey\" } } Put .sq files in the src/commonMain/sqldelight directory, and then expect a SqlDriver to be provided by individual platforms when creating the Database . Migration files should also be in the same src/commonMain/sqldelight directory. Multiplatform requires the gradle metadata feature , which you need to enable via the settings.gradle file in the project root: enableFeaturePreview ( 'GRADLE_METADATA' )","title":"Multiplatform"},{"location":"android/multiplatform/#multiplatform","text":"To use SQLDelight in Kotlin multiplatform configure the Gradle plugin with a package to generate code into. apply plugin: \"org.jetbrains.kotlin.multiplatform\" apply plugin: \"com.squareup.sqldelight\" sqldelight { MyDatabase { packageName = \"com.example.hockey\" } } Put .sq files in the src/commonMain/sqldelight directory, and then expect a SqlDriver to be provided by individual platforms when creating the Database . Migration files should also be in the same src/commonMain/sqldelight directory. Multiplatform requires the gradle metadata feature , which you need to enable via the settings.gradle file in the project root: enableFeaturePreview ( 'GRADLE_METADATA' )","title":"Multiplatform"},{"location":"android/query_arguments/","text":"Query Arguments .sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec Strong\" , \"Jake Wharton\" , \"Matt Precious\" )) Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Query Arguments"},{"location":"android/query_arguments/#query-arguments","text":".sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec Strong\" , \"Jake Wharton\" , \"Matt Precious\" )) Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Query Arguments"},{"location":"android/rxjava/","text":"RxJava To observe a query, depend on the RxJava extensions artifact and use the extension method it provides: dependencies { implementation \"com.squareup.sqldelight:rxjava2-extensions:1.2.1\" } val players : Observable < List < HockeyPlayer >> = playerQueries . selectAll () . asObservable () . mapToList ()","title":"RxJava"},{"location":"android/rxjava/#rxjava","text":"To observe a query, depend on the RxJava extensions artifact and use the extension method it provides: dependencies { implementation \"com.squareup.sqldelight:rxjava2-extensions:1.2.1\" } val players : Observable < List < HockeyPlayer >> = playerQueries . selectAll () . asObservable () . mapToList ()","title":"RxJava"},{"location":"android/supported_dialects/","text":"Supported Dialects SQLite Full support of dialect including views, triggers, indexes, FTS tables, etc. If features are missing please file an issue!","title":"Supported Dialects"},{"location":"android/supported_dialects/#supported-dialects","text":"","title":"Supported Dialects"},{"location":"android/supported_dialects/#sqlite","text":"Full support of dialect including views, triggers, indexes, FTS tables, etc. If features are missing please file an issue!","title":"SQLite"},{"location":"android/transactions/","text":"Transactions If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . foreach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"android/transactions/#transactions","text":"If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . foreach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"android/types/","text":"Types SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. SQLDelight natively supports Long, Double, String, ByteArray, Int, Short, Float, and Booleans. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray some_int INTEGER AS Int , -- Stored as INTEGER in db, retrieved as Int some_short INTEGER AS Short , -- Stored as INTEGER in db, retrieved as Short some_float REAL AS Float -- Stored as REAL in db, retrieved as Float ); Boolean columns are stored in the db as INTEGER , and so they can be given INTEGER column constraints. Use DEFAULT 0 to default to false, for example. CREATE TABLE hockey_player ( injured INTEGER AS Boolean DEFAULT 0 )","title":"Types"},{"location":"android/types/#types","text":"SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. SQLDelight natively supports Long, Double, String, ByteArray, Int, Short, Float, and Booleans. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray some_int INTEGER AS Int , -- Stored as INTEGER in db, retrieved as Int some_short INTEGER AS Short , -- Stored as INTEGER in db, retrieved as Short some_float REAL AS Float -- Stored as REAL in db, retrieved as Float ); Boolean columns are stored in the db as INTEGER , and so they can be given INTEGER column constraints. Use DEFAULT 0 to default to false, for example. CREATE TABLE hockey_player ( injured INTEGER AS Boolean DEFAULT 0 )","title":"Types"}]}