{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SQLDelight SQLDelight generates typesafe APIs from your SQL statements. It compile-time verifies your schema, statements, and migrations and provides IDE features like autocomplete and refactoring which make writing and maintaining SQL simple. SQLDelight currently supports the SQLite dialect and there are supported SQLite drivers on Android, JVM, iOS, and Windows. Android Native (iOS, macOS or Windows) JVM Javascript Multiplatform SQLite \u2705 \u2705 \u2705 \u2705 \u2705 MySQL \u26d4\ufe0f \u26d4\ufe0f \u2705 \u26d4\ufe0f \u26d4\ufe0f","title":"Overview"},{"location":"#sqldelight","text":"SQLDelight generates typesafe APIs from your SQL statements. It compile-time verifies your schema, statements, and migrations and provides IDE features like autocomplete and refactoring which make writing and maintaining SQL simple. SQLDelight currently supports the SQLite dialect and there are supported SQLite drivers on Android, JVM, iOS, and Windows. Android Native (iOS, macOS or Windows) JVM Javascript Multiplatform SQLite \u2705 \u2705 \u2705 \u2705 \u2705 MySQL \u26d4\ufe0f \u26d4\ufe0f \u2705 \u26d4\ufe0f \u26d4\ufe0f","title":"SQLDelight"},{"location":"android_sqlite/","text":"SQLDelight SQLDelight generates typesafe APIs from your SQL statements. It compile-time verifies your schema, statements, and migrations and provides IDE features like autocomplete and refactoring which make writing and maintaining SQL simple. SQLDelight currently supports the SQLite dialect and there are supported SQLite drivers on Android, JVM, iOS, and Windows. Example To use SQLDelight, apply the gradle plugin and put your SQL statements in a .sq file in src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: dependencies { implementation \"com.squareup.sqldelight:android-driver:1.2.2\" } val driver : SqlDriver = AndroidSqliteDriver ( Database . Schema , context , \"test.db\" )","title":"Overview"},{"location":"android_sqlite/#sqldelight","text":"SQLDelight generates typesafe APIs from your SQL statements. It compile-time verifies your schema, statements, and migrations and provides IDE features like autocomplete and refactoring which make writing and maintaining SQL simple. SQLDelight currently supports the SQLite dialect and there are supported SQLite drivers on Android, JVM, iOS, and Windows.","title":"SQLDelight"},{"location":"android_sqlite/#example","text":"To use SQLDelight, apply the gradle plugin and put your SQL statements in a .sq file in src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: dependencies { implementation \"com.squareup.sqldelight:android-driver:1.2.2\" } val driver : SqlDriver = AndroidSqliteDriver ( Database . Schema , context , \"test.db\" )","title":"Example"},{"location":"android_sqlite/android_paging/","text":"Android Paging To use SQLDelight with Android's Paging Library add a dependency on the paging extension artifact. dependencies { implementation \"com.squareup.sqldelight:android-paging-extensions:1.2.1\" } To create a DataSource write a query to get the number of rows and a query that takes an offset and a limit. countPlayers : SELECT count ( * ) FROM hockeyPlayer ; players : SELECT * FROM hockeyPlayer LIMIT : limit OFFSET : offset ; val dataSource = QueryDataSourceFactory ( queryProvider = playerQueries :: players , countQuery = playerQueries . countPlayers (), transacter = playerQueries ). create ()","title":"Android Paging"},{"location":"android_sqlite/android_paging/#android-paging","text":"To use SQLDelight with Android's Paging Library add a dependency on the paging extension artifact. dependencies { implementation \"com.squareup.sqldelight:android-paging-extensions:1.2.1\" } To create a DataSource write a query to get the number of rows and a query that takes an offset and a limit. countPlayers : SELECT count ( * ) FROM hockeyPlayer ; players : SELECT * FROM hockeyPlayer LIMIT : limit OFFSET : offset ; val dataSource = QueryDataSourceFactory ( queryProvider = playerQueries :: players , countQuery = playerQueries . countPlayers (), transacter = playerQueries ). create ()","title":"Android Paging"},{"location":"android_sqlite/custom_column_types/","text":"Custom Column Types If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) ) Enums As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as TEXT. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Custom Column Types"},{"location":"android_sqlite/custom_column_types/#custom-column-types","text":"If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) )","title":"Custom Column Types"},{"location":"android_sqlite/custom_column_types/#enums","text":"As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as TEXT. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Enums"},{"location":"android_sqlite/custom_projections/","text":"Custom Projections By default queries will return a data class implementation of the table schema. To override this behavior pass a custom mapper to the query function. Your custom mapper will receive typesafe parameters which are the projection of your select statement. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () }) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] But the custom mapping is there when this isn't possible, for example getting a Parcelable type for query results on Android.","title":"Custom Projections"},{"location":"android_sqlite/custom_projections/#custom-projections","text":"By default queries will return a data class implementation of the table schema. To override this behavior pass a custom mapper to the query function. Your custom mapper will receive typesafe parameters which are the projection of your select statement. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () }) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] But the custom mapping is there when this isn't possible, for example getting a Parcelable type for query results on Android.","title":"Custom Projections"},{"location":"android_sqlite/gradle/","text":"Gradle buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.2.2' } } apply plugin: 'com.squareup.sqldelight' For Android projects, the plugin will create a default database called Database using the project package name. For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) } // For native targets, whether sqlite should be automatically linked. // Defaults to true. linkSqlite = false } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) } linkSqlite = false } Snapshots Snapshots of the development version (including the IDE plugin zip) are available in Sonatype's snapshots repository . Upgrading From Previous Versions There's a separate guide for upgrading from 0.7 and other pre-1.0 versions here","title":"Gradle"},{"location":"android_sqlite/gradle/#gradle","text":"buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.2.2' } } apply plugin: 'com.squareup.sqldelight' For Android projects, the plugin will create a default database called Database using the project package name. For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) } // For native targets, whether sqlite should be automatically linked. // Defaults to true. linkSqlite = false } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) } linkSqlite = false }","title":"Gradle"},{"location":"android_sqlite/gradle/#snapshots","text":"Snapshots of the development version (including the IDE plugin zip) are available in Sonatype's snapshots repository .","title":"Snapshots"},{"location":"android_sqlite/gradle/#upgrading-from-previous-versions","text":"There's a separate guide for upgrading from 0.7 and other pre-1.0 versions here","title":"Upgrading From Previous Versions"},{"location":"android_sqlite/intellij_plugin/","text":"IntelliJ Plugin The IntelliJ plugin provides language-level features for .sq files, including: - Syntax highlighting - Refactoring/Find usages - Code autocompletion - Generate Queries files after edits - Right click to copy as valid SQLite - Compiler errors in IDE click through to file It can be installed from Android Studio by navigating Android Studio -> Preferences -> Plugins -> Browse repositories -> Search for SQLDelight","title":"IntelliJ Plugin"},{"location":"android_sqlite/intellij_plugin/#intellij-plugin","text":"The IntelliJ plugin provides language-level features for .sq files, including: - Syntax highlighting - Refactoring/Find usages - Code autocompletion - Generate Queries files after edits - Right click to copy as valid SQLite - Compiler errors in IDE click through to file It can be installed from Android Studio by navigating Android Studio -> Preferences -> Plugins -> Browse repositories -> Search for SQLDelight","title":"IntelliJ Plugin"},{"location":"android_sqlite/migrations/","text":"Migrations The .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; Migration files go in the src/main/sqldelight folder. These SQL statements are run by Database.Schema.migrate() . This is automatic for the Android and iOS drivers. You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task. You should probably do this before you create your first migration.","title":"Migrations"},{"location":"android_sqlite/migrations/#migrations","text":"The .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; Migration files go in the src/main/sqldelight folder. These SQL statements are run by Database.Schema.migrate() . This is automatic for the Android and iOS drivers. You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task. You should probably do this before you create your first migration.","title":"Migrations"},{"location":"android_sqlite/multiplatform/","text":"Multiplatform To use SQLDelight in Kotlin multiplatform configure the Gradle plugin with a package to generate code into. apply plugin: \"org.jetbrains.kotlin.multiplatform\" apply plugin: \"com.squareup.sqldelight\" sqldelight { MyDatabase { packageName = \"com.example.hockey\" } } Put .sq files in the src/commonMain/sqldelight directory, and then expect a SqlDriver to be provided by individual platforms when creating the Database . Migration files should also be in the same src/commonMain/sqldelight directory. Multiplatform requires the gradle metadata feature , which you need to enable via the settings.gradle file in the project root: enableFeaturePreview ( 'GRADLE_METADATA' )","title":"Multiplatform"},{"location":"android_sqlite/multiplatform/#multiplatform","text":"To use SQLDelight in Kotlin multiplatform configure the Gradle plugin with a package to generate code into. apply plugin: \"org.jetbrains.kotlin.multiplatform\" apply plugin: \"com.squareup.sqldelight\" sqldelight { MyDatabase { packageName = \"com.example.hockey\" } } Put .sq files in the src/commonMain/sqldelight directory, and then expect a SqlDriver to be provided by individual platforms when creating the Database . Migration files should also be in the same src/commonMain/sqldelight directory. Multiplatform requires the gradle metadata feature , which you need to enable via the settings.gradle file in the project root: enableFeaturePreview ( 'GRADLE_METADATA' )","title":"Multiplatform"},{"location":"android_sqlite/query_arguments/","text":"Query Arguments .sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec Strong\" , \"Jake Wharton\" , \"Matt Precious\" )) Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Query Arguments"},{"location":"android_sqlite/query_arguments/#query-arguments","text":".sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec Strong\" , \"Jake Wharton\" , \"Matt Precious\" )) Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Query Arguments"},{"location":"android_sqlite/rxjava/","text":"RxJava To observe a query, depend on the RxJava extensions artifact and use the extension method it provides: dependencies { implementation \"com.squareup.sqldelight:rxjava2-extensions:1.2.1\" } val players : Observable < List < HockeyPlayer >> = playerQueries . selectAll () . asObservable () . mapToList ()","title":"RxJava"},{"location":"android_sqlite/rxjava/#rxjava","text":"To observe a query, depend on the RxJava extensions artifact and use the extension method it provides: dependencies { implementation \"com.squareup.sqldelight:rxjava2-extensions:1.2.1\" } val players : Observable < List < HockeyPlayer >> = playerQueries . selectAll () . asObservable () . mapToList ()","title":"RxJava"},{"location":"android_sqlite/transactions/","text":"Transactions If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . foreach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"android_sqlite/transactions/#transactions","text":"If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . foreach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"android_sqlite/types/","text":"Types SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. SQLDelight natively supports Long, Double, String, ByteArray, Int, Short, Float, and Booleans. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray some_int INTEGER AS Int , -- Stored as INTEGER in db, retrieved as Int some_short INTEGER AS Short , -- Stored as INTEGER in db, retrieved as Short some_float REAL AS Float -- Stored as REAL in db, retrieved as Float ); Boolean columns are stored in the db as INTEGER , and so they can be given INTEGER column constraints. Use DEFAULT 0 to default to false, for example. CREATE TABLE hockey_player ( injured INTEGER AS Boolean DEFAULT 0 )","title":"Types"},{"location":"android_sqlite/types/#types","text":"SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. SQLDelight natively supports Long, Double, String, ByteArray, Int, Short, Float, and Booleans. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray some_int INTEGER AS Int , -- Stored as INTEGER in db, retrieved as Int some_short INTEGER AS Short , -- Stored as INTEGER in db, retrieved as Short some_float REAL AS Float -- Stored as REAL in db, retrieved as Float ); Boolean columns are stored in the db as INTEGER , and so they can be given INTEGER column constraints. Use DEFAULT 0 to default to false, for example. CREATE TABLE hockey_player ( injured INTEGER AS Boolean DEFAULT 0 )","title":"Types"},{"location":"android_sqlite/upgrading/","text":"Upgrading from Versions before 1.0 If you're still on SQLDelight 0.6 doing the upgrade to 0.7 first so you stay on the SupportSQLite artifact will likely be easiest Upgrade the gradle plugin from 0.7 to 0.7.1. This will upgrade the arch.persistence.db dependency to 1.1.1, but should have no effect on your usage of sqldelight. Upgrade the gradle plugin from 0.7.1 to 0.7.2. This changes the runtime package from com.squareup.sqldelight to com.squareup.sqldelight.prerelease , so you will need to change references in your own code. Upgrade the gradle plugin from 0.7.2 to 0.9.0. This upgrades the transitive dependencies and generated code to instead use AndroidX, which is a requirement of SQLDelight. This should be done at the same time as you upgrading your own project to AndroidX, and cannot be done separately since SQLDelight generates code which references android support/AndroidX. ALTERNATIVELY Upgrade the gradle plugin from 0.7 to 0.8.0 before then upgrading to 0.9.0. This upgrades to AndroidX without changing the sqldelight package name to com.squareup.sqldelight.prerelease Suppose on SQLDelight 0.9 you have this User.sq file: CREATE TABLE user ( id INTEGER NOT NULL PRIMARY KEY , name TEXT NOT NULL ); insertDefaultData : INSERT INTO user VALUES ( 1 , 'Alec' ); users : SELECT * FROM user ; names : SELECT name FROM user ; insertUser : INSERT INTO user VALUES ( ? , ? ); This will generate the UserModel class with methods for your queries. Copy and paste all *Model.java files out of the build directory and into your src/main/java folder. Upgrade the gradle plugin from 0.9 to 1.0.0-rc4. Note your build will fail at this point because of the model code having undefined references to the old SQL Delight runtime (like SqlDelightStatement ). To add these back in add an implementation dependency on com.squareup.sqldelight:runtime:0.9.0 . At this point your build should still be working, but changes to .sq files will not be reflected in your *Model.java files. If things aren't working at this point, please file an issue! Begin by modifying your SupportSQLiteOpenHelper.Callback to call into the now generated Database which holds generated code for SQL Delight 1.0: //Before @Override void onCreate ( SupportSQLiteDatabase db ) { db . execSql ( UserModel . CREATE_TABLE ); db . execSql ( UserModel . INSERTDEFAULTDATA ); // Other create table/initialization } In SQL Delight 1.0 all unlabeled statements in .sq files (including CREATE statements) will be run during onCreate , so we can remove the insertDefaultData identifier from above: User.sq ... --insertDefaultData: INSERT INTO user VALUES ( 1 , 'Alec' ); ... and now your SupportSQLiteOpenHelper.Callback should call into the Database for create @Override void onCreate ( SupportSQLiteDatabase db ) { SqlDriver driver = AndroidSqliteDriver ( db ) Database . Schema . create ( driver ) } You can do the same for your migrations if you place them in .sqm files, but thats not necessary part of the upgrade. At this point things should still work normally. Next add in the code to create your Database as part of an object graph/singleton pattern/whevs: @Provides @Singleton static SupportSQLiteOpenHelper provideDatabaseHelper ( @App Context context ) { SupportSQLiteOpenHelper . Configuration config = SupportSQLiteOpenHelper . Configuration . builder ( context ) . name ( DATABASE_NAME ) . callback ( new MyDatabaseCallback ()) . build (); return new FrameworkSQLiteOpenHelperFactory (). create ( config ); } @Provides @Singleton static Database provideDatabase ( SupportSQLiteOpenHelper helper ) { return new Database ( new AndroidSqliteDriver ( helper )); } If you're also using SQL Brite make sure you create a BriteDatabase with the same SupportSQLiteOpenHelper that's being used to create the Database . Things should still be working. The following assume you're using SQL Brite to get reactive callbacks from the database, but upgrades using only SQL Delight will be similar. Mutating queries can be converted individually by using the Database : before: private val insertUser : UserModel . InsertUser by lazy { UserModel . InsertUser ( datbaseOpenHelper . writableDatabase ) } insertUser . bind ( 2 , \"Jake\" ) insertUser . executeInsert () after: database . userQueries . insertUser ( 2 , \"Jake\" ) You no longer need a \"Factory\" type to perform queries, the query wrapper is all that is needed. before: val query = User . FACTORY . users () val usersObservable = briteDatabase . createQuery ( query . tables , query . statement , query . args ) . mapToList ( User . FACTORY . usersMapper () :: map ) after: val usersObservable = database . userQueries . users () . asObservable ( Schedulers . io ()) // The scheduler to run the query on. . mapToList () If you still want to use a custom type, pass it as a parameter to the query. val myUsersObservable = database . userQueries . users ( :: MyUser ) . asObservable ( Schedulers . io ()) . mapToList () Once you no longer have references to UserModel.java , delete the whole class. Repeat for each of your *Model.java files until upgrading is complete!","title":"Upgrading"},{"location":"android_sqlite/upgrading/#upgrading-from-versions-before-10","text":"If you're still on SQLDelight 0.6 doing the upgrade to 0.7 first so you stay on the SupportSQLite artifact will likely be easiest Upgrade the gradle plugin from 0.7 to 0.7.1. This will upgrade the arch.persistence.db dependency to 1.1.1, but should have no effect on your usage of sqldelight. Upgrade the gradle plugin from 0.7.1 to 0.7.2. This changes the runtime package from com.squareup.sqldelight to com.squareup.sqldelight.prerelease , so you will need to change references in your own code. Upgrade the gradle plugin from 0.7.2 to 0.9.0. This upgrades the transitive dependencies and generated code to instead use AndroidX, which is a requirement of SQLDelight. This should be done at the same time as you upgrading your own project to AndroidX, and cannot be done separately since SQLDelight generates code which references android support/AndroidX. ALTERNATIVELY Upgrade the gradle plugin from 0.7 to 0.8.0 before then upgrading to 0.9.0. This upgrades to AndroidX without changing the sqldelight package name to com.squareup.sqldelight.prerelease Suppose on SQLDelight 0.9 you have this User.sq file: CREATE TABLE user ( id INTEGER NOT NULL PRIMARY KEY , name TEXT NOT NULL ); insertDefaultData : INSERT INTO user VALUES ( 1 , 'Alec' ); users : SELECT * FROM user ; names : SELECT name FROM user ; insertUser : INSERT INTO user VALUES ( ? , ? ); This will generate the UserModel class with methods for your queries. Copy and paste all *Model.java files out of the build directory and into your src/main/java folder. Upgrade the gradle plugin from 0.9 to 1.0.0-rc4. Note your build will fail at this point because of the model code having undefined references to the old SQL Delight runtime (like SqlDelightStatement ). To add these back in add an implementation dependency on com.squareup.sqldelight:runtime:0.9.0 . At this point your build should still be working, but changes to .sq files will not be reflected in your *Model.java files. If things aren't working at this point, please file an issue! Begin by modifying your SupportSQLiteOpenHelper.Callback to call into the now generated Database which holds generated code for SQL Delight 1.0: //Before @Override void onCreate ( SupportSQLiteDatabase db ) { db . execSql ( UserModel . CREATE_TABLE ); db . execSql ( UserModel . INSERTDEFAULTDATA ); // Other create table/initialization } In SQL Delight 1.0 all unlabeled statements in .sq files (including CREATE statements) will be run during onCreate , so we can remove the insertDefaultData identifier from above: User.sq ... --insertDefaultData: INSERT INTO user VALUES ( 1 , 'Alec' ); ... and now your SupportSQLiteOpenHelper.Callback should call into the Database for create @Override void onCreate ( SupportSQLiteDatabase db ) { SqlDriver driver = AndroidSqliteDriver ( db ) Database . Schema . create ( driver ) } You can do the same for your migrations if you place them in .sqm files, but thats not necessary part of the upgrade. At this point things should still work normally. Next add in the code to create your Database as part of an object graph/singleton pattern/whevs: @Provides @Singleton static SupportSQLiteOpenHelper provideDatabaseHelper ( @App Context context ) { SupportSQLiteOpenHelper . Configuration config = SupportSQLiteOpenHelper . Configuration . builder ( context ) . name ( DATABASE_NAME ) . callback ( new MyDatabaseCallback ()) . build (); return new FrameworkSQLiteOpenHelperFactory (). create ( config ); } @Provides @Singleton static Database provideDatabase ( SupportSQLiteOpenHelper helper ) { return new Database ( new AndroidSqliteDriver ( helper )); } If you're also using SQL Brite make sure you create a BriteDatabase with the same SupportSQLiteOpenHelper that's being used to create the Database . Things should still be working. The following assume you're using SQL Brite to get reactive callbacks from the database, but upgrades using only SQL Delight will be similar. Mutating queries can be converted individually by using the Database : before: private val insertUser : UserModel . InsertUser by lazy { UserModel . InsertUser ( datbaseOpenHelper . writableDatabase ) } insertUser . bind ( 2 , \"Jake\" ) insertUser . executeInsert () after: database . userQueries . insertUser ( 2 , \"Jake\" ) You no longer need a \"Factory\" type to perform queries, the query wrapper is all that is needed. before: val query = User . FACTORY . users () val usersObservable = briteDatabase . createQuery ( query . tables , query . statement , query . args ) . mapToList ( User . FACTORY . usersMapper () :: map ) after: val usersObservable = database . userQueries . users () . asObservable ( Schedulers . io ()) // The scheduler to run the query on. . mapToList () If you still want to use a custom type, pass it as a parameter to the query. val myUsersObservable = database . userQueries . users ( :: MyUser ) . asObservable ( Schedulers . io ()) . mapToList () Once you no longer have references to UserModel.java , delete the whole class. Repeat for each of your *Model.java files until upgrading is complete!","title":"Upgrading from Versions before 1.0"},{"location":"common/custom_column_types/","text":"Custom Column Types If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) ) Enums As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as TEXT. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Custom Column Types"},{"location":"common/custom_column_types/#custom-column-types","text":"If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) )","title":"Custom Column Types"},{"location":"common/custom_column_types/#enums","text":"As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as TEXT. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Enums"},{"location":"common/custom_projections/","text":"Custom Projections By default queries will return a data class implementation of the table schema. To override this behavior pass a custom mapper to the query function. Your custom mapper will receive typesafe parameters which are the projection of your select statement. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () }) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] But the custom mapping is there when this isn't possible, for example getting a Parcelable type for query results on Android.","title":"Custom Projections"},{"location":"common/custom_projections/#custom-projections","text":"By default queries will return a data class implementation of the table schema. To override this behavior pass a custom mapper to the query function. Your custom mapper will receive typesafe parameters which are the projection of your select statement. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () }) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] But the custom mapping is there when this isn't possible, for example getting a Parcelable type for query results on Android.","title":"Custom Projections"},{"location":"common/gradle/","text":"Gradle buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.2.2' } } apply plugin: 'com.squareup.sqldelight' For Android projects, the plugin will create a default database called Database using the project package name. For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) } // For native targets, whether sqlite should be automatically linked. // Defaults to true. linkSqlite = false } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) } linkSqlite = false } Snapshots Snapshots of the development version (including the IDE plugin zip) are available in Sonatype's snapshots repository .","title":"Gradle"},{"location":"common/gradle/#gradle","text":"buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.2.2' } } apply plugin: 'com.squareup.sqldelight' For Android projects, the plugin will create a default database called Database using the project package name. For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) } // For native targets, whether sqlite should be automatically linked. // Defaults to true. linkSqlite = false } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) } linkSqlite = false }","title":"Gradle"},{"location":"common/gradle/#snapshots","text":"Snapshots of the development version (including the IDE plugin zip) are available in Sonatype's snapshots repository .","title":"Snapshots"},{"location":"common/intellij_plugin/","text":"IntelliJ Plugin The IntelliJ plugin provides language-level features for .sq files, including: - Syntax highlighting - Refactoring/Find usages - Code autocompletion - Generate Queries files after edits - Right click to copy as valid SQLite - Compiler errors in IDE click through to file It can be installed from Android Studio by navigating Android Studio -> Preferences -> Plugins -> Browse repositories -> Search for SQLDelight","title":"IntelliJ Plugin"},{"location":"common/intellij_plugin/#intellij-plugin","text":"The IntelliJ plugin provides language-level features for .sq files, including: - Syntax highlighting - Refactoring/Find usages - Code autocompletion - Generate Queries files after edits - Right click to copy as valid SQLite - Compiler errors in IDE click through to file It can be installed from Android Studio by navigating Android Studio -> Preferences -> Plugins -> Browse repositories -> Search for SQLDelight","title":"IntelliJ Plugin"},{"location":"common/migrations/","text":"Migrations The .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; Migration files go in the src/main/sqldelight folder. These SQL statements are run by Database.Schema.migrate() . This is automatic for the Android and iOS drivers. You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task. You should probably do this before you create your first migration.","title":"Migrations"},{"location":"common/migrations/#migrations","text":"The .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; Migration files go in the src/main/sqldelight folder. These SQL statements are run by Database.Schema.migrate() . This is automatic for the Android and iOS drivers. You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task. You should probably do this before you create your first migration.","title":"Migrations"},{"location":"common/multiplatform/","text":"Multiplatform To use SQLDelight in Kotlin multiplatform configure the Gradle plugin with a package to generate code into. apply plugin: \"org.jetbrains.kotlin.multiplatform\" apply plugin: \"com.squareup.sqldelight\" sqldelight { MyDatabase { packageName = \"com.example.hockey\" } } Put .sq files in the src/commonMain/sqldelight directory, and then expect a SqlDriver to be provided by individual platforms when creating the Database . Migration files should also be in the same src/commonMain/sqldelight directory. Multiplatform requires the gradle metadata feature , which you need to enable via the settings.gradle file in the project root: enableFeaturePreview ( 'GRADLE_METADATA' )","title":"Multiplatform"},{"location":"common/multiplatform/#multiplatform","text":"To use SQLDelight in Kotlin multiplatform configure the Gradle plugin with a package to generate code into. apply plugin: \"org.jetbrains.kotlin.multiplatform\" apply plugin: \"com.squareup.sqldelight\" sqldelight { MyDatabase { packageName = \"com.example.hockey\" } } Put .sq files in the src/commonMain/sqldelight directory, and then expect a SqlDriver to be provided by individual platforms when creating the Database . Migration files should also be in the same src/commonMain/sqldelight directory. Multiplatform requires the gradle metadata feature , which you need to enable via the settings.gradle file in the project root: enableFeaturePreview ( 'GRADLE_METADATA' )","title":"Multiplatform"},{"location":"common/query_arguments_sqlite/","text":"Query Arguments .sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec Strong\" , \"Jake Wharton\" , \"Matt Precious\" )) Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Query Arguments"},{"location":"common/query_arguments_sqlite/#query-arguments","text":".sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec Strong\" , \"Jake Wharton\" , \"Matt Precious\" )) Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Query Arguments"},{"location":"common/transactions/","text":"Transactions If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . foreach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"common/transactions/#transactions","text":"If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . foreach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"common/types_sqlite/","text":"Types SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. SQLDelight natively supports Long, Double, String, ByteArray, Int, Short, Float, and Booleans. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray some_int INTEGER AS Int , -- Stored as INTEGER in db, retrieved as Int some_short INTEGER AS Short , -- Stored as INTEGER in db, retrieved as Short some_float REAL AS Float -- Stored as REAL in db, retrieved as Float ); Boolean columns are stored in the db as INTEGER , and so they can be given INTEGER column constraints. Use DEFAULT 0 to default to false, for example. CREATE TABLE hockey_player ( injured INTEGER AS Boolean DEFAULT 0 )","title":"Types"},{"location":"common/types_sqlite/#types","text":"SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. SQLDelight natively supports Long, Double, String, ByteArray, Int, Short, Float, and Booleans. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray some_int INTEGER AS Int , -- Stored as INTEGER in db, retrieved as Int some_short INTEGER AS Short , -- Stored as INTEGER in db, retrieved as Short some_float REAL AS Float -- Stored as REAL in db, retrieved as Float ); Boolean columns are stored in the db as INTEGER , and so they can be given INTEGER column constraints. Use DEFAULT 0 to default to false, for example. CREATE TABLE hockey_player ( injured INTEGER AS Boolean DEFAULT 0 )","title":"Types"},{"location":"js_sqlite/","text":"SQLDelight SQLDelight generates typesafe APIs from your SQL statements. It compile-time verifies your schema, statements, and migrations and provides IDE features like autocomplete and refactoring which make writing and maintaining SQL simple. SQLDelight currently supports the SQLite dialect and there are supported SQLite drivers on Android, JVM, iOS, and Windows. Example To use SQLDelight, apply the gradle plugin and put your SQL statements in a .sq file in src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: dependencies { implementation \"com.squareup.sqldelight:sqlite-driver:1.2.2\" } val driver : SqlDriver = JdbcSqliteDriver ( JdbcSqliteDriver . IN_MEMORY ) Database . Schema . create ( driver )","title":"Overview"},{"location":"js_sqlite/#sqldelight","text":"SQLDelight generates typesafe APIs from your SQL statements. It compile-time verifies your schema, statements, and migrations and provides IDE features like autocomplete and refactoring which make writing and maintaining SQL simple. SQLDelight currently supports the SQLite dialect and there are supported SQLite drivers on Android, JVM, iOS, and Windows.","title":"SQLDelight"},{"location":"js_sqlite/#example","text":"To use SQLDelight, apply the gradle plugin and put your SQL statements in a .sq file in src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: dependencies { implementation \"com.squareup.sqldelight:sqlite-driver:1.2.2\" } val driver : SqlDriver = JdbcSqliteDriver ( JdbcSqliteDriver . IN_MEMORY ) Database . Schema . create ( driver )","title":"Example"},{"location":"js_sqlite/custom_column_types/","text":"Custom Column Types If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) ) Enums As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as TEXT. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Custom Column Types"},{"location":"js_sqlite/custom_column_types/#custom-column-types","text":"If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) )","title":"Custom Column Types"},{"location":"js_sqlite/custom_column_types/#enums","text":"As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as TEXT. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Enums"},{"location":"js_sqlite/custom_projections/","text":"Custom Projections By default queries will return a data class implementation of the table schema. To override this behavior pass a custom mapper to the query function. Your custom mapper will receive typesafe parameters which are the projection of your select statement. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () }) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] But the custom mapping is there when this isn't possible, for example getting a Parcelable type for query results on Android.","title":"Custom Projections"},{"location":"js_sqlite/custom_projections/#custom-projections","text":"By default queries will return a data class implementation of the table schema. To override this behavior pass a custom mapper to the query function. Your custom mapper will receive typesafe parameters which are the projection of your select statement. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () }) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] But the custom mapping is there when this isn't possible, for example getting a Parcelable type for query results on Android.","title":"Custom Projections"},{"location":"js_sqlite/gradle/","text":"Gradle buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.2.2' } } apply plugin: 'com.squareup.sqldelight' For Android projects, the plugin will create a default database called Database using the project package name. For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) } // For native targets, whether sqlite should be automatically linked. // Defaults to true. linkSqlite = false } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) } linkSqlite = false } Snapshots Snapshots of the development version (including the IDE plugin zip) are available in Sonatype's snapshots repository .","title":"Gradle"},{"location":"js_sqlite/gradle/#gradle","text":"buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.2.2' } } apply plugin: 'com.squareup.sqldelight' For Android projects, the plugin will create a default database called Database using the project package name. For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) } // For native targets, whether sqlite should be automatically linked. // Defaults to true. linkSqlite = false } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) } linkSqlite = false }","title":"Gradle"},{"location":"js_sqlite/gradle/#snapshots","text":"Snapshots of the development version (including the IDE plugin zip) are available in Sonatype's snapshots repository .","title":"Snapshots"},{"location":"js_sqlite/intellij_plugin/","text":"IntelliJ Plugin The IntelliJ plugin provides language-level features for .sq files, including: - Syntax highlighting - Refactoring/Find usages - Code autocompletion - Generate Queries files after edits - Right click to copy as valid SQLite - Compiler errors in IDE click through to file It can be installed from Android Studio by navigating Android Studio -> Preferences -> Plugins -> Browse repositories -> Search for SQLDelight","title":"Intellij plugin"},{"location":"js_sqlite/intellij_plugin/#intellij-plugin","text":"The IntelliJ plugin provides language-level features for .sq files, including: - Syntax highlighting - Refactoring/Find usages - Code autocompletion - Generate Queries files after edits - Right click to copy as valid SQLite - Compiler errors in IDE click through to file It can be installed from Android Studio by navigating Android Studio -> Preferences -> Plugins -> Browse repositories -> Search for SQLDelight","title":"IntelliJ Plugin"},{"location":"js_sqlite/migrations/","text":"Migrations The .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; Migration files go in the src/main/sqldelight folder. These SQL statements are run by Database.Schema.migrate() . This is automatic for the Android and iOS drivers. You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task. You should probably do this before you create your first migration.","title":"Migrations"},{"location":"js_sqlite/migrations/#migrations","text":"The .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; Migration files go in the src/main/sqldelight folder. These SQL statements are run by Database.Schema.migrate() . This is automatic for the Android and iOS drivers. You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task. You should probably do this before you create your first migration.","title":"Migrations"},{"location":"js_sqlite/multiplatform/","text":"Multiplatform To use SQLDelight in Kotlin multiplatform configure the Gradle plugin with a package to generate code into. apply plugin: \"org.jetbrains.kotlin.multiplatform\" apply plugin: \"com.squareup.sqldelight\" sqldelight { MyDatabase { packageName = \"com.example.hockey\" } } Put .sq files in the src/commonMain/sqldelight directory, and then expect a SqlDriver to be provided by individual platforms when creating the Database . Migration files should also be in the same src/commonMain/sqldelight directory. Multiplatform requires the gradle metadata feature , which you need to enable via the settings.gradle file in the project root: enableFeaturePreview ( 'GRADLE_METADATA' )","title":"Multiplatform"},{"location":"js_sqlite/multiplatform/#multiplatform","text":"To use SQLDelight in Kotlin multiplatform configure the Gradle plugin with a package to generate code into. apply plugin: \"org.jetbrains.kotlin.multiplatform\" apply plugin: \"com.squareup.sqldelight\" sqldelight { MyDatabase { packageName = \"com.example.hockey\" } } Put .sq files in the src/commonMain/sqldelight directory, and then expect a SqlDriver to be provided by individual platforms when creating the Database . Migration files should also be in the same src/commonMain/sqldelight directory. Multiplatform requires the gradle metadata feature , which you need to enable via the settings.gradle file in the project root: enableFeaturePreview ( 'GRADLE_METADATA' )","title":"Multiplatform"},{"location":"js_sqlite/query_arguments/","text":"Query Arguments .sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec Strong\" , \"Jake Wharton\" , \"Matt Precious\" )) Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Query Arguments"},{"location":"js_sqlite/query_arguments/#query-arguments","text":".sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec Strong\" , \"Jake Wharton\" , \"Matt Precious\" )) Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Query Arguments"},{"location":"js_sqlite/transactions/","text":"Transactions If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . foreach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"js_sqlite/transactions/#transactions","text":"If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . foreach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"js_sqlite/types/","text":"Types SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. SQLDelight natively supports Long, Double, String, ByteArray, Int, Short, Float, and Booleans. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray some_int INTEGER AS Int , -- Stored as INTEGER in db, retrieved as Int some_short INTEGER AS Short , -- Stored as INTEGER in db, retrieved as Short some_float REAL AS Float -- Stored as REAL in db, retrieved as Float ); Boolean columns are stored in the db as INTEGER , and so they can be given INTEGER column constraints. Use DEFAULT 0 to default to false, for example. CREATE TABLE hockey_player ( injured INTEGER AS Boolean DEFAULT 0 )","title":"Types"},{"location":"js_sqlite/types/#types","text":"SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. SQLDelight natively supports Long, Double, String, ByteArray, Int, Short, Float, and Booleans. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray some_int INTEGER AS Int , -- Stored as INTEGER in db, retrieved as Int some_short INTEGER AS Short , -- Stored as INTEGER in db, retrieved as Short some_float REAL AS Float -- Stored as REAL in db, retrieved as Float ); Boolean columns are stored in the db as INTEGER , and so they can be given INTEGER column constraints. Use DEFAULT 0 to default to false, for example. CREATE TABLE hockey_player ( injured INTEGER AS Boolean DEFAULT 0 )","title":"Types"},{"location":"jvm_mysql/","text":"SQLDelight SQLDelight generates typesafe APIs from your SQL statements. It compile-time verifies your schema, statements, and migrations and provides IDE features like autocomplete and refactoring which make writing and maintaining SQL simple. SQLDelight currently supports the SQLite dialect and there are supported SQLite drivers on Android, JVM, iOS, and Windows. Example To use SQLDelight, apply the gradle plugin and put your SQL statements in a .sq file in src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: dependencies { implementation \"com.squareup.sqldelight:mysql-driver:1.2.2\" } val driver : SqlDriver = JdbcSqliteDriver ( JdbcSqliteDriver . IN_MEMORY ) Database . Schema . create ( driver )","title":"Overview"},{"location":"jvm_mysql/#sqldelight","text":"SQLDelight generates typesafe APIs from your SQL statements. It compile-time verifies your schema, statements, and migrations and provides IDE features like autocomplete and refactoring which make writing and maintaining SQL simple. SQLDelight currently supports the SQLite dialect and there are supported SQLite drivers on Android, JVM, iOS, and Windows.","title":"SQLDelight"},{"location":"jvm_mysql/#example","text":"To use SQLDelight, apply the gradle plugin and put your SQL statements in a .sq file in src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: dependencies { implementation \"com.squareup.sqldelight:mysql-driver:1.2.2\" } val driver : SqlDriver = JdbcSqliteDriver ( JdbcSqliteDriver . IN_MEMORY ) Database . Schema . create ( driver )","title":"Example"},{"location":"jvm_mysql/custom_column_types/","text":"Custom Column Types If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) ) Enums As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as TEXT. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Custom Column Types"},{"location":"jvm_mysql/custom_column_types/#custom-column-types","text":"If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) )","title":"Custom Column Types"},{"location":"jvm_mysql/custom_column_types/#enums","text":"As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as TEXT. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Enums"},{"location":"jvm_mysql/custom_projections/","text":"Custom Projections By default queries will return a data class implementation of the table schema. To override this behavior pass a custom mapper to the query function. Your custom mapper will receive typesafe parameters which are the projection of your select statement. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () }) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] But the custom mapping is there when this isn't possible, for example getting a Parcelable type for query results on Android.","title":"Custom Projections"},{"location":"jvm_mysql/custom_projections/#custom-projections","text":"By default queries will return a data class implementation of the table schema. To override this behavior pass a custom mapper to the query function. Your custom mapper will receive typesafe parameters which are the projection of your select statement. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () }) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] But the custom mapping is there when this isn't possible, for example getting a Parcelable type for query results on Android.","title":"Custom Projections"},{"location":"jvm_mysql/gradle/","text":"Gradle buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.2.2' } } apply plugin: 'com.squareup.sqldelight' For Android projects, the plugin will create a default database called Database using the project package name. For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) } // For native targets, whether sqlite should be automatically linked. // Defaults to true. linkSqlite = false } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) } linkSqlite = false } Snapshots Snapshots of the development version (including the IDE plugin zip) are available in Sonatype's snapshots repository .","title":"Gradle"},{"location":"jvm_mysql/gradle/#gradle","text":"buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.2.2' } } apply plugin: 'com.squareup.sqldelight' For Android projects, the plugin will create a default database called Database using the project package name. For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) } // For native targets, whether sqlite should be automatically linked. // Defaults to true. linkSqlite = false } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) } linkSqlite = false }","title":"Gradle"},{"location":"jvm_mysql/gradle/#snapshots","text":"Snapshots of the development version (including the IDE plugin zip) are available in Sonatype's snapshots repository .","title":"Snapshots"},{"location":"jvm_mysql/intellij_plugin/","text":"IntelliJ Plugin The IntelliJ plugin provides language-level features for .sq files, including: - Syntax highlighting - Refactoring/Find usages - Code autocompletion - Generate Queries files after edits - Right click to copy as valid SQLite - Compiler errors in IDE click through to file It can be installed from Android Studio by navigating Android Studio -> Preferences -> Plugins -> Browse repositories -> Search for SQLDelight","title":"Intellij plugin"},{"location":"jvm_mysql/intellij_plugin/#intellij-plugin","text":"The IntelliJ plugin provides language-level features for .sq files, including: - Syntax highlighting - Refactoring/Find usages - Code autocompletion - Generate Queries files after edits - Right click to copy as valid SQLite - Compiler errors in IDE click through to file It can be installed from Android Studio by navigating Android Studio -> Preferences -> Plugins -> Browse repositories -> Search for SQLDelight","title":"IntelliJ Plugin"},{"location":"jvm_mysql/migrations/","text":"Migrations The .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; Migration files go in the src/main/sqldelight folder. These SQL statements are run by Database.Schema.migrate() . This is automatic for the Android and iOS drivers. You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task. You should probably do this before you create your first migration.","title":"Migrations"},{"location":"jvm_mysql/migrations/#migrations","text":"The .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; Migration files go in the src/main/sqldelight folder. These SQL statements are run by Database.Schema.migrate() . This is automatic for the Android and iOS drivers. You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task. You should probably do this before you create your first migration.","title":"Migrations"},{"location":"jvm_mysql/multiplatform/","text":"Multiplatform To use SQLDelight in Kotlin multiplatform configure the Gradle plugin with a package to generate code into. apply plugin: \"org.jetbrains.kotlin.multiplatform\" apply plugin: \"com.squareup.sqldelight\" sqldelight { MyDatabase { packageName = \"com.example.hockey\" } } Put .sq files in the src/commonMain/sqldelight directory, and then expect a SqlDriver to be provided by individual platforms when creating the Database . Migration files should also be in the same src/commonMain/sqldelight directory. Multiplatform requires the gradle metadata feature , which you need to enable via the settings.gradle file in the project root: enableFeaturePreview ( 'GRADLE_METADATA' )","title":"Multiplatform"},{"location":"jvm_mysql/multiplatform/#multiplatform","text":"To use SQLDelight in Kotlin multiplatform configure the Gradle plugin with a package to generate code into. apply plugin: \"org.jetbrains.kotlin.multiplatform\" apply plugin: \"com.squareup.sqldelight\" sqldelight { MyDatabase { packageName = \"com.example.hockey\" } } Put .sq files in the src/commonMain/sqldelight directory, and then expect a SqlDriver to be provided by individual platforms when creating the Database . Migration files should also be in the same src/commonMain/sqldelight directory. Multiplatform requires the gradle metadata feature , which you need to enable via the settings.gradle file in the project root: enableFeaturePreview ( 'GRADLE_METADATA' )","title":"Multiplatform"},{"location":"jvm_mysql/query_arguments/","text":"Query Arguments TODO.","title":"Query Arguments"},{"location":"jvm_mysql/query_arguments/#query-arguments","text":"TODO.","title":"Query Arguments"},{"location":"jvm_mysql/transactions/","text":"Transactions If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . foreach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"jvm_mysql/transactions/#transactions","text":"If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . foreach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"jvm_mysql/types/","text":"Types SQLDelight column definitions are identical to regular MySQL column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. TODO.","title":"Types"},{"location":"jvm_mysql/types/#types","text":"SQLDelight column definitions are identical to regular MySQL column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. TODO.","title":"Types"},{"location":"jvm_sqlite/","text":"SQLDelight SQLDelight generates typesafe APIs from your SQL statements. It compile-time verifies your schema, statements, and migrations and provides IDE features like autocomplete and refactoring which make writing and maintaining SQL simple. SQLDelight currently supports the SQLite dialect and there are supported SQLite drivers on Android, JVM, iOS, and Windows. Example To use SQLDelight, apply the gradle plugin and put your SQL statements in a .sq file in src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: dependencies { implementation \"com.squareup.sqldelight:sqlite-driver:1.2.2\" } val driver : SqlDriver = JdbcSqliteDriver ( JdbcSqliteDriver . IN_MEMORY ) Database . Schema . create ( driver )","title":"Overview"},{"location":"jvm_sqlite/#sqldelight","text":"SQLDelight generates typesafe APIs from your SQL statements. It compile-time verifies your schema, statements, and migrations and provides IDE features like autocomplete and refactoring which make writing and maintaining SQL simple. SQLDelight currently supports the SQLite dialect and there are supported SQLite drivers on Android, JVM, iOS, and Windows.","title":"SQLDelight"},{"location":"jvm_sqlite/#example","text":"To use SQLDelight, apply the gradle plugin and put your SQL statements in a .sq file in src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: dependencies { implementation \"com.squareup.sqldelight:sqlite-driver:1.2.2\" } val driver : SqlDriver = JdbcSqliteDriver ( JdbcSqliteDriver . IN_MEMORY ) Database . Schema . create ( driver )","title":"Example"},{"location":"jvm_sqlite/custom_column_types/","text":"Custom Column Types If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) ) Enums As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as TEXT. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Custom Column Types"},{"location":"jvm_sqlite/custom_column_types/#custom-column-types","text":"If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) )","title":"Custom Column Types"},{"location":"jvm_sqlite/custom_column_types/#enums","text":"As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as TEXT. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Enums"},{"location":"jvm_sqlite/custom_projections/","text":"Custom Projections By default queries will return a data class implementation of the table schema. To override this behavior pass a custom mapper to the query function. Your custom mapper will receive typesafe parameters which are the projection of your select statement. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () }) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] But the custom mapping is there when this isn't possible, for example getting a Parcelable type for query results on Android.","title":"Custom Projections"},{"location":"jvm_sqlite/custom_projections/#custom-projections","text":"By default queries will return a data class implementation of the table schema. To override this behavior pass a custom mapper to the query function. Your custom mapper will receive typesafe parameters which are the projection of your select statement. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () }) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] But the custom mapping is there when this isn't possible, for example getting a Parcelable type for query results on Android.","title":"Custom Projections"},{"location":"jvm_sqlite/gradle/","text":"Gradle buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.2.2' } } apply plugin: 'com.squareup.sqldelight' For Android projects, the plugin will create a default database called Database using the project package name. For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) } // For native targets, whether sqlite should be automatically linked. // Defaults to true. linkSqlite = false } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) } linkSqlite = false } Snapshots Snapshots of the development version (including the IDE plugin zip) are available in Sonatype's snapshots repository .","title":"Gradle"},{"location":"jvm_sqlite/gradle/#gradle","text":"buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.2.2' } } apply plugin: 'com.squareup.sqldelight' For Android projects, the plugin will create a default database called Database using the project package name. For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) } // For native targets, whether sqlite should be automatically linked. // Defaults to true. linkSqlite = false } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) } linkSqlite = false }","title":"Gradle"},{"location":"jvm_sqlite/gradle/#snapshots","text":"Snapshots of the development version (including the IDE plugin zip) are available in Sonatype's snapshots repository .","title":"Snapshots"},{"location":"jvm_sqlite/intellij_plugin/","text":"IntelliJ Plugin The IntelliJ plugin provides language-level features for .sq files, including: - Syntax highlighting - Refactoring/Find usages - Code autocompletion - Generate Queries files after edits - Right click to copy as valid SQLite - Compiler errors in IDE click through to file It can be installed from Android Studio by navigating Android Studio -> Preferences -> Plugins -> Browse repositories -> Search for SQLDelight","title":"Intellij plugin"},{"location":"jvm_sqlite/intellij_plugin/#intellij-plugin","text":"The IntelliJ plugin provides language-level features for .sq files, including: - Syntax highlighting - Refactoring/Find usages - Code autocompletion - Generate Queries files after edits - Right click to copy as valid SQLite - Compiler errors in IDE click through to file It can be installed from Android Studio by navigating Android Studio -> Preferences -> Plugins -> Browse repositories -> Search for SQLDelight","title":"IntelliJ Plugin"},{"location":"jvm_sqlite/migrations/","text":"Migrations The .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; Migration files go in the src/main/sqldelight folder. These SQL statements are run by Database.Schema.migrate() . This is automatic for the Android and iOS drivers. You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task. You should probably do this before you create your first migration.","title":"Migrations"},{"location":"jvm_sqlite/migrations/#migrations","text":"The .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; Migration files go in the src/main/sqldelight folder. These SQL statements are run by Database.Schema.migrate() . This is automatic for the Android and iOS drivers. You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task. You should probably do this before you create your first migration.","title":"Migrations"},{"location":"jvm_sqlite/multiplatform/","text":"Multiplatform To use SQLDelight in Kotlin multiplatform configure the Gradle plugin with a package to generate code into. apply plugin: \"org.jetbrains.kotlin.multiplatform\" apply plugin: \"com.squareup.sqldelight\" sqldelight { MyDatabase { packageName = \"com.example.hockey\" } } Put .sq files in the src/commonMain/sqldelight directory, and then expect a SqlDriver to be provided by individual platforms when creating the Database . Migration files should also be in the same src/commonMain/sqldelight directory. Multiplatform requires the gradle metadata feature , which you need to enable via the settings.gradle file in the project root: enableFeaturePreview ( 'GRADLE_METADATA' )","title":"Multiplatform"},{"location":"jvm_sqlite/multiplatform/#multiplatform","text":"To use SQLDelight in Kotlin multiplatform configure the Gradle plugin with a package to generate code into. apply plugin: \"org.jetbrains.kotlin.multiplatform\" apply plugin: \"com.squareup.sqldelight\" sqldelight { MyDatabase { packageName = \"com.example.hockey\" } } Put .sq files in the src/commonMain/sqldelight directory, and then expect a SqlDriver to be provided by individual platforms when creating the Database . Migration files should also be in the same src/commonMain/sqldelight directory. Multiplatform requires the gradle metadata feature , which you need to enable via the settings.gradle file in the project root: enableFeaturePreview ( 'GRADLE_METADATA' )","title":"Multiplatform"},{"location":"jvm_sqlite/query_arguments/","text":"Query Arguments .sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec Strong\" , \"Jake Wharton\" , \"Matt Precious\" )) Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Query Arguments"},{"location":"jvm_sqlite/query_arguments/#query-arguments","text":".sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec Strong\" , \"Jake Wharton\" , \"Matt Precious\" )) Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Query Arguments"},{"location":"jvm_sqlite/transactions/","text":"Transactions If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . foreach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"jvm_sqlite/transactions/#transactions","text":"If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . foreach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"jvm_sqlite/types/","text":"Types SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. SQLDelight natively supports Long, Double, String, ByteArray, Int, Short, Float, and Booleans. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray some_int INTEGER AS Int , -- Stored as INTEGER in db, retrieved as Int some_short INTEGER AS Short , -- Stored as INTEGER in db, retrieved as Short some_float REAL AS Float -- Stored as REAL in db, retrieved as Float ); Boolean columns are stored in the db as INTEGER , and so they can be given INTEGER column constraints. Use DEFAULT 0 to default to false, for example. CREATE TABLE hockey_player ( injured INTEGER AS Boolean DEFAULT 0 )","title":"Types"},{"location":"jvm_sqlite/types/#types","text":"SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. SQLDelight natively supports Long, Double, String, ByteArray, Int, Short, Float, and Booleans. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray some_int INTEGER AS Int , -- Stored as INTEGER in db, retrieved as Int some_short INTEGER AS Short , -- Stored as INTEGER in db, retrieved as Short some_float REAL AS Float -- Stored as REAL in db, retrieved as Float ); Boolean columns are stored in the db as INTEGER , and so they can be given INTEGER column constraints. Use DEFAULT 0 to default to false, for example. CREATE TABLE hockey_player ( injured INTEGER AS Boolean DEFAULT 0 )","title":"Types"},{"location":"multiplatform_sqlite/","text":"SQLDelight SQLDelight generates typesafe APIs from your SQL statements. It compile-time verifies your schema, statements, and migrations and provides IDE features like autocomplete and refactoring which make writing and maintaining SQL simple. SQLDelight currently supports the SQLite dialect and there are supported SQLite drivers on Android, JVM, iOS, and Windows. Example To use SQLDelight, apply the gradle plugin and put your SQL statements in a .sq file in src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: dependencies { implementation \"com.squareup.sqldelight:sqlite-driver:1.2.2\" } val driver : SqlDriver = JdbcSqliteDriver ( JdbcSqliteDriver . IN_MEMORY ) Database . Schema . create ( driver )","title":"Overview"},{"location":"multiplatform_sqlite/#sqldelight","text":"SQLDelight generates typesafe APIs from your SQL statements. It compile-time verifies your schema, statements, and migrations and provides IDE features like autocomplete and refactoring which make writing and maintaining SQL simple. SQLDelight currently supports the SQLite dialect and there are supported SQLite drivers on Android, JVM, iOS, and Windows.","title":"SQLDelight"},{"location":"multiplatform_sqlite/#example","text":"To use SQLDelight, apply the gradle plugin and put your SQL statements in a .sq file in src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: dependencies { implementation \"com.squareup.sqldelight:sqlite-driver:1.2.2\" } val driver : SqlDriver = JdbcSqliteDriver ( JdbcSqliteDriver . IN_MEMORY ) Database . Schema . create ( driver )","title":"Example"},{"location":"multiplatform_sqlite/custom_column_types/","text":"Custom Column Types If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) ) Enums As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as TEXT. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Custom Column Types"},{"location":"multiplatform_sqlite/custom_column_types/#custom-column-types","text":"If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) )","title":"Custom Column Types"},{"location":"multiplatform_sqlite/custom_column_types/#enums","text":"As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as TEXT. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Enums"},{"location":"multiplatform_sqlite/custom_projections/","text":"Custom Projections By default queries will return a data class implementation of the table schema. To override this behavior pass a custom mapper to the query function. Your custom mapper will receive typesafe parameters which are the projection of your select statement. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () }) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] But the custom mapping is there when this isn't possible, for example getting a Parcelable type for query results on Android.","title":"Custom Projections"},{"location":"multiplatform_sqlite/custom_projections/#custom-projections","text":"By default queries will return a data class implementation of the table schema. To override this behavior pass a custom mapper to the query function. Your custom mapper will receive typesafe parameters which are the projection of your select statement. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () }) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] But the custom mapping is there when this isn't possible, for example getting a Parcelable type for query results on Android.","title":"Custom Projections"},{"location":"multiplatform_sqlite/gradle/","text":"Gradle buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.2.2' } } apply plugin: 'com.squareup.sqldelight' For Android projects, the plugin will create a default database called Database using the project package name. For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) } // For native targets, whether sqlite should be automatically linked. // Defaults to true. linkSqlite = false } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) } linkSqlite = false } Snapshots Snapshots of the development version (including the IDE plugin zip) are available in Sonatype's snapshots repository .","title":"Gradle"},{"location":"multiplatform_sqlite/gradle/#gradle","text":"buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.2.2' } } apply plugin: 'com.squareup.sqldelight' For Android projects, the plugin will create a default database called Database using the project package name. For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) } // For native targets, whether sqlite should be automatically linked. // Defaults to true. linkSqlite = false } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) } linkSqlite = false }","title":"Gradle"},{"location":"multiplatform_sqlite/gradle/#snapshots","text":"Snapshots of the development version (including the IDE plugin zip) are available in Sonatype's snapshots repository .","title":"Snapshots"},{"location":"multiplatform_sqlite/intellij_plugin/","text":"IntelliJ Plugin The IntelliJ plugin provides language-level features for .sq files, including: - Syntax highlighting - Refactoring/Find usages - Code autocompletion - Generate Queries files after edits - Right click to copy as valid SQLite - Compiler errors in IDE click through to file It can be installed from Android Studio by navigating Android Studio -> Preferences -> Plugins -> Browse repositories -> Search for SQLDelight","title":"Intellij plugin"},{"location":"multiplatform_sqlite/intellij_plugin/#intellij-plugin","text":"The IntelliJ plugin provides language-level features for .sq files, including: - Syntax highlighting - Refactoring/Find usages - Code autocompletion - Generate Queries files after edits - Right click to copy as valid SQLite - Compiler errors in IDE click through to file It can be installed from Android Studio by navigating Android Studio -> Preferences -> Plugins -> Browse repositories -> Search for SQLDelight","title":"IntelliJ Plugin"},{"location":"multiplatform_sqlite/migrations/","text":"Migrations The .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; Migration files go in the src/main/sqldelight folder. These SQL statements are run by Database.Schema.migrate() . This is automatic for the Android and iOS drivers. You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task. You should probably do this before you create your first migration.","title":"Migrations"},{"location":"multiplatform_sqlite/migrations/#migrations","text":"The .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; Migration files go in the src/main/sqldelight folder. These SQL statements are run by Database.Schema.migrate() . This is automatic for the Android and iOS drivers. You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task. You should probably do this before you create your first migration.","title":"Migrations"},{"location":"multiplatform_sqlite/query_arguments/","text":"Query Arguments .sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec Strong\" , \"Jake Wharton\" , \"Matt Precious\" )) Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Query Arguments"},{"location":"multiplatform_sqlite/query_arguments/#query-arguments","text":".sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec Strong\" , \"Jake Wharton\" , \"Matt Precious\" )) Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Query Arguments"},{"location":"multiplatform_sqlite/transactions/","text":"Transactions If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . foreach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"multiplatform_sqlite/transactions/#transactions","text":"If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . foreach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"multiplatform_sqlite/types/","text":"Types SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. SQLDelight natively supports Long, Double, String, ByteArray, Int, Short, Float, and Booleans. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray some_int INTEGER AS Int , -- Stored as INTEGER in db, retrieved as Int some_short INTEGER AS Short , -- Stored as INTEGER in db, retrieved as Short some_float REAL AS Float -- Stored as REAL in db, retrieved as Float ); Boolean columns are stored in the db as INTEGER , and so they can be given INTEGER column constraints. Use DEFAULT 0 to default to false, for example. CREATE TABLE hockey_player ( injured INTEGER AS Boolean DEFAULT 0 )","title":"Types"},{"location":"multiplatform_sqlite/types/#types","text":"SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. SQLDelight natively supports Long, Double, String, ByteArray, Int, Short, Float, and Booleans. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray some_int INTEGER AS Int , -- Stored as INTEGER in db, retrieved as Int some_short INTEGER AS Short , -- Stored as INTEGER in db, retrieved as Short some_float REAL AS Float -- Stored as REAL in db, retrieved as Float ); Boolean columns are stored in the db as INTEGER , and so they can be given INTEGER column constraints. Use DEFAULT 0 to default to false, for example. CREATE TABLE hockey_player ( injured INTEGER AS Boolean DEFAULT 0 )","title":"Types"},{"location":"native_sqlite/","text":"SQLDelight SQLDelight generates typesafe APIs from your SQL statements. It compile-time verifies your schema, statements, and migrations and provides IDE features like autocomplete and refactoring which make writing and maintaining SQL simple. SQLDelight currently supports the SQLite dialect and there are supported SQLite drivers on Android, JVM, iOS, and Windows. Example To use SQLDelight, apply the gradle plugin and put your SQL statements in a .sq file in src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: dependencies { implementation \"com.squareup.sqldelight:native-driver:1.2.2\" } val driver : SqlDriver = NativeSqliteDriver ( Database . Schema , \"test.db\" )","title":"Overview"},{"location":"native_sqlite/#sqldelight","text":"SQLDelight generates typesafe APIs from your SQL statements. It compile-time verifies your schema, statements, and migrations and provides IDE features like autocomplete and refactoring which make writing and maintaining SQL simple. SQLDelight currently supports the SQLite dialect and there are supported SQLite drivers on Android, JVM, iOS, and Windows.","title":"SQLDelight"},{"location":"native_sqlite/#example","text":"To use SQLDelight, apply the gradle plugin and put your SQL statements in a .sq file in src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: dependencies { implementation \"com.squareup.sqldelight:native-driver:1.2.2\" } val driver : SqlDriver = NativeSqliteDriver ( Database . Schema , \"test.db\" )","title":"Example"},{"location":"native_sqlite/custom_column_types/","text":"Custom Column Types If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) ) Enums As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as TEXT. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Custom Column Types"},{"location":"native_sqlite/custom_column_types/#custom-column-types","text":"If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) )","title":"Custom Column Types"},{"location":"native_sqlite/custom_column_types/#enums","text":"As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as TEXT. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Enums"},{"location":"native_sqlite/custom_projections/","text":"Custom Projections By default queries will return a data class implementation of the table schema. To override this behavior pass a custom mapper to the query function. Your custom mapper will receive typesafe parameters which are the projection of your select statement. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () }) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] But the custom mapping is there when this isn't possible, for example getting a Parcelable type for query results on Android.","title":"Custom Projections"},{"location":"native_sqlite/custom_projections/#custom-projections","text":"By default queries will return a data class implementation of the table schema. To override this behavior pass a custom mapper to the query function. Your custom mapper will receive typesafe parameters which are the projection of your select statement. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () }) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] But the custom mapping is there when this isn't possible, for example getting a Parcelable type for query results on Android.","title":"Custom Projections"},{"location":"native_sqlite/gradle/","text":"Gradle buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.2.2' } } apply plugin: 'com.squareup.sqldelight' For Android projects, the plugin will create a default database called Database using the project package name. For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) } // For native targets, whether sqlite should be automatically linked. // Defaults to true. linkSqlite = false } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) } linkSqlite = false } Snapshots Snapshots of the development version (including the IDE plugin zip) are available in Sonatype's snapshots repository .","title":"Gradle"},{"location":"native_sqlite/gradle/#gradle","text":"buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.2.2' } } apply plugin: 'com.squareup.sqldelight' For Android projects, the plugin will create a default database called Database using the project package name. For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) } // For native targets, whether sqlite should be automatically linked. // Defaults to true. linkSqlite = false } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) } linkSqlite = false }","title":"Gradle"},{"location":"native_sqlite/gradle/#snapshots","text":"Snapshots of the development version (including the IDE plugin zip) are available in Sonatype's snapshots repository .","title":"Snapshots"},{"location":"native_sqlite/intellij_plugin/","text":"IntelliJ Plugin The IntelliJ plugin provides language-level features for .sq files, including: - Syntax highlighting - Refactoring/Find usages - Code autocompletion - Generate Queries files after edits - Right click to copy as valid SQLite - Compiler errors in IDE click through to file It can be installed from Android Studio by navigating Android Studio -> Preferences -> Plugins -> Browse repositories -> Search for SQLDelight","title":"Intellij plugin"},{"location":"native_sqlite/intellij_plugin/#intellij-plugin","text":"The IntelliJ plugin provides language-level features for .sq files, including: - Syntax highlighting - Refactoring/Find usages - Code autocompletion - Generate Queries files after edits - Right click to copy as valid SQLite - Compiler errors in IDE click through to file It can be installed from Android Studio by navigating Android Studio -> Preferences -> Plugins -> Browse repositories -> Search for SQLDelight","title":"IntelliJ Plugin"},{"location":"native_sqlite/migrations/","text":"Migrations The .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; Migration files go in the src/main/sqldelight folder. These SQL statements are run by Database.Schema.migrate() . This is automatic for the Android and iOS drivers. You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task. You should probably do this before you create your first migration.","title":"Migrations"},{"location":"native_sqlite/migrations/#migrations","text":"The .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; Migration files go in the src/main/sqldelight folder. These SQL statements are run by Database.Schema.migrate() . This is automatic for the Android and iOS drivers. You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task. You should probably do this before you create your first migration.","title":"Migrations"},{"location":"native_sqlite/multiplatform/","text":"Multiplatform To use SQLDelight in Kotlin multiplatform configure the Gradle plugin with a package to generate code into. apply plugin: \"org.jetbrains.kotlin.multiplatform\" apply plugin: \"com.squareup.sqldelight\" sqldelight { MyDatabase { packageName = \"com.example.hockey\" } } Put .sq files in the src/commonMain/sqldelight directory, and then expect a SqlDriver to be provided by individual platforms when creating the Database . Migration files should also be in the same src/commonMain/sqldelight directory. Multiplatform requires the gradle metadata feature , which you need to enable via the settings.gradle file in the project root: enableFeaturePreview ( 'GRADLE_METADATA' )","title":"Multiplatform"},{"location":"native_sqlite/multiplatform/#multiplatform","text":"To use SQLDelight in Kotlin multiplatform configure the Gradle plugin with a package to generate code into. apply plugin: \"org.jetbrains.kotlin.multiplatform\" apply plugin: \"com.squareup.sqldelight\" sqldelight { MyDatabase { packageName = \"com.example.hockey\" } } Put .sq files in the src/commonMain/sqldelight directory, and then expect a SqlDriver to be provided by individual platforms when creating the Database . Migration files should also be in the same src/commonMain/sqldelight directory. Multiplatform requires the gradle metadata feature , which you need to enable via the settings.gradle file in the project root: enableFeaturePreview ( 'GRADLE_METADATA' )","title":"Multiplatform"},{"location":"native_sqlite/query_arguments/","text":"Query Arguments .sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec Strong\" , \"Jake Wharton\" , \"Matt Precious\" )) Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Query Arguments"},{"location":"native_sqlite/query_arguments/#query-arguments","text":".sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec Strong\" , \"Jake Wharton\" , \"Matt Precious\" )) Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Query Arguments"},{"location":"native_sqlite/transactions/","text":"Transactions If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . foreach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"native_sqlite/transactions/#transactions","text":"If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . foreach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"native_sqlite/types/","text":"Types SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. SQLDelight natively supports Long, Double, String, ByteArray, Int, Short, Float, and Booleans. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray some_int INTEGER AS Int , -- Stored as INTEGER in db, retrieved as Int some_short INTEGER AS Short , -- Stored as INTEGER in db, retrieved as Short some_float REAL AS Float -- Stored as REAL in db, retrieved as Float ); Boolean columns are stored in the db as INTEGER , and so they can be given INTEGER column constraints. Use DEFAULT 0 to default to false, for example. CREATE TABLE hockey_player ( injured INTEGER AS Boolean DEFAULT 0 )","title":"Types"},{"location":"native_sqlite/types/#types","text":"SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. SQLDelight natively supports Long, Double, String, ByteArray, Int, Short, Float, and Booleans. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray some_int INTEGER AS Int , -- Stored as INTEGER in db, retrieved as Int some_short INTEGER AS Short , -- Stored as INTEGER in db, retrieved as Short some_float REAL AS Float -- Stored as REAL in db, retrieved as Float ); Boolean columns are stored in the db as INTEGER , and so they can be given INTEGER column constraints. Use DEFAULT 0 to default to false, for example. CREATE TABLE hockey_player ( injured INTEGER AS Boolean DEFAULT 0 )","title":"Types"}]}