{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SQLDelight SQLDelight generates typesafe kotlin APIs from your SQL statements. It compile-time verifies your schema, statements, and migrations and provides IDE features like autocomplete and refactoring which make writing and maintaining SQL simple. SQLDelight supports a variety of dialects and platforms: SQLite Android Native (iOS, macOS, or Windows) JVM Javascript (Work In Progress) Multiplatform MySQL (JVM) PostgreSQL (JVM) (Experimental) HSQL/H2 (JVM) (Experimental)","title":"Overview"},{"location":"#sqldelight","text":"SQLDelight generates typesafe kotlin APIs from your SQL statements. It compile-time verifies your schema, statements, and migrations and provides IDE features like autocomplete and refactoring which make writing and maintaining SQL simple. SQLDelight supports a variety of dialects and platforms: SQLite Android Native (iOS, macOS, or Windows) JVM Javascript (Work In Progress) Multiplatform MySQL (JVM) PostgreSQL (JVM) (Experimental) HSQL/H2 (JVM) (Experimental)","title":"SQLDelight"},{"location":"changelog/","text":"Change Log Version 1.2.1 (2019-12-11) Fix: [Gradle] Kotlin Native 1.3.60 support. Fix: [Gradle] #1287 Warning when syncing. Fix: [Compiler] #1469 SynetheticAccessor creation for query. Fix: [JVM Driver] Fixed memory leak. NOTE: The coroutine extension artifact requires kotlinx bintray maven repository be added to your buildscript. Version 1.2.0 (2019-08-30) New: [Runtime] Stable Flow api. Fix: [Gradle] Kotlin Native 1.3.50 support. Fix: [Gradle] #1380 Clean build sometimes fails. Fix: [Gradle] #1348 Running verify tasks prints \"Could not retrieve functions\" Fix: [Compile] #1405 Can't build project if query contains FTS table joined. Fix: [Gradle] #1266 Sporadic gradle build failure while having multiple database modules Version 1.1.4 (2019-07-11) New: [Runtime] Experimental kotlin Flow api. Fix: [Gradle] Kotlin/Native 1.3.40 compatibility. Fix: [Gradle] #1243 Fix for usage of SQLDelight with Gradle configure on demand. Fix: [Gradle] #1385 Fix for usage of SQLDelight with incremental annotation processing. Fix: [Gradle] Allow gradle tasks to cache. Fix: [Gradle] #1274 Enable usage of sqldelight extension with kotlin dsl. Fix: [Compiler] Unique ids are generated for each query deterministically. Fix: [Compiler] Only notify listening queries when a transaction is complete. Fix: [JVM Driver] #1370 Force JdbcSqliteDriver users to supply a DB URL Version 1.1.3 (2019-04-14) Gradle Metadata 1.0 release. Version 1.1.2 (2019-04-14) New: [Runtime] #1267 Logging driver decorator. Fix: [Compiler] #1254 Split string literals which are longer than 2^16 characters. Fix: [Gradle] #1260 generated sources are recognized as iOS source in Multiplatform Project. Fix: [IDE] #1290 kotlin.KotlinNullPointerException in CopyAsSqliteAction.kt:43. Fix: [Gradle] #1268 Running linkDebugFrameworkIos* tasks fail in recent versions. Version 1.1.1 (2019-03-01) Fix: [Gradle] Fix module dependency compilation for android projects. Fix: [Gradle] #1246 Set up api dependencies in afterEvaluate. Fix: [Compiler] Array types are properly printed. Version 1.1.0 (2019-02-27) New: [Gradle] #502 Allow specifying schema module dependencies. Enhancement: [Compiler] #1111 Table errors are sorted before other errors. Fix: [Compiler] #1225 Return the correct type for REAL literals. Fix: [Compiler] #1218 docid propagates through triggers. Version 1.0.3 (2019-01-30) Enhancement: [Runtime] #1195 Native Driver/Runtime Arm32. Enhancement: [Runtime] #1190 Expose the mapper from the Query type. Version 1.0.2 (2019-01-26) Fix: [Gradle Plugin] Update to kotlin 1.3.20. Fix: [Runtime] Transactions no longer swallow exceptions. Version 1.0.1 (2019-01-21) Enhancement: [Native Driver] Allow passing directory name to DatabaseConfiguration. Enhancement: [Compiler] #1173 Files without a package fail compilation. Fix: [IDE] Properly report IDE errors to Square. Fix: [IDE] #1162 Types in the same package show as error but work fine. Fix: [IDE] #1166 Renaming a table fails with NPE. Fix: [Compiler] #1167 Throws an exception when trying to parse complex SQL statements with UNION and SELECT. Version 1.0.0 (2019-01-08) New: Complete overhaul of generated code, now in kotlin. New: RxJava2 extensions artifact. New: Android Paging extensions artifact. New: Kotlin Multiplatform support. New: Android, iOS and JVM SQLite driver artifacts. New: Transaction API. Version 0.7.0 (2018-02-12) New: Generated code has been updated to use the Support SQLite library only. All queries now generate statement objects instead of a raw strings. New: Statement folding in the IDE. New: Boolean types are now automatically handled. Fix: Remove deprecated marshals from code generation. Fix: Correct 'avg' SQL function type mapping to be REAL. Fix: Correctly detect 'julianday' SQL function. Version 0.6.1 (2017-03-22) New: Delete Update and Insert statements without arguments get compiled statements generated. Fix: Using clause within a view used in a subquery doesn't error. Fix: Duplicate types on generated Mapper removed. Fix: Subqueries can be used in expressions that check against arguments. Version 0.6.0 (2017-03-06) New: Select queries are now exposed as a SqlDelightStatement factory instead of string constants. New: Query JavaDoc is now copied to statement and mapper factories. New: Emit string constants for view names. Fix: Queries on views which require factories now correctly require those factories are arguments. Fix: Validate the number of arguments to an insert matches the number of columns specified. Fix: Properly encode blob literals used in where clauses. Gradle 3.3 or newer is required for this release. Version 0.5.1 (2016-10-24) New: Compiled statements extend an abstract type. Fix: Primitive types in parameters will be boxed if nullable. Fix: All required factories for bind args are present in factory method. Fix: Escaped column names are marshalled correctly. Version 0.5.0 (2016-10-19) New: SQLite arguments can be passed typesafely through the Factory New: IntelliJ plugin performs formatting on .sq files New: Support for SQLite timestamp literals Fix: Parameterized types can be clicked through in IntelliJ Fix: Escaped column names no longer throw RuntimeExceptions if grabbed from Cursor. Fix: Gradle plugin doesn't crash trying to print exceptions. Version 0.4.4 (2016-07-20) New: Native support for shorts as column java type New: Javadoc on generated mappers and factory methods Fix: group_concat and nullif functions have proper nullability Fix: Compatibility with Android Studio 2.2-alpha Fix: WITH RECURSIVE no longer crashes plugin Version 0.4.3 (2016-07-07) New: Compilation errors link to source file. New: Right-click to copy SQLDelight code as valid SQLite. New: Javadoc on named statements will appear on generated Strings. Fix: Generated view models include nullability annotations. Fix: Generated code from unions has proper type and nullability to support all possible columns. Fix: sum and round SQLite functions have proper type in generated code. Fix: CAST's, inner selects bugfixes. Fix: Autocomplete in CREATE TABLE statements. Fix: SQLite keywords can be used in packages. Version 0.4.2 (2016-06-16) New: Marshal can be created from the factory. Fix: IntelliJ plugin generates factory methods with proper generic order. Fix: Function names can use any casing. Version 0.4.1 (2016-06-14) Fix: IntelliJ plugin generates classes with proper generic order. Fix: Column definitions can use any casing. Version 0.4.0 (2016-06-14) New: Mappers are generated per query instead of per table. New: Java types can be imported in .sq files. New: SQLite functions are validated. Fix: Remove duplicate errors. Fix: Uppercase column names and java keyword column names do not error. Version 0.3.2 (2016-05-14) New: Autocompletion and find usages now work for views and aliases. Fix: Compile-time validation now allows functions to be used in selects. Fix: Support insert statements which only declare default values. Fix: Plugin no longer crashes when a project not using SQLDelight is imported. Version 0.3.1 (2016-04-27) Fix: Interface visibility changed back to public to avoid Illegal Access runtime exceptions from method references. Fix: Subexpressions are evaluated properly. Version 0.3.0 (2016-04-26) New: Column definitions use SQLite types and can have additional 'AS' constraint to specify java type. New: Bug reports can be sent from the IDE. Fix: Autocomplete functions properly. Fix: SQLDelight model files update on .sq file edit. Removed: Attached databases no longer supported. Version 0.2.2 (2016-03-07) New: Compile-time validation of the columns used by insert, update, delete, index, and trigger statements. Fix: Don't crash IDE plugin on file move/create. Version 0.2.1 (2016-03-07) New: Ctrl+ / (Cmd+ / on OSX) toggles comment of the selected line(s). New: Compile-time validation of the columns used by SQL queries. Fix: Support Windows paths in both the IDE and Gradle plugin. Version 0.2.0 (2016-02-29) New: Added copy constructor to Marshal class. New: Update to Kotlin 1.0 final. Fix: Report 'sqldelight' folder structure problems in a non-failing way. Fix: Forbid columns named table_name . Their generated constant clashes with the table name constant. Fix: Ensure IDE plugin generates model classes immediately and regardless of whether .sq files were opened. Fix: Support Windows paths in both the IDE and Gradle plugin. Version 0.1.2 (2016-02-13) Fix: Remove code which prevented the Gradle plugin from being used in most projects. Fix: Add missing compiler dependency on the Antlr runtime. Version 0.1.1 (2016-02-12) Fix: Ensure the Gradle plugin points to the same version of the runtime as itself. Version 0.1.0 (2016-02-12) Initial release.","title":"Changelog"},{"location":"changelog/#change-log","text":"","title":"Change Log"},{"location":"changelog/#version-121-2019-12-11","text":"Fix: [Gradle] Kotlin Native 1.3.60 support. Fix: [Gradle] #1287 Warning when syncing. Fix: [Compiler] #1469 SynetheticAccessor creation for query. Fix: [JVM Driver] Fixed memory leak. NOTE: The coroutine extension artifact requires kotlinx bintray maven repository be added to your buildscript.","title":"Version 1.2.1 (2019-12-11)"},{"location":"changelog/#version-120-2019-08-30","text":"New: [Runtime] Stable Flow api. Fix: [Gradle] Kotlin Native 1.3.50 support. Fix: [Gradle] #1380 Clean build sometimes fails. Fix: [Gradle] #1348 Running verify tasks prints \"Could not retrieve functions\" Fix: [Compile] #1405 Can't build project if query contains FTS table joined. Fix: [Gradle] #1266 Sporadic gradle build failure while having multiple database modules","title":"Version 1.2.0 (2019-08-30)"},{"location":"changelog/#version-114-2019-07-11","text":"New: [Runtime] Experimental kotlin Flow api. Fix: [Gradle] Kotlin/Native 1.3.40 compatibility. Fix: [Gradle] #1243 Fix for usage of SQLDelight with Gradle configure on demand. Fix: [Gradle] #1385 Fix for usage of SQLDelight with incremental annotation processing. Fix: [Gradle] Allow gradle tasks to cache. Fix: [Gradle] #1274 Enable usage of sqldelight extension with kotlin dsl. Fix: [Compiler] Unique ids are generated for each query deterministically. Fix: [Compiler] Only notify listening queries when a transaction is complete. Fix: [JVM Driver] #1370 Force JdbcSqliteDriver users to supply a DB URL","title":"Version 1.1.4 (2019-07-11)"},{"location":"changelog/#version-113-2019-04-14","text":"Gradle Metadata 1.0 release.","title":"Version 1.1.3 (2019-04-14)"},{"location":"changelog/#version-112-2019-04-14","text":"New: [Runtime] #1267 Logging driver decorator. Fix: [Compiler] #1254 Split string literals which are longer than 2^16 characters. Fix: [Gradle] #1260 generated sources are recognized as iOS source in Multiplatform Project. Fix: [IDE] #1290 kotlin.KotlinNullPointerException in CopyAsSqliteAction.kt:43. Fix: [Gradle] #1268 Running linkDebugFrameworkIos* tasks fail in recent versions.","title":"Version 1.1.2 (2019-04-14)"},{"location":"changelog/#version-111-2019-03-01","text":"Fix: [Gradle] Fix module dependency compilation for android projects. Fix: [Gradle] #1246 Set up api dependencies in afterEvaluate. Fix: [Compiler] Array types are properly printed.","title":"Version 1.1.1 (2019-03-01)"},{"location":"changelog/#version-110-2019-02-27","text":"New: [Gradle] #502 Allow specifying schema module dependencies. Enhancement: [Compiler] #1111 Table errors are sorted before other errors. Fix: [Compiler] #1225 Return the correct type for REAL literals. Fix: [Compiler] #1218 docid propagates through triggers.","title":"Version 1.1.0 (2019-02-27)"},{"location":"changelog/#version-103-2019-01-30","text":"Enhancement: [Runtime] #1195 Native Driver/Runtime Arm32. Enhancement: [Runtime] #1190 Expose the mapper from the Query type.","title":"Version 1.0.3 (2019-01-30)"},{"location":"changelog/#version-102-2019-01-26","text":"Fix: [Gradle Plugin] Update to kotlin 1.3.20. Fix: [Runtime] Transactions no longer swallow exceptions.","title":"Version 1.0.2 (2019-01-26)"},{"location":"changelog/#version-101-2019-01-21","text":"Enhancement: [Native Driver] Allow passing directory name to DatabaseConfiguration. Enhancement: [Compiler] #1173 Files without a package fail compilation. Fix: [IDE] Properly report IDE errors to Square. Fix: [IDE] #1162 Types in the same package show as error but work fine. Fix: [IDE] #1166 Renaming a table fails with NPE. Fix: [Compiler] #1167 Throws an exception when trying to parse complex SQL statements with UNION and SELECT.","title":"Version 1.0.1 (2019-01-21)"},{"location":"changelog/#version-100-2019-01-08","text":"New: Complete overhaul of generated code, now in kotlin. New: RxJava2 extensions artifact. New: Android Paging extensions artifact. New: Kotlin Multiplatform support. New: Android, iOS and JVM SQLite driver artifacts. New: Transaction API.","title":"Version 1.0.0 (2019-01-08)"},{"location":"changelog/#version-070-2018-02-12","text":"New: Generated code has been updated to use the Support SQLite library only. All queries now generate statement objects instead of a raw strings. New: Statement folding in the IDE. New: Boolean types are now automatically handled. Fix: Remove deprecated marshals from code generation. Fix: Correct 'avg' SQL function type mapping to be REAL. Fix: Correctly detect 'julianday' SQL function.","title":"Version 0.7.0 (2018-02-12)"},{"location":"changelog/#version-061-2017-03-22","text":"New: Delete Update and Insert statements without arguments get compiled statements generated. Fix: Using clause within a view used in a subquery doesn't error. Fix: Duplicate types on generated Mapper removed. Fix: Subqueries can be used in expressions that check against arguments.","title":"Version 0.6.1 (2017-03-22)"},{"location":"changelog/#version-060-2017-03-06","text":"New: Select queries are now exposed as a SqlDelightStatement factory instead of string constants. New: Query JavaDoc is now copied to statement and mapper factories. New: Emit string constants for view names. Fix: Queries on views which require factories now correctly require those factories are arguments. Fix: Validate the number of arguments to an insert matches the number of columns specified. Fix: Properly encode blob literals used in where clauses. Gradle 3.3 or newer is required for this release.","title":"Version 0.6.0 (2017-03-06)"},{"location":"changelog/#version-051-2016-10-24","text":"New: Compiled statements extend an abstract type. Fix: Primitive types in parameters will be boxed if nullable. Fix: All required factories for bind args are present in factory method. Fix: Escaped column names are marshalled correctly.","title":"Version 0.5.1 (2016-10-24)"},{"location":"changelog/#version-050-2016-10-19","text":"New: SQLite arguments can be passed typesafely through the Factory New: IntelliJ plugin performs formatting on .sq files New: Support for SQLite timestamp literals Fix: Parameterized types can be clicked through in IntelliJ Fix: Escaped column names no longer throw RuntimeExceptions if grabbed from Cursor. Fix: Gradle plugin doesn't crash trying to print exceptions.","title":"Version 0.5.0 (2016-10-19)"},{"location":"changelog/#version-044-2016-07-20","text":"New: Native support for shorts as column java type New: Javadoc on generated mappers and factory methods Fix: group_concat and nullif functions have proper nullability Fix: Compatibility with Android Studio 2.2-alpha Fix: WITH RECURSIVE no longer crashes plugin","title":"Version 0.4.4 (2016-07-20)"},{"location":"changelog/#version-043-2016-07-07","text":"New: Compilation errors link to source file. New: Right-click to copy SQLDelight code as valid SQLite. New: Javadoc on named statements will appear on generated Strings. Fix: Generated view models include nullability annotations. Fix: Generated code from unions has proper type and nullability to support all possible columns. Fix: sum and round SQLite functions have proper type in generated code. Fix: CAST's, inner selects bugfixes. Fix: Autocomplete in CREATE TABLE statements. Fix: SQLite keywords can be used in packages.","title":"Version 0.4.3 (2016-07-07)"},{"location":"changelog/#version-042-2016-06-16","text":"New: Marshal can be created from the factory. Fix: IntelliJ plugin generates factory methods with proper generic order. Fix: Function names can use any casing.","title":"Version 0.4.2 (2016-06-16)"},{"location":"changelog/#version-041-2016-06-14","text":"Fix: IntelliJ plugin generates classes with proper generic order. Fix: Column definitions can use any casing.","title":"Version 0.4.1 (2016-06-14)"},{"location":"changelog/#version-040-2016-06-14","text":"New: Mappers are generated per query instead of per table. New: Java types can be imported in .sq files. New: SQLite functions are validated. Fix: Remove duplicate errors. Fix: Uppercase column names and java keyword column names do not error.","title":"Version 0.4.0 (2016-06-14)"},{"location":"changelog/#version-032-2016-05-14","text":"New: Autocompletion and find usages now work for views and aliases. Fix: Compile-time validation now allows functions to be used in selects. Fix: Support insert statements which only declare default values. Fix: Plugin no longer crashes when a project not using SQLDelight is imported.","title":"Version 0.3.2 (2016-05-14)"},{"location":"changelog/#version-031-2016-04-27","text":"Fix: Interface visibility changed back to public to avoid Illegal Access runtime exceptions from method references. Fix: Subexpressions are evaluated properly.","title":"Version 0.3.1 (2016-04-27)"},{"location":"changelog/#version-030-2016-04-26","text":"New: Column definitions use SQLite types and can have additional 'AS' constraint to specify java type. New: Bug reports can be sent from the IDE. Fix: Autocomplete functions properly. Fix: SQLDelight model files update on .sq file edit. Removed: Attached databases no longer supported.","title":"Version 0.3.0 (2016-04-26)"},{"location":"changelog/#version-022-2016-03-07","text":"New: Compile-time validation of the columns used by insert, update, delete, index, and trigger statements. Fix: Don't crash IDE plugin on file move/create.","title":"Version 0.2.2 (2016-03-07)"},{"location":"changelog/#version-021-2016-03-07","text":"New: Ctrl+ / (Cmd+ / on OSX) toggles comment of the selected line(s). New: Compile-time validation of the columns used by SQL queries. Fix: Support Windows paths in both the IDE and Gradle plugin.","title":"Version 0.2.1 (2016-03-07)"},{"location":"changelog/#version-020-2016-02-29","text":"New: Added copy constructor to Marshal class. New: Update to Kotlin 1.0 final. Fix: Report 'sqldelight' folder structure problems in a non-failing way. Fix: Forbid columns named table_name . Their generated constant clashes with the table name constant. Fix: Ensure IDE plugin generates model classes immediately and regardless of whether .sq files were opened. Fix: Support Windows paths in both the IDE and Gradle plugin.","title":"Version 0.2.0 (2016-02-29)"},{"location":"changelog/#version-012-2016-02-13","text":"Fix: Remove code which prevented the Gradle plugin from being used in most projects. Fix: Add missing compiler dependency on the Antlr runtime.","title":"Version 0.1.2 (2016-02-13)"},{"location":"changelog/#version-011-2016-02-12","text":"Fix: Ensure the Gradle plugin points to the same version of the runtime as itself.","title":"Version 0.1.1 (2016-02-12)"},{"location":"changelog/#version-010-2016-02-12","text":"Initial release.","title":"Version 0.1.0 (2016-02-12)"},{"location":"contributing/","text":"Contributing If you would like to contribute code to this project you can do so through GitHub by forking the repository and sending a pull request. When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Before your code can be accepted into the project you must also sign the Individual Contributor License Agreement (CLA) .","title":"Contributing"},{"location":"contributing/#contributing","text":"If you would like to contribute code to this project you can do so through GitHub by forking the repository and sending a pull request. When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Before your code can be accepted into the project you must also sign the Individual Contributor License Agreement (CLA) .","title":"Contributing"},{"location":"upgrading/","text":"Upgrading from Versions before 1.0 If you're still on SQLDelight 0.6 doing the upgrade to 0.7 first so you stay on the SupportSQLite artifact will likely be easiest Upgrade the gradle plugin from 0.7 to 0.7.1. This will upgrade the arch.persistence.db dependency to 1.1.1, but should have no effect on your usage of sqldelight. Upgrade the gradle plugin from 0.7.1 to 0.7.2. This changes the runtime package from com.squareup.sqldelight to com.squareup.sqldelight.prerelease , so you will need to change references in your own code. Upgrade the gradle plugin from 0.7.2 to 0.9.0. This upgrades the transitive dependencies and generated code to instead use AndroidX, which is a requirement of SQLDelight. This should be done at the same time as you upgrading your own project to AndroidX, and cannot be done separately since SQLDelight generates code which references android support/AndroidX. ALTERNATIVELY Upgrade the gradle plugin from 0.7 to 0.8.0 before then upgrading to 0.9.0. This upgrades to AndroidX without changing the sqldelight package name to com.squareup.sqldelight.prerelease Suppose on SQLDelight 0.9 you have this User.sq file: CREATE TABLE user ( id INTEGER NOT NULL PRIMARY KEY , name TEXT NOT NULL ); insertDefaultData : INSERT INTO user VALUES ( 1 , 'Alec' ); users : SELECT * FROM user ; names : SELECT name FROM user ; insertUser : INSERT INTO user VALUES ( ? , ? ); This will generate the UserModel class with methods for your queries. Copy and paste all *Model.java files out of the build directory and into your src/main/java folder. Upgrade the gradle plugin from 0.9 to 1.0.0-rc4. Note your build will fail at this point because of the model code having undefined references to the old SQL Delight runtime (like SqlDelightStatement ). To add these back in add an implementation dependency on com.squareup.sqldelight:runtime:0.9.0 . At this point your build should still be working, but changes to .sq files will not be reflected in your *Model.java files. If things aren't working at this point, please file an issue! Begin by modifying your SupportSQLiteOpenHelper.Callback to call into the now generated Database which holds generated code for SQL Delight 1.0: //Before @Override void onCreate ( SupportSQLiteDatabase db ) { db . execSql ( UserModel . CREATE_TABLE ); db . execSql ( UserModel . INSERTDEFAULTDATA ); // Other create table/initialization } In SQL Delight 1.0 all unlabeled statements in .sq files (including CREATE statements) will be run during onCreate , so we can remove the insertDefaultData identifier from above: User.sq ... --insertDefaultData: INSERT INTO user VALUES ( 1 , 'Alec' ); ... and now your SupportSQLiteOpenHelper.Callback should call into the Database for create @Override void onCreate ( SupportSQLiteDatabase db ) { SqlDriver driver = AndroidSqliteDriver ( db ) Database . Schema . create ( driver ) } You can do the same for your migrations if you place them in .sqm files, but thats not necessary part of the upgrade. At this point things should still work normally. Next add in the code to create your Database as part of an object graph/singleton pattern/whevs: @Provides @Singleton static SupportSQLiteOpenHelper provideDatabaseHelper ( @App Context context ) { SupportSQLiteOpenHelper . Configuration config = SupportSQLiteOpenHelper . Configuration . builder ( context ) . name ( DATABASE_NAME ) . callback ( new MyDatabaseCallback ()) . build (); return new FrameworkSQLiteOpenHelperFactory (). create ( config ); } @Provides @Singleton static Database provideDatabase ( SupportSQLiteOpenHelper helper ) { return new Database ( new AndroidSqliteDriver ( helper )); } If you're also using SQL Brite make sure you create a BriteDatabase with the same SupportSQLiteOpenHelper that's being used to create the Database . Things should still be working. The following assume you're using SQL Brite to get reactive callbacks from the database, but upgrades using only SQL Delight will be similar. Mutating queries can be converted individually by using the Database : before: private val insertUser : UserModel . InsertUser by lazy { UserModel . InsertUser ( datbaseOpenHelper . writableDatabase ) } insertUser . bind ( 2 , \"Jake\" ) insertUser . executeInsert () after: database . userQueries . insertUser ( 2 , \"Jake\" ) You no longer need a \"Factory\" type to perform queries, the query wrapper is all that is needed. before: val query = User . FACTORY . users () val usersObservable = briteDatabase . createQuery ( query . tables , query . statement , query . args ) . mapToList ( User . FACTORY . usersMapper () :: map ) after: val usersObservable = database . userQueries . users () . asObservable ( Schedulers . io ()) // The scheduler to run the query on. . mapToList () If you still want to use a custom type, pass it as a parameter to the query. val myUsersObservable = database . userQueries . users ( :: MyUser ) . asObservable ( Schedulers . io ()) . mapToList () Once you no longer have references to UserModel.java , delete the whole class. Repeat for each of your *Model.java files until upgrading is complete!","title":"Upgrading from Versions before 1.0"},{"location":"upgrading/#upgrading-from-versions-before-10","text":"If you're still on SQLDelight 0.6 doing the upgrade to 0.7 first so you stay on the SupportSQLite artifact will likely be easiest Upgrade the gradle plugin from 0.7 to 0.7.1. This will upgrade the arch.persistence.db dependency to 1.1.1, but should have no effect on your usage of sqldelight. Upgrade the gradle plugin from 0.7.1 to 0.7.2. This changes the runtime package from com.squareup.sqldelight to com.squareup.sqldelight.prerelease , so you will need to change references in your own code. Upgrade the gradle plugin from 0.7.2 to 0.9.0. This upgrades the transitive dependencies and generated code to instead use AndroidX, which is a requirement of SQLDelight. This should be done at the same time as you upgrading your own project to AndroidX, and cannot be done separately since SQLDelight generates code which references android support/AndroidX. ALTERNATIVELY Upgrade the gradle plugin from 0.7 to 0.8.0 before then upgrading to 0.9.0. This upgrades to AndroidX without changing the sqldelight package name to com.squareup.sqldelight.prerelease Suppose on SQLDelight 0.9 you have this User.sq file: CREATE TABLE user ( id INTEGER NOT NULL PRIMARY KEY , name TEXT NOT NULL ); insertDefaultData : INSERT INTO user VALUES ( 1 , 'Alec' ); users : SELECT * FROM user ; names : SELECT name FROM user ; insertUser : INSERT INTO user VALUES ( ? , ? ); This will generate the UserModel class with methods for your queries. Copy and paste all *Model.java files out of the build directory and into your src/main/java folder. Upgrade the gradle plugin from 0.9 to 1.0.0-rc4. Note your build will fail at this point because of the model code having undefined references to the old SQL Delight runtime (like SqlDelightStatement ). To add these back in add an implementation dependency on com.squareup.sqldelight:runtime:0.9.0 . At this point your build should still be working, but changes to .sq files will not be reflected in your *Model.java files. If things aren't working at this point, please file an issue! Begin by modifying your SupportSQLiteOpenHelper.Callback to call into the now generated Database which holds generated code for SQL Delight 1.0: //Before @Override void onCreate ( SupportSQLiteDatabase db ) { db . execSql ( UserModel . CREATE_TABLE ); db . execSql ( UserModel . INSERTDEFAULTDATA ); // Other create table/initialization } In SQL Delight 1.0 all unlabeled statements in .sq files (including CREATE statements) will be run during onCreate , so we can remove the insertDefaultData identifier from above: User.sq ... --insertDefaultData: INSERT INTO user VALUES ( 1 , 'Alec' ); ... and now your SupportSQLiteOpenHelper.Callback should call into the Database for create @Override void onCreate ( SupportSQLiteDatabase db ) { SqlDriver driver = AndroidSqliteDriver ( db ) Database . Schema . create ( driver ) } You can do the same for your migrations if you place them in .sqm files, but thats not necessary part of the upgrade. At this point things should still work normally. Next add in the code to create your Database as part of an object graph/singleton pattern/whevs: @Provides @Singleton static SupportSQLiteOpenHelper provideDatabaseHelper ( @App Context context ) { SupportSQLiteOpenHelper . Configuration config = SupportSQLiteOpenHelper . Configuration . builder ( context ) . name ( DATABASE_NAME ) . callback ( new MyDatabaseCallback ()) . build (); return new FrameworkSQLiteOpenHelperFactory (). create ( config ); } @Provides @Singleton static Database provideDatabase ( SupportSQLiteOpenHelper helper ) { return new Database ( new AndroidSqliteDriver ( helper )); } If you're also using SQL Brite make sure you create a BriteDatabase with the same SupportSQLiteOpenHelper that's being used to create the Database . Things should still be working. The following assume you're using SQL Brite to get reactive callbacks from the database, but upgrades using only SQL Delight will be similar. Mutating queries can be converted individually by using the Database : before: private val insertUser : UserModel . InsertUser by lazy { UserModel . InsertUser ( datbaseOpenHelper . writableDatabase ) } insertUser . bind ( 2 , \"Jake\" ) insertUser . executeInsert () after: database . userQueries . insertUser ( 2 , \"Jake\" ) You no longer need a \"Factory\" type to perform queries, the query wrapper is all that is needed. before: val query = User . FACTORY . users () val usersObservable = briteDatabase . createQuery ( query . tables , query . statement , query . args ) . mapToList ( User . FACTORY . usersMapper () :: map ) after: val usersObservable = database . userQueries . users () . asObservable ( Schedulers . io ()) // The scheduler to run the query on. . mapToList () If you still want to use a custom type, pass it as a parameter to the query. val myUsersObservable = database . userQueries . users ( :: MyUser ) . asObservable ( Schedulers . io ()) . mapToList () Once you no longer have references to UserModel.java , delete the whole class. Repeat for each of your *Model.java files until upgrading is complete!","title":"Upgrading from Versions before 1.0"},{"location":"1.x/coroutines-extensions/","text":"coroutines-extensions Packages Name Summary com.squareup.sqldelight.runtime.coroutines Index All Types","title":"coroutines-extensions"},{"location":"1.x/coroutines-extensions/#packages","text":"Name Summary com.squareup.sqldelight.runtime.coroutines","title":"Packages"},{"location":"1.x/coroutines-extensions/#index","text":"All Types","title":"Index"},{"location":"1.x/coroutines-extensions/alltypes/","text":"All Types Name Summary","title":"Alltypes"},{"location":"1.x/coroutines-extensions/alltypes/#all-types","text":"Name Summary","title":"All Types"},{"location":"1.x/coroutines-extensions/com.squareup.sqldelight.runtime.coroutines/","text":"coroutines-extensions / com.squareup.sqldelight.runtime.coroutines Package com.squareup.sqldelight.runtime.coroutines Functions Name Summary asFlow fun <T : Any > <ERROR CLASS>< T >.asFlow(): <ERROR CLASS><<ERROR CLASS>< T >> Turns this Query into a Flow which emits whenever the underlying result set changes. mapToList fun <T : Any > <ERROR CLASS><<ERROR CLASS>< T >>.mapToList(context: <ERROR CLASS> = Dispatchers.Default): <ERROR CLASS>< List < T >> mapToOne fun <T : Any > <ERROR CLASS><<ERROR CLASS>< T >>.mapToOne(context: <ERROR CLASS> = Dispatchers.Default): <ERROR CLASS>< T > mapToOneNotNull fun <T : Any > <ERROR CLASS><<ERROR CLASS>< T >>.mapToOneNotNull(context: <ERROR CLASS> = Dispatchers.Default): <ERROR CLASS>< T > mapToOneOrDefault fun <T : Any > <ERROR CLASS><<ERROR CLASS>< T >>.mapToOneOrDefault(defaultValue: T , context: <ERROR CLASS> = Dispatchers.Default): <ERROR CLASS>< T > mapToOneOrNull fun <T : Any > <ERROR CLASS><<ERROR CLASS>< T >>.mapToOneOrNull(context: <ERROR CLASS> = Dispatchers.Default): <ERROR CLASS>< T ?>","title":"Home"},{"location":"1.x/coroutines-extensions/com.squareup.sqldelight.runtime.coroutines/#package-comsquareupsqldelightruntimecoroutines","text":"","title":"Package com.squareup.sqldelight.runtime.coroutines"},{"location":"1.x/coroutines-extensions/com.squareup.sqldelight.runtime.coroutines/#functions","text":"Name Summary asFlow fun <T : Any > <ERROR CLASS>< T >.asFlow(): <ERROR CLASS><<ERROR CLASS>< T >> Turns this Query into a Flow which emits whenever the underlying result set changes. mapToList fun <T : Any > <ERROR CLASS><<ERROR CLASS>< T >>.mapToList(context: <ERROR CLASS> = Dispatchers.Default): <ERROR CLASS>< List < T >> mapToOne fun <T : Any > <ERROR CLASS><<ERROR CLASS>< T >>.mapToOne(context: <ERROR CLASS> = Dispatchers.Default): <ERROR CLASS>< T > mapToOneNotNull fun <T : Any > <ERROR CLASS><<ERROR CLASS>< T >>.mapToOneNotNull(context: <ERROR CLASS> = Dispatchers.Default): <ERROR CLASS>< T > mapToOneOrDefault fun <T : Any > <ERROR CLASS><<ERROR CLASS>< T >>.mapToOneOrDefault(defaultValue: T , context: <ERROR CLASS> = Dispatchers.Default): <ERROR CLASS>< T > mapToOneOrNull fun <T : Any > <ERROR CLASS><<ERROR CLASS>< T >>.mapToOneOrNull(context: <ERROR CLASS> = Dispatchers.Default): <ERROR CLASS>< T ?>","title":"Functions"},{"location":"1.x/coroutines-extensions/com.squareup.sqldelight.runtime.coroutines/as-flow/","text":"coroutines-extensions / com.squareup.sqldelight.runtime.coroutines / asFlow asFlow fun <T : Any > <ERROR CLASS>< T >.asFlow(): <ERROR CLASS><<ERROR CLASS>< T >> Turns this Query into a Flow which emits whenever the underlying result set changes.","title":"As flow"},{"location":"1.x/coroutines-extensions/com.squareup.sqldelight.runtime.coroutines/as-flow/#asflow","text":"fun <T : Any > <ERROR CLASS>< T >.asFlow(): <ERROR CLASS><<ERROR CLASS>< T >> Turns this Query into a Flow which emits whenever the underlying result set changes.","title":"asFlow"},{"location":"1.x/coroutines-extensions/com.squareup.sqldelight.runtime.coroutines/map-to-list/","text":"coroutines-extensions / com.squareup.sqldelight.runtime.coroutines / mapToList mapToList fun <T : Any > <ERROR CLASS><<ERROR CLASS>< T >>.mapToList(context: <ERROR CLASS> = Dispatchers.Default): <ERROR CLASS>< List < T >>","title":"Map to list"},{"location":"1.x/coroutines-extensions/com.squareup.sqldelight.runtime.coroutines/map-to-list/#maptolist","text":"fun <T : Any > <ERROR CLASS><<ERROR CLASS>< T >>.mapToList(context: <ERROR CLASS> = Dispatchers.Default): <ERROR CLASS>< List < T >>","title":"mapToList"},{"location":"1.x/coroutines-extensions/com.squareup.sqldelight.runtime.coroutines/map-to-one-not-null/","text":"coroutines-extensions / com.squareup.sqldelight.runtime.coroutines / mapToOneNotNull mapToOneNotNull fun <T : Any > <ERROR CLASS><<ERROR CLASS>< T >>.mapToOneNotNull(context: <ERROR CLASS> = Dispatchers.Default): <ERROR CLASS>< T >","title":"Map to one not null"},{"location":"1.x/coroutines-extensions/com.squareup.sqldelight.runtime.coroutines/map-to-one-not-null/#maptoonenotnull","text":"fun <T : Any > <ERROR CLASS><<ERROR CLASS>< T >>.mapToOneNotNull(context: <ERROR CLASS> = Dispatchers.Default): <ERROR CLASS>< T >","title":"mapToOneNotNull"},{"location":"1.x/coroutines-extensions/com.squareup.sqldelight.runtime.coroutines/map-to-one-or-default/","text":"coroutines-extensions / com.squareup.sqldelight.runtime.coroutines / mapToOneOrDefault mapToOneOrDefault fun <T : Any > <ERROR CLASS><<ERROR CLASS>< T >>.mapToOneOrDefault(defaultValue: T , context: <ERROR CLASS> = Dispatchers.Default): <ERROR CLASS>< T >","title":"Map to one or default"},{"location":"1.x/coroutines-extensions/com.squareup.sqldelight.runtime.coroutines/map-to-one-or-default/#maptooneordefault","text":"fun <T : Any > <ERROR CLASS><<ERROR CLASS>< T >>.mapToOneOrDefault(defaultValue: T , context: <ERROR CLASS> = Dispatchers.Default): <ERROR CLASS>< T >","title":"mapToOneOrDefault"},{"location":"1.x/coroutines-extensions/com.squareup.sqldelight.runtime.coroutines/map-to-one-or-null/","text":"coroutines-extensions / com.squareup.sqldelight.runtime.coroutines / mapToOneOrNull mapToOneOrNull fun <T : Any > <ERROR CLASS><<ERROR CLASS>< T >>.mapToOneOrNull(context: <ERROR CLASS> = Dispatchers.Default): <ERROR CLASS>< T ?>","title":"Map to one or null"},{"location":"1.x/coroutines-extensions/com.squareup.sqldelight.runtime.coroutines/map-to-one-or-null/#maptooneornull","text":"fun <T : Any > <ERROR CLASS><<ERROR CLASS>< T >>.mapToOneOrNull(context: <ERROR CLASS> = Dispatchers.Default): <ERROR CLASS>< T ?>","title":"mapToOneOrNull"},{"location":"1.x/coroutines-extensions/com.squareup.sqldelight.runtime.coroutines/map-to-one/","text":"coroutines-extensions / com.squareup.sqldelight.runtime.coroutines / mapToOne mapToOne fun <T : Any > <ERROR CLASS><<ERROR CLASS>< T >>.mapToOne(context: <ERROR CLASS> = Dispatchers.Default): <ERROR CLASS>< T >","title":"Map to one"},{"location":"1.x/coroutines-extensions/com.squareup.sqldelight.runtime.coroutines/map-to-one/#maptoone","text":"fun <T : Any > <ERROR CLASS><<ERROR CLASS>< T >>.mapToOne(context: <ERROR CLASS> = Dispatchers.Default): <ERROR CLASS>< T >","title":"mapToOne"},{"location":"1.x/native-driver/","text":"native-driver Packages Name Summary com.squareup.sqldelight.drivers.native (native) Index All Types","title":"native-driver"},{"location":"1.x/native-driver/#packages","text":"Name Summary com.squareup.sqldelight.drivers.native (native)","title":"Packages"},{"location":"1.x/native-driver/#index","text":"All Types","title":"Index"},{"location":"1.x/native-driver/alltypes/","text":"All Types Name Summary com.squareup.sqldelight.drivers.native.ConnectionWrapper com.squareup.sqldelight.drivers.native.NativeSqliteDriver Native driver implementation.","title":"Home"},{"location":"1.x/native-driver/alltypes/#all-types","text":"Name Summary com.squareup.sqldelight.drivers.native.ConnectionWrapper com.squareup.sqldelight.drivers.native.NativeSqliteDriver Native driver implementation.","title":"All Types"},{"location":"1.x/native-driver/com.squareup.sqldelight.drivers.native/","text":"native-driver / com.squareup.sqldelight.drivers.native Package com.squareup.sqldelight.drivers.native Platform and version requirements: native Types Name Summary ConnectionWrapper (native) sealed class ConnectionWrapper NativeSqliteDriver (native) class NativeSqliteDriver : ConnectionWrapper Native driver implementation. Functions Name Summary wrapConnection (native) fun wrapConnection(connection: <ERROR CLASS>, block: (<ERROR CLASS>) -> Unit ): Unit Sqliter's DatabaseConfiguration takes lambda arguments for it's create and upgrade operations, which each take a DatabaseConnection argument. Use wrapConnection to have SqlDelight access this passed connection and avoid the pooling that the full SqlDriver instance performs.","title":"Home"},{"location":"1.x/native-driver/com.squareup.sqldelight.drivers.native/#package-comsquareupsqldelightdriversnative","text":"Platform and version requirements: native","title":"Package com.squareup.sqldelight.drivers.native"},{"location":"1.x/native-driver/com.squareup.sqldelight.drivers.native/#types","text":"Name Summary ConnectionWrapper (native) sealed class ConnectionWrapper NativeSqliteDriver (native) class NativeSqliteDriver : ConnectionWrapper Native driver implementation.","title":"Types"},{"location":"1.x/native-driver/com.squareup.sqldelight.drivers.native/#functions","text":"Name Summary wrapConnection (native) fun wrapConnection(connection: <ERROR CLASS>, block: (<ERROR CLASS>) -> Unit ): Unit Sqliter's DatabaseConfiguration takes lambda arguments for it's create and upgrade operations, which each take a DatabaseConnection argument. Use wrapConnection to have SqlDelight access this passed connection and avoid the pooling that the full SqlDriver instance performs.","title":"Functions"},{"location":"1.x/native-driver/com.squareup.sqldelight.drivers.native/wrap-connection/","text":"native-driver / com.squareup.sqldelight.drivers.native / wrapConnection wrapConnection fun wrapConnection(connection: <ERROR CLASS>, block: (<ERROR CLASS>) -> Unit ): Unit Platform and version requirements: native Sqliter's DatabaseConfiguration takes lambda arguments for it's create and upgrade operations, which each take a DatabaseConnection argument. Use wrapConnection to have SqlDelight access this passed connection and avoid the pooling that the full SqlDriver instance performs. Note that queries created during this operation will be cleaned up. If holding onto a cursor from a wrap call, it will no longer be viable.","title":"Wrap connection"},{"location":"1.x/native-driver/com.squareup.sqldelight.drivers.native/wrap-connection/#wrapconnection","text":"fun wrapConnection(connection: <ERROR CLASS>, block: (<ERROR CLASS>) -> Unit ): Unit Platform and version requirements: native Sqliter's DatabaseConfiguration takes lambda arguments for it's create and upgrade operations, which each take a DatabaseConnection argument. Use wrapConnection to have SqlDelight access this passed connection and avoid the pooling that the full SqlDriver instance performs. Note that queries created during this operation will be cleaned up. If holding onto a cursor from a wrap call, it will no longer be viable.","title":"wrapConnection"},{"location":"1.x/native-driver/com.squareup.sqldelight.drivers.native/-connection-wrapper/","text":"native-driver / com.squareup.sqldelight.drivers.native / ConnectionWrapper ConnectionWrapper sealed class ConnectionWrapper Platform and version requirements: native Functions Name Summary execute fun execute(identifier: Int ?, sql: String , parameters: Int , binders: <ERROR CLASS>.() -> Unit ): Unit executeQuery fun executeQuery(identifier: Int ?, sql: String , parameters: Int , binders: <ERROR CLASS>.() -> Unit ): <ERROR CLASS> Inheritors Name Summary NativeSqliteDriver (native) class NativeSqliteDriver : ConnectionWrapper Native driver implementation.","title":"Home"},{"location":"1.x/native-driver/com.squareup.sqldelight.drivers.native/-connection-wrapper/#connectionwrapper","text":"sealed class ConnectionWrapper Platform and version requirements: native","title":"ConnectionWrapper"},{"location":"1.x/native-driver/com.squareup.sqldelight.drivers.native/-connection-wrapper/#functions","text":"Name Summary execute fun execute(identifier: Int ?, sql: String , parameters: Int , binders: <ERROR CLASS>.() -> Unit ): Unit executeQuery fun executeQuery(identifier: Int ?, sql: String , parameters: Int , binders: <ERROR CLASS>.() -> Unit ): <ERROR CLASS>","title":"Functions"},{"location":"1.x/native-driver/com.squareup.sqldelight.drivers.native/-connection-wrapper/#inheritors","text":"Name Summary NativeSqliteDriver (native) class NativeSqliteDriver : ConnectionWrapper Native driver implementation.","title":"Inheritors"},{"location":"1.x/native-driver/com.squareup.sqldelight.drivers.native/-connection-wrapper/execute-query/","text":"native-driver / com.squareup.sqldelight.drivers.native / ConnectionWrapper / executeQuery executeQuery fun executeQuery(identifier: Int ?, sql: String , parameters: Int , binders: <ERROR CLASS>.() -> Unit ): <ERROR CLASS> Platform and version requirements: native","title":"Execute query"},{"location":"1.x/native-driver/com.squareup.sqldelight.drivers.native/-connection-wrapper/execute-query/#executequery","text":"fun executeQuery(identifier: Int ?, sql: String , parameters: Int , binders: <ERROR CLASS>.() -> Unit ): <ERROR CLASS> Platform and version requirements: native","title":"executeQuery"},{"location":"1.x/native-driver/com.squareup.sqldelight.drivers.native/-connection-wrapper/execute/","text":"native-driver / com.squareup.sqldelight.drivers.native / ConnectionWrapper / execute execute fun execute(identifier: Int ?, sql: String , parameters: Int , binders: <ERROR CLASS>.() -> Unit ): Unit Platform and version requirements: native","title":"Execute"},{"location":"1.x/native-driver/com.squareup.sqldelight.drivers.native/-connection-wrapper/execute/#execute","text":"fun execute(identifier: Int ?, sql: String , parameters: Int , binders: <ERROR CLASS>.() -> Unit ): Unit Platform and version requirements: native","title":"execute"},{"location":"1.x/native-driver/com.squareup.sqldelight.drivers.native/-native-sqlite-driver/","text":"native-driver / com.squareup.sqldelight.drivers.native / NativeSqliteDriver NativeSqliteDriver class NativeSqliteDriver : ConnectionWrapper Platform and version requirements: native Native driver implementation. The root SqlDriver creates 2 connections to the underlying database. One is used by transactions and aligned with the thread performing the transaction. Multiple threads starting transactions block and wait. The other connection does everything outside of a connection. The goal is to be able to read while also writing. Future versions may create multiple query connections. When a transaction is started, that thread is aligned with the transaction connection. Attempting to start a transaction on another thread will block until the first finishes. Not ending transactions is problematic, but it would be regardless. One implication to be aware of. You cannot operate on a single transaction from multiple threads. However, it would be difficult to find a use case where this would be desirable or safe. To use SqlDelight during create/upgrade processes, you can alternatively wrap a real connection with wrapConnection. SqlPreparedStatement instances also do not point to real resources until either execute or executeQuery is called. The SqlPreparedStatement structure also maintains a thread-aligned instance which accumulates bind calls. Those are replayed on a real SQLite statement instance when execute or executeQuery is called. This avoids race conditions with bind calls. Constructors Name Summary <init> NativeSqliteDriver(configuration: <ERROR CLASS>) NativeSqliteDriver(schema: <ERROR CLASS>, name: String )``NativeSqliteDriver(databaseManager: <ERROR CLASS>) Native driver implementation. Functions Name Summary close fun close(): Unit currentTransaction fun currentTransaction(): <ERROR CLASS>? newTransaction fun newTransaction(): <ERROR CLASS> Inherited Functions Name Summary execute (native) fun execute(identifier: Int ?, sql: String , parameters: Int , binders: <ERROR CLASS>.() -> Unit ): Unit executeQuery (native) fun executeQuery(identifier: Int ?, sql: String , parameters: Int , binders: <ERROR CLASS>.() -> Unit ): <ERROR CLASS>","title":"Home"},{"location":"1.x/native-driver/com.squareup.sqldelight.drivers.native/-native-sqlite-driver/#nativesqlitedriver","text":"class NativeSqliteDriver : ConnectionWrapper Platform and version requirements: native Native driver implementation. The root SqlDriver creates 2 connections to the underlying database. One is used by transactions and aligned with the thread performing the transaction. Multiple threads starting transactions block and wait. The other connection does everything outside of a connection. The goal is to be able to read while also writing. Future versions may create multiple query connections. When a transaction is started, that thread is aligned with the transaction connection. Attempting to start a transaction on another thread will block until the first finishes. Not ending transactions is problematic, but it would be regardless. One implication to be aware of. You cannot operate on a single transaction from multiple threads. However, it would be difficult to find a use case where this would be desirable or safe. To use SqlDelight during create/upgrade processes, you can alternatively wrap a real connection with wrapConnection. SqlPreparedStatement instances also do not point to real resources until either execute or executeQuery is called. The SqlPreparedStatement structure also maintains a thread-aligned instance which accumulates bind calls. Those are replayed on a real SQLite statement instance when execute or executeQuery is called. This avoids race conditions with bind calls.","title":"NativeSqliteDriver"},{"location":"1.x/native-driver/com.squareup.sqldelight.drivers.native/-native-sqlite-driver/#constructors","text":"Name Summary <init> NativeSqliteDriver(configuration: <ERROR CLASS>) NativeSqliteDriver(schema: <ERROR CLASS>, name: String )``NativeSqliteDriver(databaseManager: <ERROR CLASS>) Native driver implementation.","title":"Constructors"},{"location":"1.x/native-driver/com.squareup.sqldelight.drivers.native/-native-sqlite-driver/#functions","text":"Name Summary close fun close(): Unit currentTransaction fun currentTransaction(): <ERROR CLASS>? newTransaction fun newTransaction(): <ERROR CLASS>","title":"Functions"},{"location":"1.x/native-driver/com.squareup.sqldelight.drivers.native/-native-sqlite-driver/#inherited-functions","text":"Name Summary execute (native) fun execute(identifier: Int ?, sql: String , parameters: Int , binders: <ERROR CLASS>.() -> Unit ): Unit executeQuery (native) fun executeQuery(identifier: Int ?, sql: String , parameters: Int , binders: <ERROR CLASS>.() -> Unit ): <ERROR CLASS>","title":"Inherited Functions"},{"location":"1.x/native-driver/com.squareup.sqldelight.drivers.native/-native-sqlite-driver/-init-/","text":"native-driver / com.squareup.sqldelight.drivers.native / NativeSqliteDriver / <init> <init> NativeSqliteDriver(configuration: <ERROR CLASS>) Platform and version requirements: native NativeSqliteDriver(schema: <ERROR CLASS>, name: String ) Platform and version requirements: native NativeSqliteDriver(databaseManager: <ERROR CLASS>) Platform and version requirements: native Native driver implementation. The root SqlDriver creates 2 connections to the underlying database. One is used by transactions and aligned with the thread performing the transaction. Multiple threads starting transactions block and wait. The other connection does everything outside of a connection. The goal is to be able to read while also writing. Future versions may create multiple query connections. When a transaction is started, that thread is aligned with the transaction connection. Attempting to start a transaction on another thread will block until the first finishes. Not ending transactions is problematic, but it would be regardless. One implication to be aware of. You cannot operate on a single transaction from multiple threads. However, it would be difficult to find a use case where this would be desirable or safe. To use SqlDelight during create/upgrade processes, you can alternatively wrap a real connection with wrapConnection. SqlPreparedStatement instances also do not point to real resources until either execute or executeQuery is called. The SqlPreparedStatement structure also maintains a thread-aligned instance which accumulates bind calls. Those are replayed on a real SQLite statement instance when execute or executeQuery is called. This avoids race conditions with bind calls.","title":" init "},{"location":"1.x/native-driver/com.squareup.sqldelight.drivers.native/-native-sqlite-driver/-init-/#init","text":"NativeSqliteDriver(configuration: <ERROR CLASS>) Platform and version requirements: native NativeSqliteDriver(schema: <ERROR CLASS>, name: String ) Platform and version requirements: native NativeSqliteDriver(databaseManager: <ERROR CLASS>) Platform and version requirements: native Native driver implementation. The root SqlDriver creates 2 connections to the underlying database. One is used by transactions and aligned with the thread performing the transaction. Multiple threads starting transactions block and wait. The other connection does everything outside of a connection. The goal is to be able to read while also writing. Future versions may create multiple query connections. When a transaction is started, that thread is aligned with the transaction connection. Attempting to start a transaction on another thread will block until the first finishes. Not ending transactions is problematic, but it would be regardless. One implication to be aware of. You cannot operate on a single transaction from multiple threads. However, it would be difficult to find a use case where this would be desirable or safe. To use SqlDelight during create/upgrade processes, you can alternatively wrap a real connection with wrapConnection. SqlPreparedStatement instances also do not point to real resources until either execute or executeQuery is called. The SqlPreparedStatement structure also maintains a thread-aligned instance which accumulates bind calls. Those are replayed on a real SQLite statement instance when execute or executeQuery is called. This avoids race conditions with bind calls.","title":"&lt;init&gt;"},{"location":"1.x/native-driver/com.squareup.sqldelight.drivers.native/-native-sqlite-driver/close/","text":"native-driver / com.squareup.sqldelight.drivers.native / NativeSqliteDriver / close close fun close(): Unit Platform and version requirements: native","title":"Close"},{"location":"1.x/native-driver/com.squareup.sqldelight.drivers.native/-native-sqlite-driver/close/#close","text":"fun close(): Unit Platform and version requirements: native","title":"close"},{"location":"1.x/native-driver/com.squareup.sqldelight.drivers.native/-native-sqlite-driver/current-transaction/","text":"native-driver / com.squareup.sqldelight.drivers.native / NativeSqliteDriver / currentTransaction currentTransaction fun currentTransaction(): <ERROR CLASS>? Platform and version requirements: native","title":"Current transaction"},{"location":"1.x/native-driver/com.squareup.sqldelight.drivers.native/-native-sqlite-driver/current-transaction/#currenttransaction","text":"fun currentTransaction(): <ERROR CLASS>? Platform and version requirements: native","title":"currentTransaction"},{"location":"1.x/native-driver/com.squareup.sqldelight.drivers.native/-native-sqlite-driver/new-transaction/","text":"native-driver / com.squareup.sqldelight.drivers.native / NativeSqliteDriver / newTransaction newTransaction fun newTransaction(): <ERROR CLASS> Platform and version requirements: native","title":"New transaction"},{"location":"1.x/native-driver/com.squareup.sqldelight.drivers.native/-native-sqlite-driver/new-transaction/#newtransaction","text":"fun newTransaction(): <ERROR CLASS> Platform and version requirements: native","title":"newTransaction"},{"location":"1.x/sqldelight-runtime/","text":"sqldelight-runtime Packages Name Summary com.squareup.sqldelight com.squareup.sqldelight.db com.squareup.sqldelight.logs Index All Types","title":"Home"},{"location":"1.x/sqldelight-runtime/#packages","text":"Name Summary com.squareup.sqldelight com.squareup.sqldelight.db com.squareup.sqldelight.logs","title":"Packages"},{"location":"1.x/sqldelight-runtime/#index","text":"All Types","title":"Index"},{"location":"1.x/sqldelight-runtime/alltypes/","text":"All Types Name Summary com.squareup.sqldelight.db.Closeable A type that can be closed. com.squareup.sqldelight.ColumnAdapter Marshal and map the type T to and from a database type S which is one of Long , Double , String , byte[] . com.squareup.sqldelight.EnumColumnAdapter A ColumnAdapter which maps the enum class T to a string in the database. com.squareup.sqldelight.logs.LogSqliteDriver com.squareup.sqldelight.Query A listenable, typed query generated by SQLDelight. com.squareup.sqldelight.db.SqlCursor Represents a SQL result set which can be iterated through with next . Initially the cursor will not point to any row, and calling next once will iterate to the first row. com.squareup.sqldelight.db.SqlDriver Maintains connections to an underlying SQL database and provides APIs for managing transactions and executing SQL statements. com.squareup.sqldelight.db.SqlPreparedStatement Represents a SQL statement that has been prepared by a driver to be executed. com.squareup.sqldelight.logs.StatementParameterInterceptor com.squareup.sqldelight.Transacter A transaction-aware SqlDriver wrapper which can begin a Transaction on the current connection. com.squareup.sqldelight.TransacterImpl A transaction-aware SqlDriver wrapper which can begin a Transaction on the current connection.","title":"Home"},{"location":"1.x/sqldelight-runtime/alltypes/#all-types","text":"Name Summary com.squareup.sqldelight.db.Closeable A type that can be closed. com.squareup.sqldelight.ColumnAdapter Marshal and map the type T to and from a database type S which is one of Long , Double , String , byte[] . com.squareup.sqldelight.EnumColumnAdapter A ColumnAdapter which maps the enum class T to a string in the database. com.squareup.sqldelight.logs.LogSqliteDriver com.squareup.sqldelight.Query A listenable, typed query generated by SQLDelight. com.squareup.sqldelight.db.SqlCursor Represents a SQL result set which can be iterated through with next . Initially the cursor will not point to any row, and calling next once will iterate to the first row. com.squareup.sqldelight.db.SqlDriver Maintains connections to an underlying SQL database and provides APIs for managing transactions and executing SQL statements. com.squareup.sqldelight.db.SqlPreparedStatement Represents a SQL statement that has been prepared by a driver to be executed. com.squareup.sqldelight.logs.StatementParameterInterceptor com.squareup.sqldelight.Transacter A transaction-aware SqlDriver wrapper which can begin a Transaction on the current connection. com.squareup.sqldelight.TransacterImpl A transaction-aware SqlDriver wrapper which can begin a Transaction on the current connection.","title":"All Types"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/","text":"sqldelight-runtime / com.squareup.sqldelight Package com.squareup.sqldelight Types Name Summary ColumnAdapter interface ColumnAdapter<T : Any , S> Marshal and map the type T to and from a database type S which is one of Long , Double , String , byte[] . EnumColumnAdapter class EnumColumnAdapter<T : Enum < T >> : ColumnAdapter < T , String > A ColumnAdapter which maps the enum class T to a string in the database. Query abstract class Query<out RowType : Any > A listenable, typed query generated by SQLDelight. Transacter interface Transacter A transaction-aware SqlDriver wrapper which can begin a Transaction on the current connection. TransacterImpl abstract class TransacterImpl : Transacter A transaction-aware SqlDriver wrapper which can begin a Transaction on the current connection. Functions Name Summary EnumColumnAdapter fun <T : Enum < T >> EnumColumnAdapter(): EnumColumnAdapter < T > A ColumnAdapter which maps the enum class T to a string in the database. Query fun <RowType : Any > Query(identifier: Int , queries: MutableList < Query <*>>, driver: SqlDriver , query: String , mapper: ( SqlCursor ) -> RowType ): Query < RowType > fun <RowType : Any > Query(identifier: Int , queries: MutableList < Query <*>>, driver: SqlDriver , fileName: String , label: String , query: String , mapper: ( SqlCursor ) -> RowType ): Query < RowType > A listenable, typed query generated by SQLDelight.","title":"Home"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/#package-comsquareupsqldelight","text":"","title":"Package com.squareup.sqldelight"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/#types","text":"Name Summary ColumnAdapter interface ColumnAdapter<T : Any , S> Marshal and map the type T to and from a database type S which is one of Long , Double , String , byte[] . EnumColumnAdapter class EnumColumnAdapter<T : Enum < T >> : ColumnAdapter < T , String > A ColumnAdapter which maps the enum class T to a string in the database. Query abstract class Query<out RowType : Any > A listenable, typed query generated by SQLDelight. Transacter interface Transacter A transaction-aware SqlDriver wrapper which can begin a Transaction on the current connection. TransacterImpl abstract class TransacterImpl : Transacter A transaction-aware SqlDriver wrapper which can begin a Transaction on the current connection.","title":"Types"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/#functions","text":"Name Summary EnumColumnAdapter fun <T : Enum < T >> EnumColumnAdapter(): EnumColumnAdapter < T > A ColumnAdapter which maps the enum class T to a string in the database. Query fun <RowType : Any > Query(identifier: Int , queries: MutableList < Query <*>>, driver: SqlDriver , query: String , mapper: ( SqlCursor ) -> RowType ): Query < RowType > fun <RowType : Any > Query(identifier: Int , queries: MutableList < Query <*>>, driver: SqlDriver , fileName: String , label: String , query: String , mapper: ( SqlCursor ) -> RowType ): Query < RowType > A listenable, typed query generated by SQLDelight.","title":"Functions"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-enum-column-adapter/","text":"sqldelight-runtime / com.squareup.sqldelight / EnumColumnAdapter EnumColumnAdapter inline fun <reified T : Enum < T >> EnumColumnAdapter(): EnumColumnAdapter < T > A ColumnAdapter which maps the enum class T to a string in the database.","title":" enum column adapter"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-enum-column-adapter/#enumcolumnadapter","text":"inline fun <reified T : Enum < T >> EnumColumnAdapter(): EnumColumnAdapter < T > A ColumnAdapter which maps the enum class T to a string in the database.","title":"EnumColumnAdapter"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-query/","text":"sqldelight-runtime / com.squareup.sqldelight / Query Query fun <RowType : Any > Query(identifier: Int , queries: MutableList < Query <*>>, driver: SqlDriver , query: String , mapper: ( SqlCursor ) -> RowType ): Query < RowType > fun <RowType : Any > Query(identifier: Int , queries: MutableList < Query <*>>, driver: SqlDriver , fileName: String , label: String , query: String , mapper: ( SqlCursor ) -> RowType ): Query < RowType > A listenable, typed query generated by SQLDelight. Parameters RowType - the type that this query can map its result set to.","title":" query"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-query/#query","text":"fun <RowType : Any > Query(identifier: Int , queries: MutableList < Query <*>>, driver: SqlDriver , query: String , mapper: ( SqlCursor ) -> RowType ): Query < RowType > fun <RowType : Any > Query(identifier: Int , queries: MutableList < Query <*>>, driver: SqlDriver , fileName: String , label: String , query: String , mapper: ( SqlCursor ) -> RowType ): Query < RowType > A listenable, typed query generated by SQLDelight.","title":"Query"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-query/#parameters","text":"RowType - the type that this query can map its result set to.","title":"Parameters"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-column-adapter/","text":"sqldelight-runtime / com.squareup.sqldelight / ColumnAdapter ColumnAdapter interface ColumnAdapter<T : Any , S> Marshal and map the type T to and from a database type S which is one of Long , Double , String , byte[] . Functions Name Summary decode abstract fun decode(databaseValue: S ): T encode abstract fun encode(value: T ): S Inheritors Name Summary EnumColumnAdapter class EnumColumnAdapter<T : Enum < T >> : ColumnAdapter < T , String > A ColumnAdapter which maps the enum class T to a string in the database.","title":"Home"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-column-adapter/#columnadapter","text":"interface ColumnAdapter<T : Any , S> Marshal and map the type T to and from a database type S which is one of Long , Double , String , byte[] .","title":"ColumnAdapter"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-column-adapter/#functions","text":"Name Summary decode abstract fun decode(databaseValue: S ): T encode abstract fun encode(value: T ): S","title":"Functions"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-column-adapter/#inheritors","text":"Name Summary EnumColumnAdapter class EnumColumnAdapter<T : Enum < T >> : ColumnAdapter < T , String > A ColumnAdapter which maps the enum class T to a string in the database.","title":"Inheritors"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-column-adapter/decode/","text":"sqldelight-runtime / com.squareup.sqldelight / ColumnAdapter / decode decode abstract fun decode(databaseValue: S ): T Return databaseValue decoded as type T .","title":"Decode"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-column-adapter/decode/#decode","text":"abstract fun decode(databaseValue: S ): T Return databaseValue decoded as type T .","title":"decode"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-column-adapter/encode/","text":"sqldelight-runtime / com.squareup.sqldelight / ColumnAdapter / encode encode abstract fun encode(value: T ): S Return value encoded as database type S .","title":"Encode"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-column-adapter/encode/#encode","text":"abstract fun encode(value: T ): S Return value encoded as database type S .","title":"encode"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-enum-column-adapter/","text":"sqldelight-runtime / com.squareup.sqldelight / EnumColumnAdapter EnumColumnAdapter class EnumColumnAdapter<T : Enum < T >> : ColumnAdapter < T , String > A ColumnAdapter which maps the enum class T to a string in the database. Functions Name Summary decode fun decode(databaseValue: String ): T encode fun encode(value: T ): String","title":"Home"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-enum-column-adapter/#enumcolumnadapter","text":"class EnumColumnAdapter<T : Enum < T >> : ColumnAdapter < T , String > A ColumnAdapter which maps the enum class T to a string in the database.","title":"EnumColumnAdapter"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-enum-column-adapter/#functions","text":"Name Summary decode fun decode(databaseValue: String ): T encode fun encode(value: T ): String","title":"Functions"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-enum-column-adapter/decode/","text":"sqldelight-runtime / com.squareup.sqldelight / EnumColumnAdapter / decode decode fun decode(databaseValue: String ): T Overrides ColumnAdapter.decode Return databaseValue decoded as type T .","title":"Decode"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-enum-column-adapter/decode/#decode","text":"fun decode(databaseValue: String ): T Overrides ColumnAdapter.decode Return databaseValue decoded as type T .","title":"decode"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-enum-column-adapter/encode/","text":"sqldelight-runtime / com.squareup.sqldelight / EnumColumnAdapter / encode encode fun encode(value: T ): String Overrides ColumnAdapter.encode Return value encoded as database type S .","title":"Encode"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-enum-column-adapter/encode/#encode","text":"fun encode(value: T ): String Overrides ColumnAdapter.encode Return value encoded as database type S .","title":"encode"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-query/","text":"sqldelight-runtime / com.squareup.sqldelight / Query Query abstract class Query<out RowType : Any > A listenable, typed query generated by SQLDelight. Parameters RowType - the type that this query can map its result set to. Types Name Summary Listener interface Listener An interface for listening to changes in the result set of a query. Constructors Name Summary <init> Query(queries: MutableList < Query <*>>, mapper: ( SqlCursor ) -> RowType ) A listenable, typed query generated by SQLDelight. Properties Name Summary mapper val mapper: ( SqlCursor ) -> RowType The mapper this Query was created with, which can convert a row in the SQL cursor returned by execute to RowType . Functions Name Summary addListener fun addListener(listener: Listener ): Unit Register a listener to be notified of future changes in the result set. execute abstract fun execute(): SqlCursor Execute the underlying statement. executeAsList fun executeAsList(): List < RowType > executeAsOne fun executeAsOne(): RowType executeAsOneOrNull fun executeAsOneOrNull(): RowType ? notifyDataChanged fun notifyDataChanged(): Unit Notify listeners that their current result set is staled. removeListener fun removeListener(listener: Listener ): Unit Remove a listener to no longer be notified of future changes in the result set.","title":"Home"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-query/#query","text":"abstract class Query<out RowType : Any > A listenable, typed query generated by SQLDelight.","title":"Query"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-query/#parameters","text":"RowType - the type that this query can map its result set to.","title":"Parameters"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-query/#types","text":"Name Summary Listener interface Listener An interface for listening to changes in the result set of a query.","title":"Types"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-query/#constructors","text":"Name Summary <init> Query(queries: MutableList < Query <*>>, mapper: ( SqlCursor ) -> RowType ) A listenable, typed query generated by SQLDelight.","title":"Constructors"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-query/#properties","text":"Name Summary mapper val mapper: ( SqlCursor ) -> RowType The mapper this Query was created with, which can convert a row in the SQL cursor returned by execute to RowType .","title":"Properties"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-query/#functions","text":"Name Summary addListener fun addListener(listener: Listener ): Unit Register a listener to be notified of future changes in the result set. execute abstract fun execute(): SqlCursor Execute the underlying statement. executeAsList fun executeAsList(): List < RowType > executeAsOne fun executeAsOne(): RowType executeAsOneOrNull fun executeAsOneOrNull(): RowType ? notifyDataChanged fun notifyDataChanged(): Unit Notify listeners that their current result set is staled. removeListener fun removeListener(listener: Listener ): Unit Remove a listener to no longer be notified of future changes in the result set.","title":"Functions"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-query/-init-/","text":"sqldelight-runtime / com.squareup.sqldelight / Query / <init> <init> Query(queries: MutableList < Query <*>>, mapper: ( SqlCursor ) -> RowType ) A listenable, typed query generated by SQLDelight. Parameters RowType - the type that this query can map its result set to.","title":" init "},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-query/-init-/#init","text":"Query(queries: MutableList < Query <*>>, mapper: ( SqlCursor ) -> RowType ) A listenable, typed query generated by SQLDelight.","title":"&lt;init&gt;"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-query/-init-/#parameters","text":"RowType - the type that this query can map its result set to.","title":"Parameters"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-query/add-listener/","text":"sqldelight-runtime / com.squareup.sqldelight / Query / addListener addListener fun addListener(listener: Listener ): Unit Register a listener to be notified of future changes in the result set.","title":"Add listener"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-query/add-listener/#addlistener","text":"fun addListener(listener: Listener ): Unit Register a listener to be notified of future changes in the result set.","title":"addListener"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-query/execute-as-list/","text":"sqldelight-runtime / com.squareup.sqldelight / Query / executeAsList executeAsList fun executeAsList(): List < RowType > Return The result set of the underlying SQL statement as a list of RowType .","title":"Execute as list"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-query/execute-as-list/#executeaslist","text":"fun executeAsList(): List < RowType > Return The result set of the underlying SQL statement as a list of RowType .","title":"executeAsList"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-query/execute-as-one-or-null/","text":"sqldelight-runtime / com.squareup.sqldelight / Query / executeAsOneOrNull executeAsOneOrNull fun executeAsOneOrNull(): RowType ? Exceptions IllegalStateException - if when executed this query has multiple rows in its result set. Return The first row of the result set for the underlying SQL statement as a non null RowType or null if the result set has no rows.","title":"Execute as one or null"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-query/execute-as-one-or-null/#executeasoneornull","text":"fun executeAsOneOrNull(): RowType ?","title":"executeAsOneOrNull"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-query/execute-as-one-or-null/#exceptions","text":"IllegalStateException - if when executed this query has multiple rows in its result set. Return The first row of the result set for the underlying SQL statement as a non null RowType or null if the result set has no rows.","title":"Exceptions"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-query/execute-as-one/","text":"sqldelight-runtime / com.squareup.sqldelight / Query / executeAsOne executeAsOne fun executeAsOne(): RowType Exceptions NullPointerException - if when executed this query has no rows in its result set. IllegalStateException - if when executed this query has multiple rows in its result set. Return The only row of the result set for the underlying SQL statement as a non null RowType .","title":"Execute as one"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-query/execute-as-one/#executeasone","text":"fun executeAsOne(): RowType","title":"executeAsOne"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-query/execute-as-one/#exceptions","text":"NullPointerException - if when executed this query has no rows in its result set. IllegalStateException - if when executed this query has multiple rows in its result set. Return The only row of the result set for the underlying SQL statement as a non null RowType .","title":"Exceptions"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-query/execute/","text":"sqldelight-runtime / com.squareup.sqldelight / Query / execute execute abstract fun execute(): SqlCursor Execute the underlying statement. Return the cursor for the statement's result set.","title":"Execute"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-query/execute/#execute","text":"abstract fun execute(): SqlCursor Execute the underlying statement. Return the cursor for the statement's result set.","title":"execute"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-query/mapper/","text":"sqldelight-runtime / com.squareup.sqldelight / Query / mapper mapper val mapper: ( SqlCursor ) -> RowType The mapper this Query was created with, which can convert a row in the SQL cursor returned by execute to RowType . Property mapper - The mapper this Query was created with, which can convert a row in the SQL cursor returned by execute to RowType .","title":"Mapper"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-query/mapper/#mapper","text":"val mapper: ( SqlCursor ) -> RowType The mapper this Query was created with, which can convert a row in the SQL cursor returned by execute to RowType .","title":"mapper"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-query/mapper/#property","text":"mapper - The mapper this Query was created with, which can convert a row in the SQL cursor returned by execute to RowType .","title":"Property"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-query/notify-data-changed/","text":"sqldelight-runtime / com.squareup.sqldelight / Query / notifyDataChanged notifyDataChanged fun notifyDataChanged(): Unit Notify listeners that their current result set is staled. Called internally by SQLDelight when it detects a possible staling of the result set. Emits some false positives but never misses a true positive.","title":"Notify data changed"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-query/notify-data-changed/#notifydatachanged","text":"fun notifyDataChanged(): Unit Notify listeners that their current result set is staled. Called internally by SQLDelight when it detects a possible staling of the result set. Emits some false positives but never misses a true positive.","title":"notifyDataChanged"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-query/remove-listener/","text":"sqldelight-runtime / com.squareup.sqldelight / Query / removeListener removeListener fun removeListener(listener: Listener ): Unit Remove a listener to no longer be notified of future changes in the result set.","title":"Remove listener"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-query/remove-listener/#removelistener","text":"fun removeListener(listener: Listener ): Unit Remove a listener to no longer be notified of future changes in the result set.","title":"removeListener"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-query/-listener/","text":"sqldelight-runtime / com.squareup.sqldelight / Query / Listener Listener interface Listener An interface for listening to changes in the result set of a query. Functions Name Summary queryResultsChanged abstract fun queryResultsChanged(): Unit Called whenever the query this listener was attached to is dirtied.","title":"Home"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-query/-listener/#listener","text":"interface Listener An interface for listening to changes in the result set of a query.","title":"Listener"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-query/-listener/#functions","text":"Name Summary queryResultsChanged abstract fun queryResultsChanged(): Unit Called whenever the query this listener was attached to is dirtied.","title":"Functions"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-query/-listener/query-results-changed/","text":"sqldelight-runtime / com.squareup.sqldelight / Query / Listener / queryResultsChanged queryResultsChanged abstract fun queryResultsChanged(): Unit Called whenever the query this listener was attached to is dirtied.","title":"Query results changed"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-query/-listener/query-results-changed/#queryresultschanged","text":"abstract fun queryResultsChanged(): Unit Called whenever the query this listener was attached to is dirtied.","title":"queryResultsChanged"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter/","text":"sqldelight-runtime / com.squareup.sqldelight / Transacter Transacter interface Transacter A transaction-aware SqlDriver wrapper which can begin a Transaction on the current connection. Types Name Summary Transaction abstract class Transaction A SQL transaction. Can be created through the driver via SqlDriver.newTransaction or through an implementation of Transacter by calling Transacter.transaction . Functions Name Summary transaction abstract fun transaction(noEnclosing: Boolean = false, body: Transaction .() -> Unit ): Unit Inheritors Name Summary TransacterImpl abstract class TransacterImpl : Transacter A transaction-aware SqlDriver wrapper which can begin a Transaction on the current connection.","title":"Home"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter/#transacter","text":"interface Transacter A transaction-aware SqlDriver wrapper which can begin a Transaction on the current connection.","title":"Transacter"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter/#types","text":"Name Summary Transaction abstract class Transaction A SQL transaction. Can be created through the driver via SqlDriver.newTransaction or through an implementation of Transacter by calling Transacter.transaction .","title":"Types"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter/#functions","text":"Name Summary transaction abstract fun transaction(noEnclosing: Boolean = false, body: Transaction .() -> Unit ): Unit","title":"Functions"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter/#inheritors","text":"Name Summary TransacterImpl abstract class TransacterImpl : Transacter A transaction-aware SqlDriver wrapper which can begin a Transaction on the current connection.","title":"Inheritors"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter/transaction/","text":"sqldelight-runtime / com.squareup.sqldelight / Transacter / transaction transaction abstract fun transaction(noEnclosing: Boolean = false, body: Transaction .() -> Unit ): Unit","title":"Transaction"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter/transaction/#transaction","text":"abstract fun transaction(noEnclosing: Boolean = false, body: Transaction .() -> Unit ): Unit","title":"transaction"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter/-transaction/","text":"sqldelight-runtime / com.squareup.sqldelight / Transacter / Transaction Transaction abstract class Transaction A SQL transaction. Can be created through the driver via SqlDriver.newTransaction or through an implementation of Transacter by calling Transacter.transaction . Constructors Name Summary <init> Transaction() A SQL transaction. Can be created through the driver via SqlDriver.newTransaction or through an implementation of Transacter by calling Transacter.transaction . Properties Name Summary enclosingTransaction abstract val enclosingTransaction: Transaction ? The parent transaction, if there is any. Functions Name Summary afterCommit fun afterCommit(function: () -> Unit ): Unit Queues function to be run after this transaction successfully commits. afterRollback fun afterRollback(function: () -> Unit ): Unit Queues function to be run after this transaction rolls back. endTransaction abstract fun endTransaction(successful: Boolean ): Unit Signal to the underlying SQL driver that this transaction should be finished. rollback fun rollback(): Nothing Rolls back this transaction. transaction fun transaction(body: Transaction .() -> Unit ): Unit Begin an inner transaction.","title":"Home"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter/-transaction/#transaction","text":"abstract class Transaction A SQL transaction. Can be created through the driver via SqlDriver.newTransaction or through an implementation of Transacter by calling Transacter.transaction .","title":"Transaction"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter/-transaction/#constructors","text":"Name Summary <init> Transaction() A SQL transaction. Can be created through the driver via SqlDriver.newTransaction or through an implementation of Transacter by calling Transacter.transaction .","title":"Constructors"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter/-transaction/#properties","text":"Name Summary enclosingTransaction abstract val enclosingTransaction: Transaction ? The parent transaction, if there is any.","title":"Properties"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter/-transaction/#functions","text":"Name Summary afterCommit fun afterCommit(function: () -> Unit ): Unit Queues function to be run after this transaction successfully commits. afterRollback fun afterRollback(function: () -> Unit ): Unit Queues function to be run after this transaction rolls back. endTransaction abstract fun endTransaction(successful: Boolean ): Unit Signal to the underlying SQL driver that this transaction should be finished. rollback fun rollback(): Nothing Rolls back this transaction. transaction fun transaction(body: Transaction .() -> Unit ): Unit Begin an inner transaction.","title":"Functions"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter/-transaction/-init-/","text":"sqldelight-runtime / com.squareup.sqldelight / Transacter / Transaction / <init> <init> Transaction() A SQL transaction. Can be created through the driver via SqlDriver.newTransaction or through an implementation of Transacter by calling Transacter.transaction .","title":" init "},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter/-transaction/-init-/#init","text":"Transaction() A SQL transaction. Can be created through the driver via SqlDriver.newTransaction or through an implementation of Transacter by calling Transacter.transaction .","title":"&lt;init&gt;"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter/-transaction/after-commit/","text":"sqldelight-runtime / com.squareup.sqldelight / Transacter / Transaction / afterCommit afterCommit fun afterCommit(function: () -> Unit ): Unit Queues function to be run after this transaction successfully commits.","title":"After commit"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter/-transaction/after-commit/#aftercommit","text":"fun afterCommit(function: () -> Unit ): Unit Queues function to be run after this transaction successfully commits.","title":"afterCommit"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter/-transaction/after-rollback/","text":"sqldelight-runtime / com.squareup.sqldelight / Transacter / Transaction / afterRollback afterRollback fun afterRollback(function: () -> Unit ): Unit Queues function to be run after this transaction rolls back.","title":"After rollback"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter/-transaction/after-rollback/#afterrollback","text":"fun afterRollback(function: () -> Unit ): Unit Queues function to be run after this transaction rolls back.","title":"afterRollback"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter/-transaction/enclosing-transaction/","text":"sqldelight-runtime / com.squareup.sqldelight / Transacter / Transaction / enclosingTransaction enclosingTransaction protected abstract val enclosingTransaction: Transaction ? The parent transaction, if there is any.","title":"Enclosing transaction"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter/-transaction/enclosing-transaction/#enclosingtransaction","text":"protected abstract val enclosingTransaction: Transaction ? The parent transaction, if there is any.","title":"enclosingTransaction"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter/-transaction/end-transaction/","text":"sqldelight-runtime / com.squareup.sqldelight / Transacter / Transaction / endTransaction endTransaction protected abstract fun endTransaction(successful: Boolean ): Unit Signal to the underlying SQL driver that this transaction should be finished. Parameters successful - Whether the transaction completed successfully or not.","title":"End transaction"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter/-transaction/end-transaction/#endtransaction","text":"protected abstract fun endTransaction(successful: Boolean ): Unit Signal to the underlying SQL driver that this transaction should be finished.","title":"endTransaction"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter/-transaction/end-transaction/#parameters","text":"successful - Whether the transaction completed successfully or not.","title":"Parameters"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter/-transaction/rollback/","text":"sqldelight-runtime / com.squareup.sqldelight / Transacter / Transaction / rollback rollback fun rollback(): Nothing Rolls back this transaction.","title":"Rollback"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter/-transaction/rollback/#rollback","text":"fun rollback(): Nothing Rolls back this transaction.","title":"rollback"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter/-transaction/transaction/","text":"sqldelight-runtime / com.squareup.sqldelight / Transacter / Transaction / transaction transaction fun transaction(body: Transaction .() -> Unit ): Unit Begin an inner transaction.","title":"Transaction"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter/-transaction/transaction/#transaction","text":"fun transaction(body: Transaction .() -> Unit ): Unit Begin an inner transaction.","title":"transaction"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter-impl/","text":"sqldelight-runtime / com.squareup.sqldelight / TransacterImpl TransacterImpl abstract class TransacterImpl : Transacter A transaction-aware SqlDriver wrapper which can begin a Transaction on the current connection. Constructors Name Summary <init> TransacterImpl(driver: SqlDriver ) A transaction-aware SqlDriver wrapper which can begin a Transaction on the current connection. Functions Name Summary createArguments fun createArguments(count: Int , offset: Int ): String For internal use, creates a string in the format (?3, ?4, ?5) where the first index is offset and there are count total indexes. notifyQueries fun notifyQueries(identifier: Int , queryList: () -> List < Query <*>>): Unit For internal use, notifies the listeners of queryList that their underlying result set has changed. transaction open fun transaction(noEnclosing: Boolean , body: Transaction .() -> Unit ): Unit Starts a Transaction and runs body in that transaction.","title":"Home"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter-impl/#transacterimpl","text":"abstract class TransacterImpl : Transacter A transaction-aware SqlDriver wrapper which can begin a Transaction on the current connection.","title":"TransacterImpl"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter-impl/#constructors","text":"Name Summary <init> TransacterImpl(driver: SqlDriver ) A transaction-aware SqlDriver wrapper which can begin a Transaction on the current connection.","title":"Constructors"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter-impl/#functions","text":"Name Summary createArguments fun createArguments(count: Int , offset: Int ): String For internal use, creates a string in the format (?3, ?4, ?5) where the first index is offset and there are count total indexes. notifyQueries fun notifyQueries(identifier: Int , queryList: () -> List < Query <*>>): Unit For internal use, notifies the listeners of queryList that their underlying result set has changed. transaction open fun transaction(noEnclosing: Boolean , body: Transaction .() -> Unit ): Unit Starts a Transaction and runs body in that transaction.","title":"Functions"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter-impl/-init-/","text":"sqldelight-runtime / com.squareup.sqldelight / TransacterImpl / <init> <init> TransacterImpl(driver: SqlDriver ) A transaction-aware SqlDriver wrapper which can begin a Transaction on the current connection.","title":" init "},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter-impl/-init-/#init","text":"TransacterImpl(driver: SqlDriver ) A transaction-aware SqlDriver wrapper which can begin a Transaction on the current connection.","title":"&lt;init&gt;"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter-impl/create-arguments/","text":"sqldelight-runtime / com.squareup.sqldelight / TransacterImpl / createArguments createArguments protected fun createArguments(count: Int , offset: Int ): String For internal use, creates a string in the format (?3, ?4, ?5) where the first index is offset and there are count total indexes.","title":"Create arguments"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter-impl/create-arguments/#createarguments","text":"protected fun createArguments(count: Int , offset: Int ): String For internal use, creates a string in the format (?3, ?4, ?5) where the first index is offset and there are count total indexes.","title":"createArguments"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter-impl/notify-queries/","text":"sqldelight-runtime / com.squareup.sqldelight / TransacterImpl / notifyQueries notifyQueries protected fun notifyQueries(identifier: Int , queryList: () -> List < Query <*>>): Unit For internal use, notifies the listeners of queryList that their underlying result set has changed.","title":"Notify queries"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter-impl/notify-queries/#notifyqueries","text":"protected fun notifyQueries(identifier: Int , queryList: () -> List < Query <*>>): Unit For internal use, notifies the listeners of queryList that their underlying result set has changed.","title":"notifyQueries"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter-impl/transaction/","text":"sqldelight-runtime / com.squareup.sqldelight / TransacterImpl / transaction transaction open fun transaction(noEnclosing: Boolean , body: Transaction .() -> Unit ): Unit Overrides Transacter.transaction Starts a Transaction and runs body in that transaction. Exceptions IllegalStateException - if noEnclosing is true and there is already an active Transaction on this thread.","title":"Transaction"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter-impl/transaction/#transaction","text":"open fun transaction(noEnclosing: Boolean , body: Transaction .() -> Unit ): Unit Overrides Transacter.transaction Starts a Transaction and runs body in that transaction.","title":"transaction"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight/-transacter-impl/transaction/#exceptions","text":"IllegalStateException - if noEnclosing is true and there is already an active Transaction on this thread.","title":"Exceptions"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/","text":"sqldelight-runtime / com.squareup.sqldelight.db Package com.squareup.sqldelight.db Types Name Summary Closeable (JVM, js, native) expect interface Closeable A type that can be closed. SqlCursor interface SqlCursor : Closeable Represents a SQL result set which can be iterated through with next . Initially the cursor will not point to any row, and calling next once will iterate to the first row. SqlDriver interface SqlDriver : Closeable Maintains connections to an underlying SQL database and provides APIs for managing transactions and executing SQL statements. SqlPreparedStatement interface SqlPreparedStatement Represents a SQL statement that has been prepared by a driver to be executed. Functions Name Summary use (JVM, js, native) expect fun <T : Closeable ?, R> T .use(body: ( T ) -> R ): R Run body on this and call Closeable.close before returning or throwing.","title":"Home"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/#package-comsquareupsqldelightdb","text":"","title":"Package com.squareup.sqldelight.db"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/#types","text":"Name Summary Closeable (JVM, js, native) expect interface Closeable A type that can be closed. SqlCursor interface SqlCursor : Closeable Represents a SQL result set which can be iterated through with next . Initially the cursor will not point to any row, and calling next once will iterate to the first row. SqlDriver interface SqlDriver : Closeable Maintains connections to an underlying SQL database and provides APIs for managing transactions and executing SQL statements. SqlPreparedStatement interface SqlPreparedStatement Represents a SQL statement that has been prepared by a driver to be executed.","title":"Types"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/#functions","text":"Name Summary use (JVM, js, native) expect fun <T : Closeable ?, R> T .use(body: ( T ) -> R ): R Run body on this and call Closeable.close before returning or throwing.","title":"Functions"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/use/","text":"sqldelight-runtime / com.squareup.sqldelight.db / use use inline expect fun <T : Closeable ?, R> T .use(body: ( T ) -> R ): R Platform and version requirements: JVM, js, native Run body on this and call Closeable.close before returning or throwing.","title":"Use"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/use/#use","text":"inline expect fun <T : Closeable ?, R> T .use(body: ( T ) -> R ): R Platform and version requirements: JVM, js, native Run body on this and call Closeable.close before returning or throwing.","title":"use"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-closeable/","text":"sqldelight-runtime / com.squareup.sqldelight.db / Closeable Closeable expect interface Closeable Platform and version requirements: JVM, js, native A type that can be closed. Functions Name Summary close (js, native) abstract fun close(): Unit Close any resources backed by this object. Extension Functions Name Summary use (JVM, js, native) expect fun <T : Closeable ?, R> T .use(body: ( T ) -> R ): R Run body on this and call Closeable.close before returning or throwing. Inheritors Name Summary SqlCursor interface SqlCursor : Closeable Represents a SQL result set which can be iterated through with next . Initially the cursor will not point to any row, and calling next once will iterate to the first row. SqlDriver interface SqlDriver : Closeable Maintains connections to an underlying SQL database and provides APIs for managing transactions and executing SQL statements.","title":"Home"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-closeable/#closeable","text":"expect interface Closeable Platform and version requirements: JVM, js, native A type that can be closed.","title":"Closeable"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-closeable/#functions","text":"Name Summary close (js, native) abstract fun close(): Unit Close any resources backed by this object.","title":"Functions"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-closeable/#extension-functions","text":"Name Summary use (JVM, js, native) expect fun <T : Closeable ?, R> T .use(body: ( T ) -> R ): R Run body on this and call Closeable.close before returning or throwing.","title":"Extension Functions"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-closeable/#inheritors","text":"Name Summary SqlCursor interface SqlCursor : Closeable Represents a SQL result set which can be iterated through with next . Initially the cursor will not point to any row, and calling next once will iterate to the first row. SqlDriver interface SqlDriver : Closeable Maintains connections to an underlying SQL database and provides APIs for managing transactions and executing SQL statements.","title":"Inheritors"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-closeable/close/","text":"sqldelight-runtime / com.squareup.sqldelight.db / Closeable / close close abstract fun close(): Unit Platform and version requirements: js, native Close any resources backed by this object.","title":"Close"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-closeable/close/#close","text":"abstract fun close(): Unit Platform and version requirements: js, native Close any resources backed by this object.","title":"close"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-cursor/","text":"sqldelight-runtime / com.squareup.sqldelight.db / SqlCursor SqlCursor interface SqlCursor : Closeable Represents a SQL result set which can be iterated through with next . Initially the cursor will not point to any row, and calling next once will iterate to the first row. Functions Name Summary getBytes abstract fun getBytes(index: Int ): ByteArray ? getDouble abstract fun getDouble(index: Int ): Double ? getLong abstract fun getLong(index: Int ): Long ? getString abstract fun getString(index: Int ): String ? next abstract fun next(): Boolean Move to the next row in the result set. Inherited Functions Name Summary close (js, native) abstract fun close(): Unit Close any resources backed by this object.","title":"Home"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-cursor/#sqlcursor","text":"interface SqlCursor : Closeable Represents a SQL result set which can be iterated through with next . Initially the cursor will not point to any row, and calling next once will iterate to the first row.","title":"SqlCursor"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-cursor/#functions","text":"Name Summary getBytes abstract fun getBytes(index: Int ): ByteArray ? getDouble abstract fun getDouble(index: Int ): Double ? getLong abstract fun getLong(index: Int ): Long ? getString abstract fun getString(index: Int ): String ? next abstract fun next(): Boolean Move to the next row in the result set.","title":"Functions"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-cursor/#inherited-functions","text":"Name Summary close (js, native) abstract fun close(): Unit Close any resources backed by this object.","title":"Inherited Functions"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-cursor/get-bytes/","text":"sqldelight-runtime / com.squareup.sqldelight.db / SqlCursor / getBytes getBytes abstract fun getBytes(index: Int ): ByteArray ? Return The bytes or null value of column index for the current row of the result set.","title":"Get bytes"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-cursor/get-bytes/#getbytes","text":"abstract fun getBytes(index: Int ): ByteArray ? Return The bytes or null value of column index for the current row of the result set.","title":"getBytes"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-cursor/get-double/","text":"sqldelight-runtime / com.squareup.sqldelight.db / SqlCursor / getDouble getDouble abstract fun getDouble(index: Int ): Double ? Return The double or null value of column index for the current row of the result set.","title":"Get double"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-cursor/get-double/#getdouble","text":"abstract fun getDouble(index: Int ): Double ? Return The double or null value of column index for the current row of the result set.","title":"getDouble"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-cursor/get-long/","text":"sqldelight-runtime / com.squareup.sqldelight.db / SqlCursor / getLong getLong abstract fun getLong(index: Int ): Long ? Return The int or null value of column index for the current row of the result set.","title":"Get long"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-cursor/get-long/#getlong","text":"abstract fun getLong(index: Int ): Long ? Return The int or null value of column index for the current row of the result set.","title":"getLong"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-cursor/get-string/","text":"sqldelight-runtime / com.squareup.sqldelight.db / SqlCursor / getString getString abstract fun getString(index: Int ): String ? Return The string or null value of column index for the current row of the result set.","title":"Get string"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-cursor/get-string/#getstring","text":"abstract fun getString(index: Int ): String ? Return The string or null value of column index for the current row of the result set.","title":"getString"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-cursor/next/","text":"sqldelight-runtime / com.squareup.sqldelight.db / SqlCursor / next next abstract fun next(): Boolean Move to the next row in the result set. Return true if the cursor successfully moved to a new row, false if there was no row to iterate to.","title":"Next"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-cursor/next/#next","text":"abstract fun next(): Boolean Move to the next row in the result set. Return true if the cursor successfully moved to a new row, false if there was no row to iterate to.","title":"next"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-driver/","text":"sqldelight-runtime / com.squareup.sqldelight.db / SqlDriver SqlDriver interface SqlDriver : Closeable Maintains connections to an underlying SQL database and provides APIs for managing transactions and executing SQL statements. Types Name Summary Schema interface Schema API for creating and migrating a SQL database. Functions Name Summary currentTransaction abstract fun currentTransaction(): Transaction ? The currently open Transacter.Transaction on the database. execute abstract fun execute(identifier: Int ?, sql: String , parameters: Int , binders: SqlPreparedStatement .() -> Unit = null): Unit Execute a SQL statement. executeQuery abstract fun executeQuery(identifier: Int ?, sql: String , parameters: Int , binders: SqlPreparedStatement .() -> Unit = null): SqlCursor Execute a SQL statement and return a SqlCursor that iterates the result set. newTransaction abstract fun newTransaction(): Transaction Start a new Transacter.Transaction on the database. Inherited Functions Name Summary close (js, native) abstract fun close(): Unit Close any resources backed by this object. Inheritors Name Summary LogSqliteDriver class LogSqliteDriver : SqlDriver","title":"Home"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-driver/#sqldriver","text":"interface SqlDriver : Closeable Maintains connections to an underlying SQL database and provides APIs for managing transactions and executing SQL statements.","title":"SqlDriver"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-driver/#types","text":"Name Summary Schema interface Schema API for creating and migrating a SQL database.","title":"Types"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-driver/#functions","text":"Name Summary currentTransaction abstract fun currentTransaction(): Transaction ? The currently open Transacter.Transaction on the database. execute abstract fun execute(identifier: Int ?, sql: String , parameters: Int , binders: SqlPreparedStatement .() -> Unit = null): Unit Execute a SQL statement. executeQuery abstract fun executeQuery(identifier: Int ?, sql: String , parameters: Int , binders: SqlPreparedStatement .() -> Unit = null): SqlCursor Execute a SQL statement and return a SqlCursor that iterates the result set. newTransaction abstract fun newTransaction(): Transaction Start a new Transacter.Transaction on the database.","title":"Functions"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-driver/#inherited-functions","text":"Name Summary close (js, native) abstract fun close(): Unit Close any resources backed by this object.","title":"Inherited Functions"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-driver/#inheritors","text":"Name Summary LogSqliteDriver class LogSqliteDriver : SqlDriver","title":"Inheritors"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-driver/current-transaction/","text":"sqldelight-runtime / com.squareup.sqldelight.db / SqlDriver / currentTransaction currentTransaction abstract fun currentTransaction(): Transaction ? The currently open Transacter.Transaction on the database. It's up to the implementor how this method behaves for different connection/threading patterns.","title":"Current transaction"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-driver/current-transaction/#currenttransaction","text":"abstract fun currentTransaction(): Transaction ? The currently open Transacter.Transaction on the database. It's up to the implementor how this method behaves for different connection/threading patterns.","title":"currentTransaction"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-driver/execute-query/","text":"sqldelight-runtime / com.squareup.sqldelight.db / SqlDriver / executeQuery executeQuery abstract fun executeQuery(identifier: Int ?, sql: String , parameters: Int , binders: SqlPreparedStatement .() -> Unit = null): SqlCursor Execute a SQL statement and return a SqlCursor that iterates the result set. Parameters identifier - An opaque, unique value that can be used to implement any driver-side caching of prepared statements. If identifier is null, a fresh statement is required. sql - The SQL string to be executed. parameters - The number of bindable parameters sql contains. binders - A lambda which is called before execution to bind any parameters to the SQL statement.","title":"Execute query"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-driver/execute-query/#executequery","text":"abstract fun executeQuery(identifier: Int ?, sql: String , parameters: Int , binders: SqlPreparedStatement .() -> Unit = null): SqlCursor Execute a SQL statement and return a SqlCursor that iterates the result set.","title":"executeQuery"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-driver/execute-query/#parameters","text":"identifier - An opaque, unique value that can be used to implement any driver-side caching of prepared statements. If identifier is null, a fresh statement is required. sql - The SQL string to be executed. parameters - The number of bindable parameters sql contains. binders - A lambda which is called before execution to bind any parameters to the SQL statement.","title":"Parameters"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-driver/execute/","text":"sqldelight-runtime / com.squareup.sqldelight.db / SqlDriver / execute execute abstract fun execute(identifier: Int ?, sql: String , parameters: Int , binders: SqlPreparedStatement .() -> Unit = null): Unit Execute a SQL statement. Parameters identifier - An opaque, unique value that can be used to implement any driver-side caching of prepared statements. If identifier is null, a fresh statement is required. sql - The SQL string to be executed. parameters - The number of bindable parameters sql contains. binders - A lambda which is called before execution to bind any parameters to the SQL statement.","title":"Execute"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-driver/execute/#execute","text":"abstract fun execute(identifier: Int ?, sql: String , parameters: Int , binders: SqlPreparedStatement .() -> Unit = null): Unit Execute a SQL statement.","title":"execute"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-driver/execute/#parameters","text":"identifier - An opaque, unique value that can be used to implement any driver-side caching of prepared statements. If identifier is null, a fresh statement is required. sql - The SQL string to be executed. parameters - The number of bindable parameters sql contains. binders - A lambda which is called before execution to bind any parameters to the SQL statement.","title":"Parameters"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-driver/new-transaction/","text":"sqldelight-runtime / com.squareup.sqldelight.db / SqlDriver / newTransaction newTransaction abstract fun newTransaction(): Transaction Start a new Transacter.Transaction on the database. It's up to the implementor how this method behaves for different connection/threading patterns.","title":"New transaction"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-driver/new-transaction/#newtransaction","text":"abstract fun newTransaction(): Transaction Start a new Transacter.Transaction on the database. It's up to the implementor how this method behaves for different connection/threading patterns.","title":"newTransaction"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-driver/-schema/","text":"sqldelight-runtime / com.squareup.sqldelight.db / SqlDriver / Schema Schema interface Schema API for creating and migrating a SQL database. Properties Name Summary version abstract val version: Int The version of this schema. Functions Name Summary create abstract fun create(driver: SqlDriver ): Unit Use driver to create the schema from scratch. Assumes no existing database state. migrate abstract fun migrate(driver: SqlDriver , oldVersion: Int , newVersion: Int ): Unit Use driver to migrate from schema oldVersion to newVersion .","title":"Home"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-driver/-schema/#schema","text":"interface Schema API for creating and migrating a SQL database.","title":"Schema"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-driver/-schema/#properties","text":"Name Summary version abstract val version: Int The version of this schema.","title":"Properties"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-driver/-schema/#functions","text":"Name Summary create abstract fun create(driver: SqlDriver ): Unit Use driver to create the schema from scratch. Assumes no existing database state. migrate abstract fun migrate(driver: SqlDriver , oldVersion: Int , newVersion: Int ): Unit Use driver to migrate from schema oldVersion to newVersion .","title":"Functions"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-driver/-schema/create/","text":"sqldelight-runtime / com.squareup.sqldelight.db / SqlDriver / Schema / create create abstract fun create(driver: SqlDriver ): Unit Use driver to create the schema from scratch. Assumes no existing database state.","title":"Create"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-driver/-schema/create/#create","text":"abstract fun create(driver: SqlDriver ): Unit Use driver to create the schema from scratch. Assumes no existing database state.","title":"create"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-driver/-schema/migrate/","text":"sqldelight-runtime / com.squareup.sqldelight.db / SqlDriver / Schema / migrate migrate abstract fun migrate(driver: SqlDriver , oldVersion: Int , newVersion: Int ): Unit Use driver to migrate from schema oldVersion to newVersion .","title":"Migrate"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-driver/-schema/migrate/#migrate","text":"abstract fun migrate(driver: SqlDriver , oldVersion: Int , newVersion: Int ): Unit Use driver to migrate from schema oldVersion to newVersion .","title":"migrate"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-driver/-schema/version/","text":"sqldelight-runtime / com.squareup.sqldelight.db / SqlDriver / Schema / version version abstract val version: Int The version of this schema.","title":"Version"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-driver/-schema/version/#version","text":"abstract val version: Int The version of this schema.","title":"version"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-prepared-statement/","text":"sqldelight-runtime / com.squareup.sqldelight.db / SqlPreparedStatement SqlPreparedStatement interface SqlPreparedStatement Represents a SQL statement that has been prepared by a driver to be executed. This type is not thread safe unless otherwise specified by the driver emitting these. Prepared statements should not be cached by client code. Drivers can implement caching by using the integer identifier passed to SqlDriver.execute or SqlDriver.executeQuery . Client code can pass the same identifier to that method to request that the prepared statement is cached. Functions Name Summary bindBytes abstract fun bindBytes(index: Int , value: ByteArray ?): Unit Bind value to the underlying statement at index . bindDouble abstract fun bindDouble(index: Int , value: Double ?): Unit Bind value to the underlying statement at index . bindLong abstract fun bindLong(index: Int , value: Long ?): Unit Bind value to the underlying statement at index . bindString abstract fun bindString(index: Int , value: String ?): Unit Bind value to the underlying statement at index . Inheritors Name Summary StatementParameterInterceptor class StatementParameterInterceptor : SqlPreparedStatement","title":"Home"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-prepared-statement/#sqlpreparedstatement","text":"interface SqlPreparedStatement Represents a SQL statement that has been prepared by a driver to be executed. This type is not thread safe unless otherwise specified by the driver emitting these. Prepared statements should not be cached by client code. Drivers can implement caching by using the integer identifier passed to SqlDriver.execute or SqlDriver.executeQuery . Client code can pass the same identifier to that method to request that the prepared statement is cached.","title":"SqlPreparedStatement"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-prepared-statement/#functions","text":"Name Summary bindBytes abstract fun bindBytes(index: Int , value: ByteArray ?): Unit Bind value to the underlying statement at index . bindDouble abstract fun bindDouble(index: Int , value: Double ?): Unit Bind value to the underlying statement at index . bindLong abstract fun bindLong(index: Int , value: Long ?): Unit Bind value to the underlying statement at index . bindString abstract fun bindString(index: Int , value: String ?): Unit Bind value to the underlying statement at index .","title":"Functions"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-prepared-statement/#inheritors","text":"Name Summary StatementParameterInterceptor class StatementParameterInterceptor : SqlPreparedStatement","title":"Inheritors"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-prepared-statement/bind-bytes/","text":"sqldelight-runtime / com.squareup.sqldelight.db / SqlPreparedStatement / bindBytes bindBytes abstract fun bindBytes(index: Int , value: ByteArray ?): Unit Bind value to the underlying statement at index .","title":"Bind bytes"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-prepared-statement/bind-bytes/#bindbytes","text":"abstract fun bindBytes(index: Int , value: ByteArray ?): Unit Bind value to the underlying statement at index .","title":"bindBytes"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-prepared-statement/bind-double/","text":"sqldelight-runtime / com.squareup.sqldelight.db / SqlPreparedStatement / bindDouble bindDouble abstract fun bindDouble(index: Int , value: Double ?): Unit Bind value to the underlying statement at index .","title":"Bind double"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-prepared-statement/bind-double/#binddouble","text":"abstract fun bindDouble(index: Int , value: Double ?): Unit Bind value to the underlying statement at index .","title":"bindDouble"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-prepared-statement/bind-long/","text":"sqldelight-runtime / com.squareup.sqldelight.db / SqlPreparedStatement / bindLong bindLong abstract fun bindLong(index: Int , value: Long ?): Unit Bind value to the underlying statement at index .","title":"Bind long"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-prepared-statement/bind-long/#bindlong","text":"abstract fun bindLong(index: Int , value: Long ?): Unit Bind value to the underlying statement at index .","title":"bindLong"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-prepared-statement/bind-string/","text":"sqldelight-runtime / com.squareup.sqldelight.db / SqlPreparedStatement / bindString bindString abstract fun bindString(index: Int , value: String ?): Unit Bind value to the underlying statement at index .","title":"Bind string"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.db/-sql-prepared-statement/bind-string/#bindstring","text":"abstract fun bindString(index: Int , value: String ?): Unit Bind value to the underlying statement at index .","title":"bindString"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.logs/","text":"sqldelight-runtime / com.squareup.sqldelight.logs Package com.squareup.sqldelight.logs Types Name Summary LogSqliteDriver class LogSqliteDriver : SqlDriver StatementParameterInterceptor class StatementParameterInterceptor : SqlPreparedStatement","title":"Home"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.logs/#package-comsquareupsqldelightlogs","text":"","title":"Package com.squareup.sqldelight.logs"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.logs/#types","text":"Name Summary LogSqliteDriver class LogSqliteDriver : SqlDriver StatementParameterInterceptor class StatementParameterInterceptor : SqlPreparedStatement","title":"Types"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.logs/-log-sqlite-driver/","text":"sqldelight-runtime / com.squareup.sqldelight.logs / LogSqliteDriver LogSqliteDriver class LogSqliteDriver : SqlDriver Constructors Name Summary <init> LogSqliteDriver(sqlDriver: SqlDriver , logger: ( String ) -> Unit ) Functions Name Summary close fun close(): Unit Close any resources backed by this object. currentTransaction fun currentTransaction(): Transaction ? The currently open Transacter.Transaction on the database. execute fun execute(identifier: Int ?, sql: String , parameters: Int , binders: SqlPreparedStatement .() -> Unit ): Unit Execute a SQL statement. executeQuery fun executeQuery(identifier: Int ?, sql: String , parameters: Int , binders: SqlPreparedStatement .() -> Unit ): SqlCursor Execute a SQL statement and return a SqlCursor that iterates the result set. newTransaction fun newTransaction(): Transaction Start a new Transacter.Transaction on the database.","title":"Home"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.logs/-log-sqlite-driver/#logsqlitedriver","text":"class LogSqliteDriver : SqlDriver","title":"LogSqliteDriver"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.logs/-log-sqlite-driver/#constructors","text":"Name Summary <init> LogSqliteDriver(sqlDriver: SqlDriver , logger: ( String ) -> Unit )","title":"Constructors"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.logs/-log-sqlite-driver/#functions","text":"Name Summary close fun close(): Unit Close any resources backed by this object. currentTransaction fun currentTransaction(): Transaction ? The currently open Transacter.Transaction on the database. execute fun execute(identifier: Int ?, sql: String , parameters: Int , binders: SqlPreparedStatement .() -> Unit ): Unit Execute a SQL statement. executeQuery fun executeQuery(identifier: Int ?, sql: String , parameters: Int , binders: SqlPreparedStatement .() -> Unit ): SqlCursor Execute a SQL statement and return a SqlCursor that iterates the result set. newTransaction fun newTransaction(): Transaction Start a new Transacter.Transaction on the database.","title":"Functions"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.logs/-log-sqlite-driver/-init-/","text":"sqldelight-runtime / com.squareup.sqldelight.logs / LogSqliteDriver / <init> <init> LogSqliteDriver(sqlDriver: SqlDriver , logger: ( String ) -> Unit )","title":" init "},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.logs/-log-sqlite-driver/-init-/#init","text":"LogSqliteDriver(sqlDriver: SqlDriver , logger: ( String ) -> Unit )","title":"&lt;init&gt;"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.logs/-log-sqlite-driver/close/","text":"sqldelight-runtime / com.squareup.sqldelight.logs / LogSqliteDriver / close close fun close(): Unit Overrides Closeable.close Close any resources backed by this object.","title":"Close"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.logs/-log-sqlite-driver/close/#close","text":"fun close(): Unit Overrides Closeable.close Close any resources backed by this object.","title":"close"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.logs/-log-sqlite-driver/current-transaction/","text":"sqldelight-runtime / com.squareup.sqldelight.logs / LogSqliteDriver / currentTransaction currentTransaction fun currentTransaction(): Transaction ? Overrides SqlDriver.currentTransaction The currently open Transacter.Transaction on the database. It's up to the implementor how this method behaves for different connection/threading patterns.","title":"Current transaction"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.logs/-log-sqlite-driver/current-transaction/#currenttransaction","text":"fun currentTransaction(): Transaction ? Overrides SqlDriver.currentTransaction The currently open Transacter.Transaction on the database. It's up to the implementor how this method behaves for different connection/threading patterns.","title":"currentTransaction"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.logs/-log-sqlite-driver/execute-query/","text":"sqldelight-runtime / com.squareup.sqldelight.logs / LogSqliteDriver / executeQuery executeQuery fun executeQuery(identifier: Int ?, sql: String , parameters: Int , binders: SqlPreparedStatement .() -> Unit ): SqlCursor Overrides SqlDriver.executeQuery Execute a SQL statement and return a SqlCursor that iterates the result set. Parameters identifier - An opaque, unique value that can be used to implement any driver-side caching of prepared statements. If identifier is null, a fresh statement is required. sql - The SQL string to be executed. parameters - The number of bindable parameters sql contains. binders - A lambda which is called before execution to bind any parameters to the SQL statement.","title":"Execute query"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.logs/-log-sqlite-driver/execute-query/#executequery","text":"fun executeQuery(identifier: Int ?, sql: String , parameters: Int , binders: SqlPreparedStatement .() -> Unit ): SqlCursor Overrides SqlDriver.executeQuery Execute a SQL statement and return a SqlCursor that iterates the result set.","title":"executeQuery"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.logs/-log-sqlite-driver/execute-query/#parameters","text":"identifier - An opaque, unique value that can be used to implement any driver-side caching of prepared statements. If identifier is null, a fresh statement is required. sql - The SQL string to be executed. parameters - The number of bindable parameters sql contains. binders - A lambda which is called before execution to bind any parameters to the SQL statement.","title":"Parameters"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.logs/-log-sqlite-driver/execute/","text":"sqldelight-runtime / com.squareup.sqldelight.logs / LogSqliteDriver / execute execute fun execute(identifier: Int ?, sql: String , parameters: Int , binders: SqlPreparedStatement .() -> Unit ): Unit Overrides SqlDriver.execute Execute a SQL statement. Parameters identifier - An opaque, unique value that can be used to implement any driver-side caching of prepared statements. If identifier is null, a fresh statement is required. sql - The SQL string to be executed. parameters - The number of bindable parameters sql contains. binders - A lambda which is called before execution to bind any parameters to the SQL statement.","title":"Execute"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.logs/-log-sqlite-driver/execute/#execute","text":"fun execute(identifier: Int ?, sql: String , parameters: Int , binders: SqlPreparedStatement .() -> Unit ): Unit Overrides SqlDriver.execute Execute a SQL statement.","title":"execute"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.logs/-log-sqlite-driver/execute/#parameters","text":"identifier - An opaque, unique value that can be used to implement any driver-side caching of prepared statements. If identifier is null, a fresh statement is required. sql - The SQL string to be executed. parameters - The number of bindable parameters sql contains. binders - A lambda which is called before execution to bind any parameters to the SQL statement.","title":"Parameters"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.logs/-log-sqlite-driver/new-transaction/","text":"sqldelight-runtime / com.squareup.sqldelight.logs / LogSqliteDriver / newTransaction newTransaction fun newTransaction(): Transaction Overrides SqlDriver.newTransaction Start a new Transacter.Transaction on the database. It's up to the implementor how this method behaves for different connection/threading patterns.","title":"New transaction"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.logs/-log-sqlite-driver/new-transaction/#newtransaction","text":"fun newTransaction(): Transaction Overrides SqlDriver.newTransaction Start a new Transacter.Transaction on the database. It's up to the implementor how this method behaves for different connection/threading patterns.","title":"newTransaction"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.logs/-statement-parameter-interceptor/","text":"sqldelight-runtime / com.squareup.sqldelight.logs / StatementParameterInterceptor StatementParameterInterceptor class StatementParameterInterceptor : SqlPreparedStatement Constructors Name Summary <init> StatementParameterInterceptor() Functions Name Summary bindBytes fun bindBytes(index: Int , value: ByteArray ?): Unit Bind value to the underlying statement at index . bindDouble fun bindDouble(index: Int , value: Double ?): Unit Bind value to the underlying statement at index . bindLong fun bindLong(index: Int , value: Long ?): Unit Bind value to the underlying statement at index . bindString fun bindString(index: Int , value: String ?): Unit Bind value to the underlying statement at index . getAndClearParameters fun getAndClearParameters(): List < Any ?>","title":"Home"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.logs/-statement-parameter-interceptor/#statementparameterinterceptor","text":"class StatementParameterInterceptor : SqlPreparedStatement","title":"StatementParameterInterceptor"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.logs/-statement-parameter-interceptor/#constructors","text":"Name Summary <init> StatementParameterInterceptor()","title":"Constructors"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.logs/-statement-parameter-interceptor/#functions","text":"Name Summary bindBytes fun bindBytes(index: Int , value: ByteArray ?): Unit Bind value to the underlying statement at index . bindDouble fun bindDouble(index: Int , value: Double ?): Unit Bind value to the underlying statement at index . bindLong fun bindLong(index: Int , value: Long ?): Unit Bind value to the underlying statement at index . bindString fun bindString(index: Int , value: String ?): Unit Bind value to the underlying statement at index . getAndClearParameters fun getAndClearParameters(): List < Any ?>","title":"Functions"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.logs/-statement-parameter-interceptor/-init-/","text":"sqldelight-runtime / com.squareup.sqldelight.logs / StatementParameterInterceptor / <init> <init> StatementParameterInterceptor()","title":" init "},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.logs/-statement-parameter-interceptor/-init-/#init","text":"StatementParameterInterceptor()","title":"&lt;init&gt;"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.logs/-statement-parameter-interceptor/bind-bytes/","text":"sqldelight-runtime / com.squareup.sqldelight.logs / StatementParameterInterceptor / bindBytes bindBytes fun bindBytes(index: Int , value: ByteArray ?): Unit Overrides SqlPreparedStatement.bindBytes Bind value to the underlying statement at index .","title":"Bind bytes"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.logs/-statement-parameter-interceptor/bind-bytes/#bindbytes","text":"fun bindBytes(index: Int , value: ByteArray ?): Unit Overrides SqlPreparedStatement.bindBytes Bind value to the underlying statement at index .","title":"bindBytes"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.logs/-statement-parameter-interceptor/bind-double/","text":"sqldelight-runtime / com.squareup.sqldelight.logs / StatementParameterInterceptor / bindDouble bindDouble fun bindDouble(index: Int , value: Double ?): Unit Overrides SqlPreparedStatement.bindDouble Bind value to the underlying statement at index .","title":"Bind double"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.logs/-statement-parameter-interceptor/bind-double/#binddouble","text":"fun bindDouble(index: Int , value: Double ?): Unit Overrides SqlPreparedStatement.bindDouble Bind value to the underlying statement at index .","title":"bindDouble"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.logs/-statement-parameter-interceptor/bind-long/","text":"sqldelight-runtime / com.squareup.sqldelight.logs / StatementParameterInterceptor / bindLong bindLong fun bindLong(index: Int , value: Long ?): Unit Overrides SqlPreparedStatement.bindLong Bind value to the underlying statement at index .","title":"Bind long"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.logs/-statement-parameter-interceptor/bind-long/#bindlong","text":"fun bindLong(index: Int , value: Long ?): Unit Overrides SqlPreparedStatement.bindLong Bind value to the underlying statement at index .","title":"bindLong"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.logs/-statement-parameter-interceptor/bind-string/","text":"sqldelight-runtime / com.squareup.sqldelight.logs / StatementParameterInterceptor / bindString bindString fun bindString(index: Int , value: String ?): Unit Overrides SqlPreparedStatement.bindString Bind value to the underlying statement at index .","title":"Bind string"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.logs/-statement-parameter-interceptor/bind-string/#bindstring","text":"fun bindString(index: Int , value: String ?): Unit Overrides SqlPreparedStatement.bindString Bind value to the underlying statement at index .","title":"bindString"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.logs/-statement-parameter-interceptor/get-and-clear-parameters/","text":"sqldelight-runtime / com.squareup.sqldelight.logs / StatementParameterInterceptor / getAndClearParameters getAndClearParameters fun getAndClearParameters(): List < Any ?>","title":"Get and clear parameters"},{"location":"1.x/sqldelight-runtime/com.squareup.sqldelight.logs/-statement-parameter-interceptor/get-and-clear-parameters/#getandclearparameters","text":"fun getAndClearParameters(): List < Any ?>","title":"getAndClearParameters"},{"location":"android_sqlite/","text":"Getting Started on Android First apply the gradle plugin in your project. buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.3.0' } } apply plugin: 'com.squareup.sqldelight' Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: dependencies { implementation \"com.squareup.sqldelight:android-driver:1.3.0\" } val driver : SqlDriver = AndroidSqliteDriver ( Database . Schema , context , \"test.db\" ) SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Getting Started"},{"location":"android_sqlite/#getting-started-on-android","text":"First apply the gradle plugin in your project. buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.3.0' } } apply plugin: 'com.squareup.sqldelight' Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: dependencies { implementation \"com.squareup.sqldelight:android-driver:1.3.0\" } val driver : SqlDriver = AndroidSqliteDriver ( Database . Schema , context , \"test.db\" ) SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Getting Started on Android"},{"location":"android_sqlite/android_paging/","text":"Android Paging To use SQLDelight with Android's Paging Library add a dependency on the paging extension artifact. dependencies { implementation \"com.squareup.sqldelight:android-paging-extensions:1.2.1\" } To create a DataSource write a query to get the number of rows and a query that takes an offset and a limit. countPlayers : SELECT count ( * ) FROM hockeyPlayer ; players : SELECT * FROM hockeyPlayer LIMIT : limit OFFSET : offset ; val dataSource = QueryDataSourceFactory ( queryProvider = playerQueries :: players , countQuery = playerQueries . countPlayers (), transacter = playerQueries ). create ()","title":"Android Paging"},{"location":"android_sqlite/android_paging/#android-paging","text":"To use SQLDelight with Android's Paging Library add a dependency on the paging extension artifact. dependencies { implementation \"com.squareup.sqldelight:android-paging-extensions:1.2.1\" } To create a DataSource write a query to get the number of rows and a query that takes an offset and a limit. countPlayers : SELECT count ( * ) FROM hockeyPlayer ; players : SELECT * FROM hockeyPlayer LIMIT : limit OFFSET : offset ; val dataSource = QueryDataSourceFactory ( queryProvider = playerQueries :: players , countQuery = playerQueries . countPlayers (), transacter = playerQueries ). create ()","title":"Android Paging"},{"location":"android_sqlite/coroutines/","text":"Flow To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides: dependencies { implementation \"com.squareup.sqldelight:coroutines-extensions:1.2.1\" } val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Coroutines"},{"location":"android_sqlite/coroutines/#flow","text":"To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides: dependencies { implementation \"com.squareup.sqldelight:coroutines-extensions:1.2.1\" } val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Flow"},{"location":"android_sqlite/custom_projections/","text":"Projections By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"android_sqlite/custom_projections/#projections","text":"By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"android_sqlite/gradle/","text":"Gradle For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // The dialect version you would like to target // Defaults to \"sqlite:3.18\" dialect = \"sqlite:3.24\" } } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) dialect = \"sqlite:3.24\" } }","title":"Gradle"},{"location":"android_sqlite/gradle/#gradle","text":"For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // The dialect version you would like to target // Defaults to \"sqlite:3.18\" dialect = \"sqlite:3.24\" } } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) dialect = \"sqlite:3.24\" } }","title":"Gradle"},{"location":"android_sqlite/intellij_plugin/","text":"IntelliJ Plugin The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight","title":"IntelliJ Plugin"},{"location":"android_sqlite/intellij_plugin/#intellij-plugin","text":"The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight","title":"IntelliJ Plugin"},{"location":"android_sqlite/migrations/","text":"Migrations The .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. Versioning The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; These SQL statements are run by Database.Schema.migrate() . Verifying Migrations You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task, which is available once you specify a schemaOutputDirectory , as described in the gradle.md . You should probably do this before you create your first migration.","title":"Migrations"},{"location":"android_sqlite/migrations/#migrations","text":"The .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date.","title":"Migrations"},{"location":"android_sqlite/migrations/#versioning","text":"The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; These SQL statements are run by Database.Schema.migrate() .","title":"Versioning"},{"location":"android_sqlite/migrations/#verifying-migrations","text":"You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task, which is available once you specify a schemaOutputDirectory , as described in the gradle.md . You should probably do this before you create your first migration.","title":"Verifying Migrations"},{"location":"android_sqlite/query_arguments/","text":"Bind Args .sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments. Type Inference SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Named Arguments Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" ) Variable Arguments Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" )) Inserts INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Arguments"},{"location":"android_sqlite/query_arguments/#bind-args","text":".sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments.","title":"Bind Args"},{"location":"android_sqlite/query_arguments/#type-inference","text":"SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\"","title":"Type Inference"},{"location":"android_sqlite/query_arguments/#named-arguments","text":"Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Named Arguments"},{"location":"android_sqlite/query_arguments/#variable-arguments","text":"Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" ))","title":"Variable Arguments"},{"location":"android_sqlite/query_arguments/#inserts","text":"INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Inserts"},{"location":"android_sqlite/resources/","text":"Other Resources Guides SQLDelight 1.x Quickstart Guide for Android","title":"Resources"},{"location":"android_sqlite/resources/#other-resources","text":"","title":"Other Resources"},{"location":"android_sqlite/resources/#guides","text":"SQLDelight 1.x Quickstart Guide for Android","title":"Guides"},{"location":"android_sqlite/rxjava/","text":"RxJava To observe a query, depend on the RxJava extensions artifact and use the extension method it provides: dependencies { implementation \"com.squareup.sqldelight:rxjava3-extensions:1.3.0\" } val players : Observable < List < HockeyPlayer >> = playerQueries . selectAll () . asObservable () . mapToList () Note: For RxJava 2, use rxjava2-extensions as the artifact name.","title":"RxJava"},{"location":"android_sqlite/rxjava/#rxjava","text":"To observe a query, depend on the RxJava extensions artifact and use the extension method it provides: dependencies { implementation \"com.squareup.sqldelight:rxjava3-extensions:1.3.0\" } val players : Observable < List < HockeyPlayer >> = playerQueries . selectAll () . asObservable () . mapToList () Note: For RxJava 2, use rxjava2-extensions as the artifact name.","title":"RxJava"},{"location":"android_sqlite/transactions/","text":"API If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithReturn function. val players = database . playerQueries . transactionWithReturn { database . playerQueries . selectAll (). executeAsList () } Rollback Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted = database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size } Callbacks You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \"${players.size} players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"android_sqlite/transactions/#api","text":"If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithReturn function. val players = database . playerQueries . transactionWithReturn { database . playerQueries . selectAll (). executeAsList () }","title":"API"},{"location":"android_sqlite/transactions/#rollback","text":"Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted = database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size }","title":"Rollback"},{"location":"android_sqlite/transactions/#callbacks","text":"You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \"${players.size} players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Callbacks"},{"location":"android_sqlite/types/","text":"SQLite Types SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. SQLDelight natively supports Long, Double, String, ByteArray, Int, Short, Float, and Booleans. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray some_int INTEGER AS Int , -- Stored as INTEGER in db, retrieved as Int some_short INTEGER AS Short , -- Stored as INTEGER in db, retrieved as Short some_float REAL AS Float -- Stored as REAL in db, retrieved as Float ); Boolean columns are stored in the db as INTEGER , and so they can be given INTEGER column constraints. Use DEFAULT 0 to default to false, for example. CREATE TABLE hockey_player ( injured INTEGER AS Boolean DEFAULT 0 ) Custom Column Types If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) ) Enums As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Types"},{"location":"android_sqlite/types/#sqlite-types","text":"SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. SQLDelight natively supports Long, Double, String, ByteArray, Int, Short, Float, and Booleans. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray some_int INTEGER AS Int , -- Stored as INTEGER in db, retrieved as Int some_short INTEGER AS Short , -- Stored as INTEGER in db, retrieved as Short some_float REAL AS Float -- Stored as REAL in db, retrieved as Float ); Boolean columns are stored in the db as INTEGER , and so they can be given INTEGER column constraints. Use DEFAULT 0 to default to false, for example. CREATE TABLE hockey_player ( injured INTEGER AS Boolean DEFAULT 0 )","title":"SQLite Types"},{"location":"android_sqlite/types/#custom-column-types","text":"If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) )","title":"Custom Column Types"},{"location":"android_sqlite/types/#enums","text":"As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Enums"},{"location":"android_sqlite/upgrading/","text":"Upgrading from Versions before 1.0 If you're still on SQLDelight 0.6 doing the upgrade to 0.7 first so you stay on the SupportSQLite artifact will likely be easiest Upgrade the gradle plugin from 0.7 to 0.7.1. This will upgrade the arch.persistence.db dependency to 1.1.1, but should have no effect on your usage of sqldelight. Upgrade the gradle plugin from 0.7.1 to 0.7.2. This changes the runtime package from com.squareup.sqldelight to com.squareup.sqldelight.prerelease , so you will need to change references in your own code. Upgrade the gradle plugin from 0.7.2 to 0.9.0. This upgrades the transitive dependencies and generated code to instead use AndroidX, which is a requirement of SQLDelight. This should be done at the same time as you upgrading your own project to AndroidX, and cannot be done separately since SQLDelight generates code which references android support/AndroidX. ALTERNATIVELY Upgrade the gradle plugin from 0.7 to 0.8.0 before then upgrading to 0.9.0. This upgrades to AndroidX without changing the sqldelight package name to com.squareup.sqldelight.prerelease Suppose on SQLDelight 0.9 you have this User.sq file: CREATE TABLE user ( id INTEGER NOT NULL PRIMARY KEY , name TEXT NOT NULL ); insertDefaultData : INSERT INTO user VALUES ( 1 , 'Alec' ); users : SELECT * FROM user ; names : SELECT name FROM user ; insertUser : INSERT INTO user VALUES ( ? , ? ); This will generate the UserModel class with methods for your queries. Copy and paste all *Model.java files out of the build directory and into your src/main/java folder. Upgrade the gradle plugin from 0.9 to 1.0.0-rc4. Note your build will fail at this point because of the model code having undefined references to the old SQL Delight runtime (like SqlDelightStatement ). To add these back in add an implementation dependency on com.squareup.sqldelight:runtime:0.9.0 . At this point your build should still be working, but changes to .sq files will not be reflected in your *Model.java files. If things aren't working at this point, please file an issue! Begin by modifying your SupportSQLiteOpenHelper.Callback to call into the now generated Database which holds generated code for SQL Delight 1.0: //Before @Override void onCreate ( SupportSQLiteDatabase db ) { db . execSql ( UserModel . CREATE_TABLE ); db . execSql ( UserModel . INSERTDEFAULTDATA ); // Other create table/initialization } In SQL Delight 1.0 all unlabeled statements in .sq files (including CREATE statements) will be run during onCreate , so we can remove the insertDefaultData identifier from above: User.sq ... --insertDefaultData: INSERT INTO user VALUES ( 1 , 'Alec' ); ... and now your SupportSQLiteOpenHelper.Callback should call into the Database for create @Override void onCreate ( SupportSQLiteDatabase db ) { SqlDriver driver = AndroidSqliteDriver ( db ) Database . Schema . create ( driver ) } You can do the same for your migrations if you place them in .sqm files, but thats not necessary part of the upgrade. At this point things should still work normally. Next add in the code to create your Database as part of an object graph/singleton pattern/whevs: @Provides @Singleton static SupportSQLiteOpenHelper provideDatabaseHelper ( @App Context context ) { SupportSQLiteOpenHelper . Configuration config = SupportSQLiteOpenHelper . Configuration . builder ( context ) . name ( DATABASE_NAME ) . callback ( new MyDatabaseCallback ()) . build (); return new FrameworkSQLiteOpenHelperFactory (). create ( config ); } @Provides @Singleton static Database provideDatabase ( SupportSQLiteOpenHelper helper ) { return new Database ( new AndroidSqliteDriver ( helper )); } If you're also using SQL Brite make sure you create a BriteDatabase with the same SupportSQLiteOpenHelper that's being used to create the Database . Things should still be working. The following assume you're using SQL Brite to get reactive callbacks from the database, but upgrades using only SQL Delight will be similar. Mutating queries can be converted individually by using the Database : before: private val insertUser : UserModel . InsertUser by lazy { UserModel . InsertUser ( datbaseOpenHelper . writableDatabase ) } insertUser . bind ( 2 , \"Jake\" ) insertUser . executeInsert () after: database . userQueries . insertUser ( 2 , \"Jake\" ) You no longer need a \"Factory\" type to perform queries, the query wrapper is all that is needed. before: val query = User . FACTORY . users () val usersObservable = briteDatabase . createQuery ( query . tables , query . statement , query . args ) . mapToList ( User . FACTORY . usersMapper () :: map ) after: val usersObservable = database . userQueries . users () . asObservable ( Schedulers . io ()) // The scheduler to run the query on. . mapToList () If you still want to use a custom type, pass it as a parameter to the query. val myUsersObservable = database . userQueries . users ( :: MyUser ) . asObservable ( Schedulers . io ()) . mapToList () Once you no longer have references to UserModel.java , delete the whole class. Repeat for each of your *Model.java files until upgrading is complete!","title":"Upgrading Pre-1.0"},{"location":"android_sqlite/upgrading/#upgrading-from-versions-before-10","text":"If you're still on SQLDelight 0.6 doing the upgrade to 0.7 first so you stay on the SupportSQLite artifact will likely be easiest Upgrade the gradle plugin from 0.7 to 0.7.1. This will upgrade the arch.persistence.db dependency to 1.1.1, but should have no effect on your usage of sqldelight. Upgrade the gradle plugin from 0.7.1 to 0.7.2. This changes the runtime package from com.squareup.sqldelight to com.squareup.sqldelight.prerelease , so you will need to change references in your own code. Upgrade the gradle plugin from 0.7.2 to 0.9.0. This upgrades the transitive dependencies and generated code to instead use AndroidX, which is a requirement of SQLDelight. This should be done at the same time as you upgrading your own project to AndroidX, and cannot be done separately since SQLDelight generates code which references android support/AndroidX. ALTERNATIVELY Upgrade the gradle plugin from 0.7 to 0.8.0 before then upgrading to 0.9.0. This upgrades to AndroidX without changing the sqldelight package name to com.squareup.sqldelight.prerelease Suppose on SQLDelight 0.9 you have this User.sq file: CREATE TABLE user ( id INTEGER NOT NULL PRIMARY KEY , name TEXT NOT NULL ); insertDefaultData : INSERT INTO user VALUES ( 1 , 'Alec' ); users : SELECT * FROM user ; names : SELECT name FROM user ; insertUser : INSERT INTO user VALUES ( ? , ? ); This will generate the UserModel class with methods for your queries. Copy and paste all *Model.java files out of the build directory and into your src/main/java folder. Upgrade the gradle plugin from 0.9 to 1.0.0-rc4. Note your build will fail at this point because of the model code having undefined references to the old SQL Delight runtime (like SqlDelightStatement ). To add these back in add an implementation dependency on com.squareup.sqldelight:runtime:0.9.0 . At this point your build should still be working, but changes to .sq files will not be reflected in your *Model.java files. If things aren't working at this point, please file an issue! Begin by modifying your SupportSQLiteOpenHelper.Callback to call into the now generated Database which holds generated code for SQL Delight 1.0: //Before @Override void onCreate ( SupportSQLiteDatabase db ) { db . execSql ( UserModel . CREATE_TABLE ); db . execSql ( UserModel . INSERTDEFAULTDATA ); // Other create table/initialization } In SQL Delight 1.0 all unlabeled statements in .sq files (including CREATE statements) will be run during onCreate , so we can remove the insertDefaultData identifier from above: User.sq ... --insertDefaultData: INSERT INTO user VALUES ( 1 , 'Alec' ); ... and now your SupportSQLiteOpenHelper.Callback should call into the Database for create @Override void onCreate ( SupportSQLiteDatabase db ) { SqlDriver driver = AndroidSqliteDriver ( db ) Database . Schema . create ( driver ) } You can do the same for your migrations if you place them in .sqm files, but thats not necessary part of the upgrade. At this point things should still work normally. Next add in the code to create your Database as part of an object graph/singleton pattern/whevs: @Provides @Singleton static SupportSQLiteOpenHelper provideDatabaseHelper ( @App Context context ) { SupportSQLiteOpenHelper . Configuration config = SupportSQLiteOpenHelper . Configuration . builder ( context ) . name ( DATABASE_NAME ) . callback ( new MyDatabaseCallback ()) . build (); return new FrameworkSQLiteOpenHelperFactory (). create ( config ); } @Provides @Singleton static Database provideDatabase ( SupportSQLiteOpenHelper helper ) { return new Database ( new AndroidSqliteDriver ( helper )); } If you're also using SQL Brite make sure you create a BriteDatabase with the same SupportSQLiteOpenHelper that's being used to create the Database . Things should still be working. The following assume you're using SQL Brite to get reactive callbacks from the database, but upgrades using only SQL Delight will be similar. Mutating queries can be converted individually by using the Database : before: private val insertUser : UserModel . InsertUser by lazy { UserModel . InsertUser ( datbaseOpenHelper . writableDatabase ) } insertUser . bind ( 2 , \"Jake\" ) insertUser . executeInsert () after: database . userQueries . insertUser ( 2 , \"Jake\" ) You no longer need a \"Factory\" type to perform queries, the query wrapper is all that is needed. before: val query = User . FACTORY . users () val usersObservable = briteDatabase . createQuery ( query . tables , query . statement , query . args ) . mapToList ( User . FACTORY . usersMapper () :: map ) after: val usersObservable = database . userQueries . users () . asObservable ( Schedulers . io ()) // The scheduler to run the query on. . mapToList () If you still want to use a custom type, pass it as a parameter to the query. val myUsersObservable = database . userQueries . users ( :: MyUser ) . asObservable ( Schedulers . io ()) . mapToList () Once you no longer have references to UserModel.java , delete the whole class. Repeat for each of your *Model.java files until upgrading is complete!","title":"Upgrading from Versions before 1.0"},{"location":"common/coroutines-multiplatform/","text":"Flow To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides: kotlin { sourceSets . commonMain . dependencies { implementation \"com.squareup.sqldelight:coroutines-extensions:1.2.1\" } } val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Coroutines multiplatform"},{"location":"common/coroutines-multiplatform/#flow","text":"To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides: kotlin { sourceSets . commonMain . dependencies { implementation \"com.squareup.sqldelight:coroutines-extensions:1.2.1\" } } val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Flow"},{"location":"common/coroutines-usage/","text":"val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Coroutines usage"},{"location":"common/coroutines/","text":"Flow To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides: dependencies { implementation \"com.squareup.sqldelight:coroutines-extensions:1.2.1\" } val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Coroutines"},{"location":"common/coroutines/#flow","text":"To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides: dependencies { implementation \"com.squareup.sqldelight:coroutines-extensions:1.2.1\" } val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Flow"},{"location":"common/custom_column_types/","text":"Custom Column Types If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) ) Enums As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Custom column types"},{"location":"common/custom_column_types/#custom-column-types","text":"If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) )","title":"Custom Column Types"},{"location":"common/custom_column_types/#enums","text":"As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Enums"},{"location":"common/custom_projections/","text":"Projections By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"common/custom_projections/#projections","text":"By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"common/gradle-common-groovy-properties/","text":"// Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [\"db\"] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file(\"src/main/sqldelight/databases\") // Optionally specify schema dependencies on other gradle projects dependency project(':OtherProject') // The dialect version you would like to target // Defaults to \"sqlite:3.18\" dialect = \"sqlite:3.24\"","title":"Gradle common groovy properties"},{"location":"common/gradle-common-kotlin-properties/","text":"packageName = \"com.example.db\" sourceFolders = listOf(\"db\") schemaOutputDirectory = file(\"build/dbs\") dependency(project(\":OtherProject\")) dialect = \"sqlite:3.24\"","title":"Gradle common kotlin properties"},{"location":"common/gradle-multiplatform/","text":"Gradle For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // The dialect version you would like to target // Defaults to \"sqlite:3.18\" dialect = \"sqlite:3.24\" } // For native targets, whether sqlite should be automatically linked. // Defaults to true. linkSqlite = false } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) dialect = \"sqlite:3.24\" } linkSqlite = false }","title":"Gradle"},{"location":"common/gradle-multiplatform/#gradle","text":"For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // The dialect version you would like to target // Defaults to \"sqlite:3.18\" dialect = \"sqlite:3.24\" } // For native targets, whether sqlite should be automatically linked. // Defaults to true. linkSqlite = false } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) dialect = \"sqlite:3.24\" } linkSqlite = false }","title":"Gradle"},{"location":"common/gradle/","text":"Gradle For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // The dialect version you would like to target // Defaults to \"sqlite:3.18\" dialect = \"sqlite:3.24\" } } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) dialect = \"sqlite:3.24\" } }","title":"Gradle"},{"location":"common/gradle/#gradle","text":"For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // The dialect version you would like to target // Defaults to \"sqlite:3.18\" dialect = \"sqlite:3.24\" } } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) dialect = \"sqlite:3.24\" } }","title":"Gradle"},{"location":"common/gradle_server/","text":"Gradle build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"sqldelight\" , \"resources\" ] // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // Wether or not to use .sqm files as the source of truth for the schema. // Defaults to false deriveSchemaFromMigrations = true // If set, configures a task to output the .sqm migration files as valid SQL // Defaults to null migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) // The extension format to use for generated valid SQL migrations. // Defaults to \".sql\" migrationOutputFileFormat = \".sql\" } } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = [ \"sqldelight\" , \"resources\" ] dependency project ( ' : OtherProject ' ) deriveSchemaFromMigrations = true migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" } }","title":"Gradle"},{"location":"common/gradle_server/#gradle","text":"build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"sqldelight\" , \"resources\" ] // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // Wether or not to use .sqm files as the source of truth for the schema. // Defaults to false deriveSchemaFromMigrations = true // If set, configures a task to output the .sqm migration files as valid SQL // Defaults to null migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) // The extension format to use for generated valid SQL migrations. // Defaults to \".sql\" migrationOutputFileFormat = \".sql\" } } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = [ \"sqldelight\" , \"resources\" ] dependency project ( ' : OtherProject ' ) deriveSchemaFromMigrations = true migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" } }","title":"Gradle"},{"location":"common/index_gradle_database/","text":"First apply the gradle plugin in your project. buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.3.0' } } apply plugin: 'com.squareup.sqldelight' sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" } }","title":"Index gradle database"},{"location":"common/index_gradle_database_post_dialect/","text":"} } ```","title":"Index gradle database post dialect"},{"location":"common/index_gradle_database_pre_dialect/","text":"First apply the gradle plugin in your project. ```groovy buildscript { repositories { google() mavenCentral() } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.3.0' } } apply plugin: 'com.squareup.sqldelight' sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\"","title":"Index gradle database pre dialect"},{"location":"common/index_queries/","text":"SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Index queries"},{"location":"common/index_schema/","text":"Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of:","title":"Index schema"},{"location":"common/index_schema_sq/","text":"Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' );","title":"Index schema sq"},{"location":"common/index_server/","text":"SQLDelight needs to know the schema of your database. If you always create your schema fresh with create table statements, you'll want to put those statements in .sq files, as shown here . If you apply migration files to an already running database, you'll want to rename your migration files to .sqm files, as shown here Fresh Schema Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); In the same .sq files you can start placing your sql statements to be executed at runtime . Migration Schema First, configure gradle to use migrations to assemble the schema: sqldelight { Database { ... sourceFolders = [ \"sqldelight\" ] deriveSchemaFromMigrations = true } } Migration files have the extension .sqm , and must have a number in their file name indicating what order the migration file runs in. For example, given this hierarchy: src --main ----sqldelight ------v1__backend.sqm ------v2__backend.sqm SQLDelight will create the schema by applying v1__backend.sqm and then v2__backend.sqm . Place your normal SQL CREATE / ALTER statements in these files. If another service reads from your migrations files (like flyway), make sure to read the info on migrations and how to output valid SQL. Typesafe SQL Before you're able to execute SQL statements at runtime, you need to create a SqlDriver to connect to your database. The easiest way is off of a DataSource that you would get from hikari or other connection managers. dependencies { implementation \"com.squareup.sqldelight:jdbc-driver:\" } val driver : SqlDriver = dataSource . asJdbcDriver () Regardless of if you specify the schema as fresh create table statements or through migrations, runtime SQL goes in .sq files. SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Index server"},{"location":"common/index_server/#fresh-schema","text":"Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); In the same .sq files you can start placing your sql statements to be executed at runtime .","title":"Fresh Schema"},{"location":"common/index_server/#migration-schema","text":"First, configure gradle to use migrations to assemble the schema: sqldelight { Database { ... sourceFolders = [ \"sqldelight\" ] deriveSchemaFromMigrations = true } } Migration files have the extension .sqm , and must have a number in their file name indicating what order the migration file runs in. For example, given this hierarchy: src --main ----sqldelight ------v1__backend.sqm ------v2__backend.sqm SQLDelight will create the schema by applying v1__backend.sqm and then v2__backend.sqm . Place your normal SQL CREATE / ALTER statements in these files. If another service reads from your migrations files (like flyway), make sure to read the info on migrations and how to output valid SQL.","title":"Migration Schema"},{"location":"common/index_server/#typesafe-sql","text":"Before you're able to execute SQL statements at runtime, you need to create a SqlDriver to connect to your database. The easiest way is off of a DataSource that you would get from hikari or other connection managers. dependencies { implementation \"com.squareup.sqldelight:jdbc-driver:\" } val driver : SqlDriver = dataSource . asJdbcDriver () Regardless of if you specify the schema as fresh create table statements or through migrations, runtime SQL goes in .sq files. SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Typesafe SQL"},{"location":"common/intellij_plugin/","text":"IntelliJ Plugin The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight","title":"IntelliJ Plugin"},{"location":"common/intellij_plugin/#intellij-plugin","text":"The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight","title":"IntelliJ Plugin"},{"location":"common/migrations/","text":"Migrations The .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. Versioning The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; These SQL statements are run by Database.Schema.migrate() . Verifying Migrations You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task, which is available once you specify a schemaOutputDirectory , as described in the gradle.md . You should probably do this before you create your first migration.","title":"Migrations"},{"location":"common/migrations/#migrations","text":"The .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date.","title":"Migrations"},{"location":"common/migrations/#versioning","text":"The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; These SQL statements are run by Database.Schema.migrate() .","title":"Versioning"},{"location":"common/migrations/#verifying-migrations","text":"You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task, which is available once you specify a schemaOutputDirectory , as described in the gradle.md . You should probably do this before you create your first migration.","title":"Verifying Migrations"},{"location":"common/migrations_server/","text":"Valid SQL migrations Using custom kotlin types in migration files means those files are no longer valid SQL. You can optionally configure a gradle task to output your migration files as valid SQL for other services to read from: sqldelight { Database { migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" // Defaults to .sql } } This creates a new task generateMainDatabaseMigrations which will output your .sqm files as valid SQL in the output directory, with the output format. Create a dependency from your compileKotlin task so that services such as flyway will have the files available on their classpath: compileKotlin . configure { dependsOn \"generateMainDatabaseMigrations\" }","title":"Migrations server"},{"location":"common/migrations_server/#valid-sql-migrations","text":"Using custom kotlin types in migration files means those files are no longer valid SQL. You can optionally configure a gradle task to output your migration files as valid SQL for other services to read from: sqldelight { Database { migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" // Defaults to .sql } } This creates a new task generateMainDatabaseMigrations which will output your .sqm files as valid SQL in the output directory, with the output format. Create a dependency from your compileKotlin task so that services such as flyway will have the files available on their classpath: compileKotlin . configure { dependsOn \"generateMainDatabaseMigrations\" }","title":"Valid SQL migrations"},{"location":"common/multiplatform/","text":"Multiplatform To use SQLDelight in Kotlin multiplatform configure the Gradle plugin with a package to generate code into. apply plugin: \"org.jetbrains.kotlin.multiplatform\" apply plugin: \"com.squareup.sqldelight\" sqldelight { MyDatabase { packageName = \"com.example.hockey\" } } Put .sq files in the src/commonMain/sqldelight directory, and then expect a SqlDriver to be provided by individual platforms when creating the Database . Migration files should also be in the same src/commonMain/sqldelight directory. Multiplatform requires the gradle metadata feature , which you need to enable via the settings.gradle file in the project root: enableFeaturePreview ( 'GRADLE_METADATA' )","title":"Multiplatform"},{"location":"common/multiplatform/#multiplatform","text":"To use SQLDelight in Kotlin multiplatform configure the Gradle plugin with a package to generate code into. apply plugin: \"org.jetbrains.kotlin.multiplatform\" apply plugin: \"com.squareup.sqldelight\" sqldelight { MyDatabase { packageName = \"com.example.hockey\" } } Put .sq files in the src/commonMain/sqldelight directory, and then expect a SqlDriver to be provided by individual platforms when creating the Database . Migration files should also be in the same src/commonMain/sqldelight directory. Multiplatform requires the gradle metadata feature , which you need to enable via the settings.gradle file in the project root: enableFeaturePreview ( 'GRADLE_METADATA' )","title":"Multiplatform"},{"location":"common/query_arguments/","text":"Type Inference SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Named Arguments Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" ) Variable Arguments Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" )) Inserts INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Query arguments"},{"location":"common/query_arguments/#type-inference","text":"SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\"","title":"Type Inference"},{"location":"common/query_arguments/#named-arguments","text":"Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Named Arguments"},{"location":"common/query_arguments/#variable-arguments","text":"Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" ))","title":"Variable Arguments"},{"location":"common/query_arguments/#inserts","text":"INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Inserts"},{"location":"common/query_arguments_sqlite/","text":"Bind Args .sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments. Type Inference SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Named Arguments Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" ) Variable Arguments Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" )) Inserts INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Query arguments sqlite"},{"location":"common/query_arguments_sqlite/#bind-args","text":".sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments.","title":"Bind Args"},{"location":"common/query_arguments_sqlite/#type-inference","text":"SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\"","title":"Type Inference"},{"location":"common/query_arguments_sqlite/#named-arguments","text":"Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Named Arguments"},{"location":"common/query_arguments_sqlite/#variable-arguments","text":"Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" ))","title":"Variable Arguments"},{"location":"common/query_arguments_sqlite/#inserts","text":"INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Inserts"},{"location":"common/rxjava/","text":"RxJava To observe a query, depend on the RxJava extensions artifact and use the extension method it provides: dependencies { implementation \"com.squareup.sqldelight:rxjava3-extensions:1.3.0\" } val players : Observable < List < HockeyPlayer >> = playerQueries . selectAll () . asObservable () . mapToList () Note: For RxJava 2, use rxjava2-extensions as the artifact name.","title":"RxJava"},{"location":"common/rxjava/#rxjava","text":"To observe a query, depend on the RxJava extensions artifact and use the extension method it provides: dependencies { implementation \"com.squareup.sqldelight:rxjava3-extensions:1.3.0\" } val players : Observable < List < HockeyPlayer >> = playerQueries . selectAll () . asObservable () . mapToList () Note: For RxJava 2, use rxjava2-extensions as the artifact name.","title":"RxJava"},{"location":"common/transactions/","text":"API If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithReturn function. val players = database . playerQueries . transactionWithReturn { database . playerQueries . selectAll (). executeAsList () } Rollback Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted = database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size } Callbacks You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \"${players.size} players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"common/transactions/#api","text":"If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithReturn function. val players = database . playerQueries . transactionWithReturn { database . playerQueries . selectAll (). executeAsList () }","title":"API"},{"location":"common/transactions/#rollback","text":"Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted = database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size }","title":"Rollback"},{"location":"common/transactions/#callbacks","text":"You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \"${players.size} players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Callbacks"},{"location":"common/types_server_migrations/","text":"Custom Types in Migrations If migrations are the schema's source of truth, you can also specify the exposed kotlin type when altering a table: import kotlin . collection . List ; ALTER TABLE my_table ADD COLUMN new_column VARCHAR ( 8 ) AS List < String > ;","title":"Types server migrations"},{"location":"common/types_server_migrations/#custom-types-in-migrations","text":"If migrations are the schema's source of truth, you can also specify the exposed kotlin type when altering a table: import kotlin . collection . List ; ALTER TABLE my_table ADD COLUMN new_column VARCHAR ( 8 ) AS List < String > ;","title":"Custom Types in Migrations"},{"location":"common/types_sqlite/","text":"SQLite Types SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. SQLDelight natively supports Long, Double, String, ByteArray, Int, Short, Float, and Booleans. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray some_int INTEGER AS Int , -- Stored as INTEGER in db, retrieved as Int some_short INTEGER AS Short , -- Stored as INTEGER in db, retrieved as Short some_float REAL AS Float -- Stored as REAL in db, retrieved as Float ); Boolean columns are stored in the db as INTEGER , and so they can be given INTEGER column constraints. Use DEFAULT 0 to default to false, for example. CREATE TABLE hockey_player ( injured INTEGER AS Boolean DEFAULT 0 )","title":"Types sqlite"},{"location":"common/types_sqlite/#sqlite-types","text":"SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. SQLDelight natively supports Long, Double, String, ByteArray, Int, Short, Float, and Booleans. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray some_int INTEGER AS Int , -- Stored as INTEGER in db, retrieved as Int some_short INTEGER AS Short , -- Stored as INTEGER in db, retrieved as Short some_float REAL AS Float -- Stored as REAL in db, retrieved as Float ); Boolean columns are stored in the db as INTEGER , and so they can be given INTEGER column constraints. Use DEFAULT 0 to default to false, for example. CREATE TABLE hockey_player ( injured INTEGER AS Boolean DEFAULT 0 )","title":"SQLite Types"},{"location":"jvm_h2/","text":"\ud83d\udc77\u200d\u2640\ufe0f IN DEVELOPMENT H2 is still incubating, and pieces of the dialect are missing. If you are using it and encounter parts of the dialect which are unsupported, please report at sql-psi Getting Started with H2 First apply the gradle plugin in your project. buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.3.0' } } apply plugin: 'com.squareup.sqldelight' sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" dialect = \"hsql\" } } SQLDelight needs to know the schema of your database. If you always create your schema fresh with create table statements, you'll want to put those statements in .sq files, as shown here . If you apply migration files to an already running database, you'll want to rename your migration files to .sqm files, as shown here Fresh Schema Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); In the same .sq files you can start placing your sql statements to be executed at runtime . Migration Schema First, configure gradle to use migrations to assemble the schema: sqldelight { Database { ... sourceFolders = [ \"sqldelight\" ] deriveSchemaFromMigrations = true } } Migration files have the extension .sqm , and must have a number in their file name indicating what order the migration file runs in. For example, given this hierarchy: src --main ----sqldelight ------v1__backend.sqm ------v2__backend.sqm SQLDelight will create the schema by applying v1__backend.sqm and then v2__backend.sqm . Place your normal SQL CREATE / ALTER statements in these files. If another service reads from your migrations files (like flyway), make sure to read the info on migrations and how to output valid SQL. Typesafe SQL Before you're able to execute SQL statements at runtime, you need to create a SqlDriver to connect to your database. The easiest way is off of a DataSource that you would get from hikari or other connection managers. dependencies { implementation \"com.squareup.sqldelight:jdbc-driver:\" } val driver : SqlDriver = dataSource . asJdbcDriver () Regardless of if you specify the schema as fresh create table statements or through migrations, runtime SQL goes in .sq files. SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Getting Started"},{"location":"jvm_h2/#in-development","text":"H2 is still incubating, and pieces of the dialect are missing. If you are using it and encounter parts of the dialect which are unsupported, please report at sql-psi","title":"\ud83d\udc77\u200d\u2640\ufe0f IN DEVELOPMENT"},{"location":"jvm_h2/#getting-started-with-h2","text":"First apply the gradle plugin in your project. buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.3.0' } } apply plugin: 'com.squareup.sqldelight' sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" dialect = \"hsql\" } } SQLDelight needs to know the schema of your database. If you always create your schema fresh with create table statements, you'll want to put those statements in .sq files, as shown here . If you apply migration files to an already running database, you'll want to rename your migration files to .sqm files, as shown here","title":"Getting Started with H2"},{"location":"jvm_h2/#fresh-schema","text":"Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); In the same .sq files you can start placing your sql statements to be executed at runtime .","title":"Fresh Schema"},{"location":"jvm_h2/#migration-schema","text":"First, configure gradle to use migrations to assemble the schema: sqldelight { Database { ... sourceFolders = [ \"sqldelight\" ] deriveSchemaFromMigrations = true } } Migration files have the extension .sqm , and must have a number in their file name indicating what order the migration file runs in. For example, given this hierarchy: src --main ----sqldelight ------v1__backend.sqm ------v2__backend.sqm SQLDelight will create the schema by applying v1__backend.sqm and then v2__backend.sqm . Place your normal SQL CREATE / ALTER statements in these files. If another service reads from your migrations files (like flyway), make sure to read the info on migrations and how to output valid SQL.","title":"Migration Schema"},{"location":"jvm_h2/#typesafe-sql","text":"Before you're able to execute SQL statements at runtime, you need to create a SqlDriver to connect to your database. The easiest way is off of a DataSource that you would get from hikari or other connection managers. dependencies { implementation \"com.squareup.sqldelight:jdbc-driver:\" } val driver : SqlDriver = dataSource . asJdbcDriver () Regardless of if you specify the schema as fresh create table statements or through migrations, runtime SQL goes in .sq files. SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Typesafe SQL"},{"location":"jvm_h2/custom_projections/","text":"Projections By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"jvm_h2/custom_projections/#projections","text":"By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"jvm_h2/gradle/","text":"Gradle build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"sqldelight\" , \"resources\" ] // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // Wether or not to use .sqm files as the source of truth for the schema. // Defaults to false deriveSchemaFromMigrations = true // If set, configures a task to output the .sqm migration files as valid SQL // Defaults to null migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) // The extension format to use for generated valid SQL migrations. // Defaults to \".sql\" migrationOutputFileFormat = \".sql\" } } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = [ \"sqldelight\" , \"resources\" ] dependency project ( ' : OtherProject ' ) deriveSchemaFromMigrations = true migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" } }","title":"Gradle"},{"location":"jvm_h2/gradle/#gradle","text":"build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"sqldelight\" , \"resources\" ] // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // Wether or not to use .sqm files as the source of truth for the schema. // Defaults to false deriveSchemaFromMigrations = true // If set, configures a task to output the .sqm migration files as valid SQL // Defaults to null migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) // The extension format to use for generated valid SQL migrations. // Defaults to \".sql\" migrationOutputFileFormat = \".sql\" } } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = [ \"sqldelight\" , \"resources\" ] dependency project ( ' : OtherProject ' ) deriveSchemaFromMigrations = true migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" } }","title":"Gradle"},{"location":"jvm_h2/intellij_plugin/","text":"IntelliJ Plugin The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight","title":"IntelliJ Plugin"},{"location":"jvm_h2/intellij_plugin/#intellij-plugin","text":"The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight","title":"IntelliJ Plugin"},{"location":"jvm_h2/migrations/","text":"Valid SQL migrations Using custom kotlin types in migration files means those files are no longer valid SQL. You can optionally configure a gradle task to output your migration files as valid SQL for other services to read from: sqldelight { Database { migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" // Defaults to .sql } } This creates a new task generateMainDatabaseMigrations which will output your .sqm files as valid SQL in the output directory, with the output format. Create a dependency from your compileKotlin task so that services such as flyway will have the files available on their classpath: compileKotlin . configure { dependsOn \"generateMainDatabaseMigrations\" }","title":"Migrations"},{"location":"jvm_h2/migrations/#valid-sql-migrations","text":"Using custom kotlin types in migration files means those files are no longer valid SQL. You can optionally configure a gradle task to output your migration files as valid SQL for other services to read from: sqldelight { Database { migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" // Defaults to .sql } } This creates a new task generateMainDatabaseMigrations which will output your .sqm files as valid SQL in the output directory, with the output format. Create a dependency from your compileKotlin task so that services such as flyway will have the files available on their classpath: compileKotlin . configure { dependsOn \"generateMainDatabaseMigrations\" }","title":"Valid SQL migrations"},{"location":"jvm_h2/query_arguments/","text":"Bind Args .sq files use the exact same syntax as MySQL, including bound arguments. If a statement contains bind args, the associated method will require corresponding arguments. Type Inference SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Named Arguments Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" ) Variable Arguments Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" )) Inserts INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Arguments"},{"location":"jvm_h2/query_arguments/#bind-args","text":".sq files use the exact same syntax as MySQL, including bound arguments. If a statement contains bind args, the associated method will require corresponding arguments.","title":"Bind Args"},{"location":"jvm_h2/query_arguments/#type-inference","text":"SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\"","title":"Type Inference"},{"location":"jvm_h2/query_arguments/#named-arguments","text":"Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Named Arguments"},{"location":"jvm_h2/query_arguments/#variable-arguments","text":"Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" ))","title":"Variable Arguments"},{"location":"jvm_h2/query_arguments/#inserts","text":"INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Inserts"},{"location":"jvm_h2/transactions/","text":"API If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithReturn function. val players = database . playerQueries . transactionWithReturn { database . playerQueries . selectAll (). executeAsList () } Rollback Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted = database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size } Callbacks You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \"${players.size} players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"jvm_h2/transactions/#api","text":"If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithReturn function. val players = database . playerQueries . transactionWithReturn { database . playerQueries . selectAll (). executeAsList () }","title":"API"},{"location":"jvm_h2/transactions/#rollback","text":"Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted = database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size }","title":"Rollback"},{"location":"jvm_h2/transactions/#callbacks","text":"You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \"${players.size} players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Callbacks"},{"location":"jvm_h2/types/","text":"MySQL Types SQLDelight column definitions are identical to regular H2 column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. CREATE TABLE some_types ( some_tiny_int TINYINT , -- Retrieved as Int some_small_int SMALLINT , -- Retrieved as Int some_integer INTEGER , -- Retrieved as Int some_int INT , -- Retrieved as Int some_big_int BIGINT , -- Retrieved as Long some_decimal DECIMAL ( 6 , 5 ), -- Retrieved as Int some_dec DEC ( 6 , 5 ), -- Retrieved as Int some_numeric NUMERIC ( 6 , 5 ), -- Retrieved as Int some_float FLOAT ( 6 ), -- Retrieved as Double some_real REAL , -- Retrieved as Double some_double DOUBLE , -- Retrieved as Double some_double_precision DOUBLE PRECISION , -- Retrieved as Double some_boolean BOOLEAN , -- Retrieved as Boolean some_date DATE , -- Retrieved as String some_time TIME , -- Retrieved as String some_timestamp2 TIMESTAMP ( 6 ), -- Retrieved as String some_char CHAR , -- Retrieved as String some_character CHARACTER ( 6 ), -- Retrieved as String some_char_varying CHAR VARYING ( 6 ), -- Retrieved as String some_longvarchar LONGVARCHAR , -- Retrieved as String some_character_varying CHARACTER VARYING ( 6 ), -- Retrieved as String some_varchar VARCHAR ( 16 ), -- Retrieved as String some_clo CHARACTER LARGE OBJECT ( 16 ), -- Retrieved as String some_clob clob ( 16 M CHARACTERS ), -- Retrieved as String some_binary BINARY , -- Retrieved as ByteArray some_binary2 BINARY ( 6 ), -- Retrieved as ByteArray some_longvarbinary LONGVARBINARY , -- Retrieved as ByteArray some_longvarbinary2 LONGVARBINARY ( 6 ), -- Retrieved as ByteArray some_binary_varying BINARY VARYING ( 6 ), -- Retrieved as ByteArray some_varbinary VARBINARY ( 8 ), -- Retrieved as ByteArray some_uuid UUID , -- Retrieved as ByteArray some_blob BLOB , -- Retrieved as ByteArray some_blo BINARY LARGE OBJECT ( 6 ), -- Retrieved as ByteArray some_bit BIT , -- Retrieved as ByteArray some_bit2 BIT ( 6 ), -- Retrieved as ByteArray some_bit_varying BIT VARYING ( 6 ), -- Retrieved as ByteArray some_interval INTERVAL YEAR TO MONTH , -- Retrieved as ByteArray some_interval2 INTERVAL YEAR ( 3 ), -- Retrieved as ByteArray some_interval3 INTERVAL DAY ( 4 ) TO HOUR , -- Retrieved as ByteArray some_interval4 INTERVAL MINUTE ( 4 ) TO SECOND ( 6 ), -- Retrieved as ByteArray some_interval5 INTERVAL SECOND ( 4 , 6 ) -- Retrieved as ByteArray ); Custom Column Types If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) ) Enums As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) ) Custom Types in Migrations If migrations are the schema's source of truth, you can also specify the exposed kotlin type when altering a table: import kotlin . collection . List ; ALTER TABLE my_table ADD COLUMN new_column VARCHAR ( 8 ) AS List < String > ;","title":"Types"},{"location":"jvm_h2/types/#mysql-types","text":"SQLDelight column definitions are identical to regular H2 column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. CREATE TABLE some_types ( some_tiny_int TINYINT , -- Retrieved as Int some_small_int SMALLINT , -- Retrieved as Int some_integer INTEGER , -- Retrieved as Int some_int INT , -- Retrieved as Int some_big_int BIGINT , -- Retrieved as Long some_decimal DECIMAL ( 6 , 5 ), -- Retrieved as Int some_dec DEC ( 6 , 5 ), -- Retrieved as Int some_numeric NUMERIC ( 6 , 5 ), -- Retrieved as Int some_float FLOAT ( 6 ), -- Retrieved as Double some_real REAL , -- Retrieved as Double some_double DOUBLE , -- Retrieved as Double some_double_precision DOUBLE PRECISION , -- Retrieved as Double some_boolean BOOLEAN , -- Retrieved as Boolean some_date DATE , -- Retrieved as String some_time TIME , -- Retrieved as String some_timestamp2 TIMESTAMP ( 6 ), -- Retrieved as String some_char CHAR , -- Retrieved as String some_character CHARACTER ( 6 ), -- Retrieved as String some_char_varying CHAR VARYING ( 6 ), -- Retrieved as String some_longvarchar LONGVARCHAR , -- Retrieved as String some_character_varying CHARACTER VARYING ( 6 ), -- Retrieved as String some_varchar VARCHAR ( 16 ), -- Retrieved as String some_clo CHARACTER LARGE OBJECT ( 16 ), -- Retrieved as String some_clob clob ( 16 M CHARACTERS ), -- Retrieved as String some_binary BINARY , -- Retrieved as ByteArray some_binary2 BINARY ( 6 ), -- Retrieved as ByteArray some_longvarbinary LONGVARBINARY , -- Retrieved as ByteArray some_longvarbinary2 LONGVARBINARY ( 6 ), -- Retrieved as ByteArray some_binary_varying BINARY VARYING ( 6 ), -- Retrieved as ByteArray some_varbinary VARBINARY ( 8 ), -- Retrieved as ByteArray some_uuid UUID , -- Retrieved as ByteArray some_blob BLOB , -- Retrieved as ByteArray some_blo BINARY LARGE OBJECT ( 6 ), -- Retrieved as ByteArray some_bit BIT , -- Retrieved as ByteArray some_bit2 BIT ( 6 ), -- Retrieved as ByteArray some_bit_varying BIT VARYING ( 6 ), -- Retrieved as ByteArray some_interval INTERVAL YEAR TO MONTH , -- Retrieved as ByteArray some_interval2 INTERVAL YEAR ( 3 ), -- Retrieved as ByteArray some_interval3 INTERVAL DAY ( 4 ) TO HOUR , -- Retrieved as ByteArray some_interval4 INTERVAL MINUTE ( 4 ) TO SECOND ( 6 ), -- Retrieved as ByteArray some_interval5 INTERVAL SECOND ( 4 , 6 ) -- Retrieved as ByteArray );","title":"MySQL Types"},{"location":"jvm_h2/types/#custom-column-types","text":"If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) )","title":"Custom Column Types"},{"location":"jvm_h2/types/#enums","text":"As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Enums"},{"location":"jvm_h2/types/#custom-types-in-migrations","text":"If migrations are the schema's source of truth, you can also specify the exposed kotlin type when altering a table: import kotlin . collection . List ; ALTER TABLE my_table ADD COLUMN new_column VARCHAR ( 8 ) AS List < String > ;","title":"Custom Types in Migrations"},{"location":"jvm_mysql/","text":"Getting Started with MySQL First apply the gradle plugin in your project. buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.3.0' } } apply plugin: 'com.squareup.sqldelight' sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" dialect = \"mysql\" } } SQLDelight needs to know the schema of your database. If you always create your schema fresh with create table statements, you'll want to put those statements in .sq files, as shown here . If you apply migration files to an already running database, you'll want to rename your migration files to .sqm files, as shown here Fresh Schema Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); In the same .sq files you can start placing your sql statements to be executed at runtime . Migration Schema First, configure gradle to use migrations to assemble the schema: sqldelight { Database { ... sourceFolders = [ \"sqldelight\" ] deriveSchemaFromMigrations = true } } Migration files have the extension .sqm , and must have a number in their file name indicating what order the migration file runs in. For example, given this hierarchy: src --main ----sqldelight ------v1__backend.sqm ------v2__backend.sqm SQLDelight will create the schema by applying v1__backend.sqm and then v2__backend.sqm . Place your normal SQL CREATE / ALTER statements in these files. If another service reads from your migrations files (like flyway), make sure to read the info on migrations and how to output valid SQL. Typesafe SQL Before you're able to execute SQL statements at runtime, you need to create a SqlDriver to connect to your database. The easiest way is off of a DataSource that you would get from hikari or other connection managers. dependencies { implementation \"com.squareup.sqldelight:jdbc-driver:\" } val driver : SqlDriver = dataSource . asJdbcDriver () Regardless of if you specify the schema as fresh create table statements or through migrations, runtime SQL goes in .sq files. SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Getting Started"},{"location":"jvm_mysql/#getting-started-with-mysql","text":"First apply the gradle plugin in your project. buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.3.0' } } apply plugin: 'com.squareup.sqldelight' sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" dialect = \"mysql\" } } SQLDelight needs to know the schema of your database. If you always create your schema fresh with create table statements, you'll want to put those statements in .sq files, as shown here . If you apply migration files to an already running database, you'll want to rename your migration files to .sqm files, as shown here","title":"Getting Started with MySQL"},{"location":"jvm_mysql/#fresh-schema","text":"Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); In the same .sq files you can start placing your sql statements to be executed at runtime .","title":"Fresh Schema"},{"location":"jvm_mysql/#migration-schema","text":"First, configure gradle to use migrations to assemble the schema: sqldelight { Database { ... sourceFolders = [ \"sqldelight\" ] deriveSchemaFromMigrations = true } } Migration files have the extension .sqm , and must have a number in their file name indicating what order the migration file runs in. For example, given this hierarchy: src --main ----sqldelight ------v1__backend.sqm ------v2__backend.sqm SQLDelight will create the schema by applying v1__backend.sqm and then v2__backend.sqm . Place your normal SQL CREATE / ALTER statements in these files. If another service reads from your migrations files (like flyway), make sure to read the info on migrations and how to output valid SQL.","title":"Migration Schema"},{"location":"jvm_mysql/#typesafe-sql","text":"Before you're able to execute SQL statements at runtime, you need to create a SqlDriver to connect to your database. The easiest way is off of a DataSource that you would get from hikari or other connection managers. dependencies { implementation \"com.squareup.sqldelight:jdbc-driver:\" } val driver : SqlDriver = dataSource . asJdbcDriver () Regardless of if you specify the schema as fresh create table statements or through migrations, runtime SQL goes in .sq files. SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Typesafe SQL"},{"location":"jvm_mysql/custom_projections/","text":"Projections By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"jvm_mysql/custom_projections/#projections","text":"By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"jvm_mysql/gradle/","text":"Gradle build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"sqldelight\" , \"resources\" ] // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // Wether or not to use .sqm files as the source of truth for the schema. // Defaults to false deriveSchemaFromMigrations = true // If set, configures a task to output the .sqm migration files as valid SQL // Defaults to null migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) // The extension format to use for generated valid SQL migrations. // Defaults to \".sql\" migrationOutputFileFormat = \".sql\" } } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = [ \"sqldelight\" , \"resources\" ] dependency project ( ' : OtherProject ' ) deriveSchemaFromMigrations = true migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" } }","title":"Gradle"},{"location":"jvm_mysql/gradle/#gradle","text":"build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"sqldelight\" , \"resources\" ] // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // Wether or not to use .sqm files as the source of truth for the schema. // Defaults to false deriveSchemaFromMigrations = true // If set, configures a task to output the .sqm migration files as valid SQL // Defaults to null migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) // The extension format to use for generated valid SQL migrations. // Defaults to \".sql\" migrationOutputFileFormat = \".sql\" } } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = [ \"sqldelight\" , \"resources\" ] dependency project ( ' : OtherProject ' ) deriveSchemaFromMigrations = true migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" } }","title":"Gradle"},{"location":"jvm_mysql/intellij_plugin/","text":"IntelliJ Plugin The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight","title":"IntelliJ Plugin"},{"location":"jvm_mysql/intellij_plugin/#intellij-plugin","text":"The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight","title":"IntelliJ Plugin"},{"location":"jvm_mysql/migrations/","text":"Valid SQL migrations Using custom kotlin types in migration files means those files are no longer valid SQL. You can optionally configure a gradle task to output your migration files as valid SQL for other services to read from: sqldelight { Database { migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" // Defaults to .sql } } This creates a new task generateMainDatabaseMigrations which will output your .sqm files as valid SQL in the output directory, with the output format. Create a dependency from your compileKotlin task so that services such as flyway will have the files available on their classpath: compileKotlin . configure { dependsOn \"generateMainDatabaseMigrations\" }","title":"Migrations"},{"location":"jvm_mysql/migrations/#valid-sql-migrations","text":"Using custom kotlin types in migration files means those files are no longer valid SQL. You can optionally configure a gradle task to output your migration files as valid SQL for other services to read from: sqldelight { Database { migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" // Defaults to .sql } } This creates a new task generateMainDatabaseMigrations which will output your .sqm files as valid SQL in the output directory, with the output format. Create a dependency from your compileKotlin task so that services such as flyway will have the files available on their classpath: compileKotlin . configure { dependsOn \"generateMainDatabaseMigrations\" }","title":"Valid SQL migrations"},{"location":"jvm_mysql/query_arguments/","text":"Bind Args .sq files use the exact same syntax as MySQL, including bound arguments. If a statement contains bind args, the associated method will require corresponding arguments. Type Inference SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Named Arguments Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" ) Variable Arguments Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" )) Inserts INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Arguments"},{"location":"jvm_mysql/query_arguments/#bind-args","text":".sq files use the exact same syntax as MySQL, including bound arguments. If a statement contains bind args, the associated method will require corresponding arguments.","title":"Bind Args"},{"location":"jvm_mysql/query_arguments/#type-inference","text":"SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\"","title":"Type Inference"},{"location":"jvm_mysql/query_arguments/#named-arguments","text":"Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Named Arguments"},{"location":"jvm_mysql/query_arguments/#variable-arguments","text":"Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" ))","title":"Variable Arguments"},{"location":"jvm_mysql/query_arguments/#inserts","text":"INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Inserts"},{"location":"jvm_mysql/transactions/","text":"API If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithReturn function. val players = database . playerQueries . transactionWithReturn { database . playerQueries . selectAll (). executeAsList () } Rollback Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted = database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size } Callbacks You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \"${players.size} players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"jvm_mysql/transactions/#api","text":"If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithReturn function. val players = database . playerQueries . transactionWithReturn { database . playerQueries . selectAll (). executeAsList () }","title":"API"},{"location":"jvm_mysql/transactions/#rollback","text":"Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted = database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size }","title":"Rollback"},{"location":"jvm_mysql/transactions/#callbacks","text":"You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \"${players.size} players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Callbacks"},{"location":"jvm_mysql/types/","text":"MySQL Types SQLDelight column definitions are identical to regular MySQL column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. CREATE TABLE some_types ( some_tiny_int TINYINT , -- Retrieved as Int some_small_int SMALLINT , -- Retrieved as Int some_medium_int MEDIUMINT , -- Retrieved as Int some_integer INTEGER , -- Retrieved as Int some_int INT , -- Retrieved as Int some_big_int BIGINT , -- Retrieved as Long some_decimal DECIMAL , -- Retrieved as Double some_dec DEC , -- Retrieved as Double some_fixed FIXED , -- Retrieved as Double some_numeric NUMERIC , -- Retrieved as Double some_float FLOAT , -- Retrieved as Double some_real REAL , -- Retrieved as Double some_double_prec DOUBLE PRECISION , -- Retrieved as Double some_double DOUBLE , -- Retrieved as Double some_date DATE , -- Retrieved as String some_time TIME , -- Retrieved as String some_datetime DATETIME , -- Retrieved as String some_timestamp TIMESTAMP , -- Retrieved as String some_year YEAR , -- Retrieved as String some_char CHAR , -- Retrieved as String some_varchar VARCHAR ( 16 ), -- Retrieved as String some_tiny_text TINYTEXT , -- Retrieved as String some_text TEXT , -- Retrieved as String some_medium_text MEDIUMTEXT , -- Retrieved as String some_long_text LONGTEXT , -- Retrieved as String some_enum ENUM , -- Retrieved as String some_set SET , -- Retrieved as String some_varbinary VARBINARY ( 8 ), -- Retrieved as ByteArray some_blob BLOB ( 8 , 8 ), -- Retrieved as ByteArray some_binary BINARY , -- Retrieved as ByteArray some_json JSON , -- Retrieved as String some_boolean BOOLEAN , -- Retrieved as Boolean ); Custom Column Types If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) ) Enums As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) ) Custom Types in Migrations If migrations are the schema's source of truth, you can also specify the exposed kotlin type when altering a table: import kotlin . collection . List ; ALTER TABLE my_table ADD COLUMN new_column VARCHAR ( 8 ) AS List < String > ;","title":"Types"},{"location":"jvm_mysql/types/#mysql-types","text":"SQLDelight column definitions are identical to regular MySQL column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. CREATE TABLE some_types ( some_tiny_int TINYINT , -- Retrieved as Int some_small_int SMALLINT , -- Retrieved as Int some_medium_int MEDIUMINT , -- Retrieved as Int some_integer INTEGER , -- Retrieved as Int some_int INT , -- Retrieved as Int some_big_int BIGINT , -- Retrieved as Long some_decimal DECIMAL , -- Retrieved as Double some_dec DEC , -- Retrieved as Double some_fixed FIXED , -- Retrieved as Double some_numeric NUMERIC , -- Retrieved as Double some_float FLOAT , -- Retrieved as Double some_real REAL , -- Retrieved as Double some_double_prec DOUBLE PRECISION , -- Retrieved as Double some_double DOUBLE , -- Retrieved as Double some_date DATE , -- Retrieved as String some_time TIME , -- Retrieved as String some_datetime DATETIME , -- Retrieved as String some_timestamp TIMESTAMP , -- Retrieved as String some_year YEAR , -- Retrieved as String some_char CHAR , -- Retrieved as String some_varchar VARCHAR ( 16 ), -- Retrieved as String some_tiny_text TINYTEXT , -- Retrieved as String some_text TEXT , -- Retrieved as String some_medium_text MEDIUMTEXT , -- Retrieved as String some_long_text LONGTEXT , -- Retrieved as String some_enum ENUM , -- Retrieved as String some_set SET , -- Retrieved as String some_varbinary VARBINARY ( 8 ), -- Retrieved as ByteArray some_blob BLOB ( 8 , 8 ), -- Retrieved as ByteArray some_binary BINARY , -- Retrieved as ByteArray some_json JSON , -- Retrieved as String some_boolean BOOLEAN , -- Retrieved as Boolean );","title":"MySQL Types"},{"location":"jvm_mysql/types/#custom-column-types","text":"If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) )","title":"Custom Column Types"},{"location":"jvm_mysql/types/#enums","text":"As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Enums"},{"location":"jvm_mysql/types/#custom-types-in-migrations","text":"If migrations are the schema's source of truth, you can also specify the exposed kotlin type when altering a table: import kotlin . collection . List ; ALTER TABLE my_table ADD COLUMN new_column VARCHAR ( 8 ) AS List < String > ;","title":"Custom Types in Migrations"},{"location":"jvm_postgresql/","text":"\ud83d\udc77\u200d\u2640\ufe0f IN DEVELOPMENT PostgreSQL is still incubating, and pieces of the dialect are missing. If you are using it and encounter parts of the dialect which are unsupported, please report at sql-psi Getting Started with PostgreSQL First apply the gradle plugin in your project. buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.3.0' } } apply plugin: 'com.squareup.sqldelight' sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" dialect = \"postgresql\" } } SQLDelight needs to know the schema of your database. If you always create your schema fresh with create table statements, you'll want to put those statements in .sq files, as shown here . If you apply migration files to an already running database, you'll want to rename your migration files to .sqm files, as shown here Fresh Schema Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); In the same .sq files you can start placing your sql statements to be executed at runtime . Migration Schema First, configure gradle to use migrations to assemble the schema: sqldelight { Database { ... sourceFolders = [ \"sqldelight\" ] deriveSchemaFromMigrations = true } } Migration files have the extension .sqm , and must have a number in their file name indicating what order the migration file runs in. For example, given this hierarchy: src --main ----sqldelight ------v1__backend.sqm ------v2__backend.sqm SQLDelight will create the schema by applying v1__backend.sqm and then v2__backend.sqm . Place your normal SQL CREATE / ALTER statements in these files. If another service reads from your migrations files (like flyway), make sure to read the info on migrations and how to output valid SQL. Typesafe SQL Before you're able to execute SQL statements at runtime, you need to create a SqlDriver to connect to your database. The easiest way is off of a DataSource that you would get from hikari or other connection managers. dependencies { implementation \"com.squareup.sqldelight:jdbc-driver:\" } val driver : SqlDriver = dataSource . asJdbcDriver () Regardless of if you specify the schema as fresh create table statements or through migrations, runtime SQL goes in .sq files. SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Getting Started"},{"location":"jvm_postgresql/#in-development","text":"PostgreSQL is still incubating, and pieces of the dialect are missing. If you are using it and encounter parts of the dialect which are unsupported, please report at sql-psi","title":"\ud83d\udc77\u200d\u2640\ufe0f IN DEVELOPMENT"},{"location":"jvm_postgresql/#getting-started-with-postgresql","text":"First apply the gradle plugin in your project. buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.3.0' } } apply plugin: 'com.squareup.sqldelight' sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" dialect = \"postgresql\" } } SQLDelight needs to know the schema of your database. If you always create your schema fresh with create table statements, you'll want to put those statements in .sq files, as shown here . If you apply migration files to an already running database, you'll want to rename your migration files to .sqm files, as shown here","title":"Getting Started with PostgreSQL"},{"location":"jvm_postgresql/#fresh-schema","text":"Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); In the same .sq files you can start placing your sql statements to be executed at runtime .","title":"Fresh Schema"},{"location":"jvm_postgresql/#migration-schema","text":"First, configure gradle to use migrations to assemble the schema: sqldelight { Database { ... sourceFolders = [ \"sqldelight\" ] deriveSchemaFromMigrations = true } } Migration files have the extension .sqm , and must have a number in their file name indicating what order the migration file runs in. For example, given this hierarchy: src --main ----sqldelight ------v1__backend.sqm ------v2__backend.sqm SQLDelight will create the schema by applying v1__backend.sqm and then v2__backend.sqm . Place your normal SQL CREATE / ALTER statements in these files. If another service reads from your migrations files (like flyway), make sure to read the info on migrations and how to output valid SQL.","title":"Migration Schema"},{"location":"jvm_postgresql/#typesafe-sql","text":"Before you're able to execute SQL statements at runtime, you need to create a SqlDriver to connect to your database. The easiest way is off of a DataSource that you would get from hikari or other connection managers. dependencies { implementation \"com.squareup.sqldelight:jdbc-driver:\" } val driver : SqlDriver = dataSource . asJdbcDriver () Regardless of if you specify the schema as fresh create table statements or through migrations, runtime SQL goes in .sq files. SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Typesafe SQL"},{"location":"jvm_postgresql/custom_projections/","text":"Projections By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"jvm_postgresql/custom_projections/#projections","text":"By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"jvm_postgresql/gradle/","text":"Gradle build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"sqldelight\" , \"resources\" ] // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // Wether or not to use .sqm files as the source of truth for the schema. // Defaults to false deriveSchemaFromMigrations = true // If set, configures a task to output the .sqm migration files as valid SQL // Defaults to null migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) // The extension format to use for generated valid SQL migrations. // Defaults to \".sql\" migrationOutputFileFormat = \".sql\" } } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = [ \"sqldelight\" , \"resources\" ] dependency project ( ' : OtherProject ' ) deriveSchemaFromMigrations = true migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" } }","title":"Gradle"},{"location":"jvm_postgresql/gradle/#gradle","text":"build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"sqldelight\" , \"resources\" ] // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // Wether or not to use .sqm files as the source of truth for the schema. // Defaults to false deriveSchemaFromMigrations = true // If set, configures a task to output the .sqm migration files as valid SQL // Defaults to null migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) // The extension format to use for generated valid SQL migrations. // Defaults to \".sql\" migrationOutputFileFormat = \".sql\" } } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = [ \"sqldelight\" , \"resources\" ] dependency project ( ' : OtherProject ' ) deriveSchemaFromMigrations = true migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" } }","title":"Gradle"},{"location":"jvm_postgresql/intellij_plugin/","text":"IntelliJ Plugin The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight","title":"IntelliJ Plugin"},{"location":"jvm_postgresql/intellij_plugin/#intellij-plugin","text":"The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight","title":"IntelliJ Plugin"},{"location":"jvm_postgresql/migrations/","text":"Valid SQL migrations Using custom kotlin types in migration files means those files are no longer valid SQL. You can optionally configure a gradle task to output your migration files as valid SQL for other services to read from: sqldelight { Database { migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" // Defaults to .sql } } This creates a new task generateMainDatabaseMigrations which will output your .sqm files as valid SQL in the output directory, with the output format. Create a dependency from your compileKotlin task so that services such as flyway will have the files available on their classpath: compileKotlin . configure { dependsOn \"generateMainDatabaseMigrations\" }","title":"Migrations"},{"location":"jvm_postgresql/migrations/#valid-sql-migrations","text":"Using custom kotlin types in migration files means those files are no longer valid SQL. You can optionally configure a gradle task to output your migration files as valid SQL for other services to read from: sqldelight { Database { migrationOutputDirectory = file ( \"$buildDir/resources/main/migrations\" ) migrationOutputFileFormat = \".sql\" // Defaults to .sql } } This creates a new task generateMainDatabaseMigrations which will output your .sqm files as valid SQL in the output directory, with the output format. Create a dependency from your compileKotlin task so that services such as flyway will have the files available on their classpath: compileKotlin . configure { dependsOn \"generateMainDatabaseMigrations\" }","title":"Valid SQL migrations"},{"location":"jvm_postgresql/query_arguments/","text":"Bind Args .sq files use the exact same syntax as PostgreSQL, including bound arguments. If a statement contains bind args, the associated method will require corresponding arguments. Type Inference SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Named Arguments Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" ) Variable Arguments Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" )) Inserts INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Arguments"},{"location":"jvm_postgresql/query_arguments/#bind-args","text":".sq files use the exact same syntax as PostgreSQL, including bound arguments. If a statement contains bind args, the associated method will require corresponding arguments.","title":"Bind Args"},{"location":"jvm_postgresql/query_arguments/#type-inference","text":"SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\"","title":"Type Inference"},{"location":"jvm_postgresql/query_arguments/#named-arguments","text":"Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Named Arguments"},{"location":"jvm_postgresql/query_arguments/#variable-arguments","text":"Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" ))","title":"Variable Arguments"},{"location":"jvm_postgresql/query_arguments/#inserts","text":"INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Inserts"},{"location":"jvm_postgresql/transactions/","text":"API If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithReturn function. val players = database . playerQueries . transactionWithReturn { database . playerQueries . selectAll (). executeAsList () } Rollback Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted = database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size } Callbacks You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \"${players.size} players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"jvm_postgresql/transactions/#api","text":"If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithReturn function. val players = database . playerQueries . transactionWithReturn { database . playerQueries . selectAll (). executeAsList () }","title":"API"},{"location":"jvm_postgresql/transactions/#rollback","text":"Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted = database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size }","title":"Rollback"},{"location":"jvm_postgresql/transactions/#callbacks","text":"You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \"${players.size} players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Callbacks"},{"location":"jvm_postgresql/types/","text":"PostgreSQL Types SQLDelight column definitions are identical to regular PostgreSQL column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. CREATE TABLE some_types ( some_smallint SMALLINT , -- Retrieved as Int some_int2 INT2 , -- Retrieved as Int some_integer INTEGER , -- Retrieved as Int some_int INT , -- Retrieved as Int some_int4 INT4 , -- Retrieved as Int some_bigint BIGINT , -- Retrieved as Long some_int8 INT8 , -- Retrieved as Long some_numeric NUMERIC , -- Retrieved as Int some_decimal DECIMAL , -- Retrieved as Int some_real REAL , -- Retrieved as Double some_float4 FLOAT4 , -- Retrieved as Double some_double_prec DOUBLE PRECISION , -- Retrieved as Double some_float8 FLOAT8 , -- Retrieved as Double some_character CHARACTER , -- Retrieved as String some_char CHAR , -- Retrieved as String some_char_var CHARACTER VARYING ( 16 ), -- Retrieved as String some_varchar VARCHAR ( 16 ), -- Retrieved as String some_text TEXT , -- Retrieved as String some_date DATE , -- Retrieved as String some_time TIME , -- Retrieved as String some_timestamp TIMESTAMP , -- Retrieved as String some_json JSON -- Retrieved as String ); Custom Column Types If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) ) Enums As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) ) Custom Types in Migrations If migrations are the schema's source of truth, you can also specify the exposed kotlin type when altering a table: import kotlin . collection . List ; ALTER TABLE my_table ADD COLUMN new_column VARCHAR ( 8 ) AS List < String > ;","title":"Types"},{"location":"jvm_postgresql/types/#postgresql-types","text":"SQLDelight column definitions are identical to regular PostgreSQL column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. CREATE TABLE some_types ( some_smallint SMALLINT , -- Retrieved as Int some_int2 INT2 , -- Retrieved as Int some_integer INTEGER , -- Retrieved as Int some_int INT , -- Retrieved as Int some_int4 INT4 , -- Retrieved as Int some_bigint BIGINT , -- Retrieved as Long some_int8 INT8 , -- Retrieved as Long some_numeric NUMERIC , -- Retrieved as Int some_decimal DECIMAL , -- Retrieved as Int some_real REAL , -- Retrieved as Double some_float4 FLOAT4 , -- Retrieved as Double some_double_prec DOUBLE PRECISION , -- Retrieved as Double some_float8 FLOAT8 , -- Retrieved as Double some_character CHARACTER , -- Retrieved as String some_char CHAR , -- Retrieved as String some_char_var CHARACTER VARYING ( 16 ), -- Retrieved as String some_varchar VARCHAR ( 16 ), -- Retrieved as String some_text TEXT , -- Retrieved as String some_date DATE , -- Retrieved as String some_time TIME , -- Retrieved as String some_timestamp TIMESTAMP , -- Retrieved as String some_json JSON -- Retrieved as String );","title":"PostgreSQL Types"},{"location":"jvm_postgresql/types/#custom-column-types","text":"If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) )","title":"Custom Column Types"},{"location":"jvm_postgresql/types/#enums","text":"As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Enums"},{"location":"jvm_postgresql/types/#custom-types-in-migrations","text":"If migrations are the schema's source of truth, you can also specify the exposed kotlin type when altering a table: import kotlin . collection . List ; ALTER TABLE my_table ADD COLUMN new_column VARCHAR ( 8 ) AS List < String > ;","title":"Custom Types in Migrations"},{"location":"jvm_sqlite/","text":"Getting Started on JVM with SQLite First apply the gradle plugin in your project. buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.3.0' } } apply plugin: 'com.squareup.sqldelight' sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" } } Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: dependencies { implementation \"com.squareup.sqldelight:sqlite-driver:1.3.0\" } val driver : SqlDriver = JdbcSqliteDriver ( JdbcSqliteDriver . IN_MEMORY ) Database . Schema . create ( driver ) SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Getting Started"},{"location":"jvm_sqlite/#getting-started-on-jvm-with-sqlite","text":"First apply the gradle plugin in your project. buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.3.0' } } apply plugin: 'com.squareup.sqldelight' sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" } } Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: dependencies { implementation \"com.squareup.sqldelight:sqlite-driver:1.3.0\" } val driver : SqlDriver = JdbcSqliteDriver ( JdbcSqliteDriver . IN_MEMORY ) Database . Schema . create ( driver ) SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Getting Started on JVM with SQLite"},{"location":"jvm_sqlite/coroutines/","text":"Flow To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides: dependencies { implementation \"com.squareup.sqldelight:coroutines-extensions:1.2.1\" } val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Coroutines"},{"location":"jvm_sqlite/coroutines/#flow","text":"To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides: dependencies { implementation \"com.squareup.sqldelight:coroutines-extensions:1.2.1\" } val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Flow"},{"location":"jvm_sqlite/custom_projections/","text":"Projections By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"jvm_sqlite/custom_projections/#projections","text":"By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"jvm_sqlite/gradle/","text":"Gradle For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // The dialect version you would like to target // Defaults to \"sqlite:3.18\" dialect = \"sqlite:3.24\" } } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) dialect = \"sqlite:3.24\" } }","title":"Gradle"},{"location":"jvm_sqlite/gradle/#gradle","text":"For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // The dialect version you would like to target // Defaults to \"sqlite:3.18\" dialect = \"sqlite:3.24\" } } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) dialect = \"sqlite:3.24\" } }","title":"Gradle"},{"location":"jvm_sqlite/intellij_plugin/","text":"IntelliJ Plugin The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight","title":"IntelliJ Plugin"},{"location":"jvm_sqlite/intellij_plugin/#intellij-plugin","text":"The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight","title":"IntelliJ Plugin"},{"location":"jvm_sqlite/migrations/","text":"Migrations The .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. Versioning The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; These SQL statements are run by Database.Schema.migrate() . Verifying Migrations You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task, which is available once you specify a schemaOutputDirectory , as described in the gradle.md . You should probably do this before you create your first migration.","title":"Migrations"},{"location":"jvm_sqlite/migrations/#migrations","text":"The .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date.","title":"Migrations"},{"location":"jvm_sqlite/migrations/#versioning","text":"The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; These SQL statements are run by Database.Schema.migrate() .","title":"Versioning"},{"location":"jvm_sqlite/migrations/#verifying-migrations","text":"You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task, which is available once you specify a schemaOutputDirectory , as described in the gradle.md . You should probably do this before you create your first migration.","title":"Verifying Migrations"},{"location":"jvm_sqlite/query_arguments/","text":"Bind Args .sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments. Type Inference SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Named Arguments Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" ) Variable Arguments Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" )) Inserts INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Arguments"},{"location":"jvm_sqlite/query_arguments/#bind-args","text":".sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments.","title":"Bind Args"},{"location":"jvm_sqlite/query_arguments/#type-inference","text":"SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\"","title":"Type Inference"},{"location":"jvm_sqlite/query_arguments/#named-arguments","text":"Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Named Arguments"},{"location":"jvm_sqlite/query_arguments/#variable-arguments","text":"Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" ))","title":"Variable Arguments"},{"location":"jvm_sqlite/query_arguments/#inserts","text":"INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Inserts"},{"location":"jvm_sqlite/rxjava/","text":"RxJava To observe a query, depend on the RxJava extensions artifact and use the extension method it provides: dependencies { implementation \"com.squareup.sqldelight:rxjava3-extensions:1.3.0\" } val players : Observable < List < HockeyPlayer >> = playerQueries . selectAll () . asObservable () . mapToList () Note: For RxJava 2, use rxjava2-extensions as the artifact name.","title":"RxJava"},{"location":"jvm_sqlite/rxjava/#rxjava","text":"To observe a query, depend on the RxJava extensions artifact and use the extension method it provides: dependencies { implementation \"com.squareup.sqldelight:rxjava3-extensions:1.3.0\" } val players : Observable < List < HockeyPlayer >> = playerQueries . selectAll () . asObservable () . mapToList () Note: For RxJava 2, use rxjava2-extensions as the artifact name.","title":"RxJava"},{"location":"jvm_sqlite/transactions/","text":"API If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithReturn function. val players = database . playerQueries . transactionWithReturn { database . playerQueries . selectAll (). executeAsList () } Rollback Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted = database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size } Callbacks You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \"${players.size} players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"jvm_sqlite/transactions/#api","text":"If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithReturn function. val players = database . playerQueries . transactionWithReturn { database . playerQueries . selectAll (). executeAsList () }","title":"API"},{"location":"jvm_sqlite/transactions/#rollback","text":"Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted = database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size }","title":"Rollback"},{"location":"jvm_sqlite/transactions/#callbacks","text":"You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \"${players.size} players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Callbacks"},{"location":"jvm_sqlite/types/","text":"SQLite Types SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. SQLDelight natively supports Long, Double, String, ByteArray, Int, Short, Float, and Booleans. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray some_int INTEGER AS Int , -- Stored as INTEGER in db, retrieved as Int some_short INTEGER AS Short , -- Stored as INTEGER in db, retrieved as Short some_float REAL AS Float -- Stored as REAL in db, retrieved as Float ); Boolean columns are stored in the db as INTEGER , and so they can be given INTEGER column constraints. Use DEFAULT 0 to default to false, for example. CREATE TABLE hockey_player ( injured INTEGER AS Boolean DEFAULT 0 ) Custom Column Types If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) ) Enums As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Types"},{"location":"jvm_sqlite/types/#sqlite-types","text":"SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. SQLDelight natively supports Long, Double, String, ByteArray, Int, Short, Float, and Booleans. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray some_int INTEGER AS Int , -- Stored as INTEGER in db, retrieved as Int some_short INTEGER AS Short , -- Stored as INTEGER in db, retrieved as Short some_float REAL AS Float -- Stored as REAL in db, retrieved as Float ); Boolean columns are stored in the db as INTEGER , and so they can be given INTEGER column constraints. Use DEFAULT 0 to default to false, for example. CREATE TABLE hockey_player ( injured INTEGER AS Boolean DEFAULT 0 )","title":"SQLite Types"},{"location":"jvm_sqlite/types/#custom-column-types","text":"If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) )","title":"Custom Column Types"},{"location":"jvm_sqlite/types/#enums","text":"As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Enums"},{"location":"multiplatform_sqlite/","text":"Getting Started with Multiplatform First apply the gradle plugin in your project. buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.3.0' } } apply plugin: 'com.squareup.sqldelight' sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" } } Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: kotlin { // The drivers needed will change depending on what platforms you target: sourceSets . androidMain . dependencies { implementation \"com.squareup.sqldelight:android-driver:1.3.0\" } // or sourceSets.iosMain, sourceSets.windowsMain, etc. sourceSets . nativeMain . dependencies { implementation \"com.squareup.sqldelight:native-driver:1.3.0\" } sourceSets . jvmMain . dependencies { implementation \"com.squareup.sqldelight:sqlite-driver:1.3.0\" } } // in src/commonMain/kotlin expect class DriverFactory { expect fun createDriver (): SqlDriver } fun createDatabase ( driverFactory ): Database { val driver = driverFactory . createDriver () val database = Database ( driver ) // Do more work with the database (see below). } // in src/androidMain/kotlin actual class DriverFactory ( private val context : Context ) { actual fun createDriver (): SqlDriver { return AndroidSqliteDriver ( Database . Schema , context , \"test.db\" ) } } // in src/nativeMain/kotlin actual class DriverFactory { actual fun createDriver (): SqlDriver { return NativeSqliteDriver ( Database . Schema , \"test.db\" ) } } // in src/jvmMain/kotlin actual class DriverFactory { actual fun createDriver (): SqlDriver { val driver : SqlDriver = JdbcSqliteDriver ( JdbcSqliteDriver . IN_MEMORY ) Database . Schema . create ( driver ) return driver } } SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Getting Started"},{"location":"multiplatform_sqlite/#getting-started-with-multiplatform","text":"First apply the gradle plugin in your project. buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.3.0' } } apply plugin: 'com.squareup.sqldelight' sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" } } Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: kotlin { // The drivers needed will change depending on what platforms you target: sourceSets . androidMain . dependencies { implementation \"com.squareup.sqldelight:android-driver:1.3.0\" } // or sourceSets.iosMain, sourceSets.windowsMain, etc. sourceSets . nativeMain . dependencies { implementation \"com.squareup.sqldelight:native-driver:1.3.0\" } sourceSets . jvmMain . dependencies { implementation \"com.squareup.sqldelight:sqlite-driver:1.3.0\" } } // in src/commonMain/kotlin expect class DriverFactory { expect fun createDriver (): SqlDriver } fun createDatabase ( driverFactory ): Database { val driver = driverFactory . createDriver () val database = Database ( driver ) // Do more work with the database (see below). } // in src/androidMain/kotlin actual class DriverFactory ( private val context : Context ) { actual fun createDriver (): SqlDriver { return AndroidSqliteDriver ( Database . Schema , context , \"test.db\" ) } } // in src/nativeMain/kotlin actual class DriverFactory { actual fun createDriver (): SqlDriver { return NativeSqliteDriver ( Database . Schema , \"test.db\" ) } } // in src/jvmMain/kotlin actual class DriverFactory { actual fun createDriver (): SqlDriver { val driver : SqlDriver = JdbcSqliteDriver ( JdbcSqliteDriver . IN_MEMORY ) Database . Schema . create ( driver ) return driver } } SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Getting Started with Multiplatform"},{"location":"multiplatform_sqlite/coroutines/","text":"Flow To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides: kotlin { sourceSets . commonMain . dependencies { implementation \"com.squareup.sqldelight:coroutines-extensions:1.2.1\" } } val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Coroutines"},{"location":"multiplatform_sqlite/coroutines/#flow","text":"To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides: kotlin { sourceSets . commonMain . dependencies { implementation \"com.squareup.sqldelight:coroutines-extensions:1.2.1\" } } val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Flow"},{"location":"multiplatform_sqlite/custom_projections/","text":"Projections By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"multiplatform_sqlite/custom_projections/#projections","text":"By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"multiplatform_sqlite/gradle/","text":"Gradle For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // The dialect version you would like to target // Defaults to \"sqlite:3.18\" dialect = \"sqlite:3.24\" } // For native targets, whether sqlite should be automatically linked. // Defaults to true. linkSqlite = false } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) dialect = \"sqlite:3.24\" } linkSqlite = false }","title":"Gradle"},{"location":"multiplatform_sqlite/gradle/#gradle","text":"For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // The dialect version you would like to target // Defaults to \"sqlite:3.18\" dialect = \"sqlite:3.24\" } // For native targets, whether sqlite should be automatically linked. // Defaults to true. linkSqlite = false } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) dialect = \"sqlite:3.24\" } linkSqlite = false }","title":"Gradle"},{"location":"multiplatform_sqlite/intellij_plugin/","text":"IntelliJ Plugin The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight","title":"IntelliJ Plugin"},{"location":"multiplatform_sqlite/intellij_plugin/#intellij-plugin","text":"The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight","title":"IntelliJ Plugin"},{"location":"multiplatform_sqlite/migrations/","text":"Migrations The .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. Versioning The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; These SQL statements are run by Database.Schema.migrate() . Verifying Migrations You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task, which is available once you specify a schemaOutputDirectory , as described in the gradle.md . You should probably do this before you create your first migration.","title":"Migrations"},{"location":"multiplatform_sqlite/migrations/#migrations","text":"The .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date.","title":"Migrations"},{"location":"multiplatform_sqlite/migrations/#versioning","text":"The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; These SQL statements are run by Database.Schema.migrate() .","title":"Versioning"},{"location":"multiplatform_sqlite/migrations/#verifying-migrations","text":"You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task, which is available once you specify a schemaOutputDirectory , as described in the gradle.md . You should probably do this before you create your first migration.","title":"Verifying Migrations"},{"location":"multiplatform_sqlite/query_arguments/","text":"Bind Args .sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments. Type Inference SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Named Arguments Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" ) Variable Arguments Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" )) Inserts INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Arguments"},{"location":"multiplatform_sqlite/query_arguments/#bind-args","text":".sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments.","title":"Bind Args"},{"location":"multiplatform_sqlite/query_arguments/#type-inference","text":"SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\"","title":"Type Inference"},{"location":"multiplatform_sqlite/query_arguments/#named-arguments","text":"Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Named Arguments"},{"location":"multiplatform_sqlite/query_arguments/#variable-arguments","text":"Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" ))","title":"Variable Arguments"},{"location":"multiplatform_sqlite/query_arguments/#inserts","text":"INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Inserts"},{"location":"multiplatform_sqlite/resources/","text":"Other Resources Guides Introduction to Multiplatform Persistence with SQLDelight Samples https://github.com/joreilly/PeopleInSpace (Android/iOS/watchOS/macOS/Web) https://github.com/JakeWharton/SdkSearch (Android/Web) https://github.com/saket/press (Android/macOS) https://github.com/cashapp/sqldelight/tree/master/sample (Android/iOS/Web)","title":"Resources"},{"location":"multiplatform_sqlite/resources/#other-resources","text":"","title":"Other Resources"},{"location":"multiplatform_sqlite/resources/#guides","text":"Introduction to Multiplatform Persistence with SQLDelight","title":"Guides"},{"location":"multiplatform_sqlite/resources/#samples","text":"https://github.com/joreilly/PeopleInSpace (Android/iOS/watchOS/macOS/Web) https://github.com/JakeWharton/SdkSearch (Android/Web) https://github.com/saket/press (Android/macOS) https://github.com/cashapp/sqldelight/tree/master/sample (Android/iOS/Web)","title":"Samples"},{"location":"multiplatform_sqlite/transactions/","text":"API If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithReturn function. val players = database . playerQueries . transactionWithReturn { database . playerQueries . selectAll (). executeAsList () } Rollback Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted = database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size } Callbacks You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \"${players.size} players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"multiplatform_sqlite/transactions/#api","text":"If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithReturn function. val players = database . playerQueries . transactionWithReturn { database . playerQueries . selectAll (). executeAsList () }","title":"API"},{"location":"multiplatform_sqlite/transactions/#rollback","text":"Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted = database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size }","title":"Rollback"},{"location":"multiplatform_sqlite/transactions/#callbacks","text":"You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \"${players.size} players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Callbacks"},{"location":"multiplatform_sqlite/types/","text":"SQLite Types SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. SQLDelight natively supports Long, Double, String, ByteArray, Int, Short, Float, and Booleans. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray some_int INTEGER AS Int , -- Stored as INTEGER in db, retrieved as Int some_short INTEGER AS Short , -- Stored as INTEGER in db, retrieved as Short some_float REAL AS Float -- Stored as REAL in db, retrieved as Float ); Boolean columns are stored in the db as INTEGER , and so they can be given INTEGER column constraints. Use DEFAULT 0 to default to false, for example. CREATE TABLE hockey_player ( injured INTEGER AS Boolean DEFAULT 0 ) Custom Column Types If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) ) Enums As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Types"},{"location":"multiplatform_sqlite/types/#sqlite-types","text":"SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. SQLDelight natively supports Long, Double, String, ByteArray, Int, Short, Float, and Booleans. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray some_int INTEGER AS Int , -- Stored as INTEGER in db, retrieved as Int some_short INTEGER AS Short , -- Stored as INTEGER in db, retrieved as Short some_float REAL AS Float -- Stored as REAL in db, retrieved as Float ); Boolean columns are stored in the db as INTEGER , and so they can be given INTEGER column constraints. Use DEFAULT 0 to default to false, for example. CREATE TABLE hockey_player ( injured INTEGER AS Boolean DEFAULT 0 )","title":"SQLite Types"},{"location":"multiplatform_sqlite/types/#custom-column-types","text":"If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) )","title":"Custom Column Types"},{"location":"multiplatform_sqlite/types/#enums","text":"As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Enums"},{"location":"native_sqlite/","text":"Getting started on Kotlin Native with SQLDelight First apply the gradle plugin in your project. buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.3.0' } } apply plugin: 'com.squareup.sqldelight' sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" } } Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: kotlin { // or sourceSets.iosMain, sourceSets.windowsMain, etc. sourceSets . nativeMain . dependencies { implementation \"com.squareup.sqldelight:native-driver:1.3.0\" } } val driver : SqlDriver = NativeSqliteDriver ( Database . Schema , \"test.db\" ) SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Getting Started"},{"location":"native_sqlite/#getting-started-on-kotlin-native-with-sqldelight","text":"First apply the gradle plugin in your project. buildscript { repositories { google () mavenCentral () } dependencies { classpath 'com.squareup.sqldelight:gradle-plugin:1.3.0' } } apply plugin: 'com.squareup.sqldelight' sqldelight { Database { // This will be the name of the generated database class. packageName = \"com.example\" } } Put your SQL statements in a .sq file under src/main/sqldelight . Typically the first statement in the SQL file creates a table. -- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq CREATE TABLE hockeyPlayer ( player_number INTEGER NOT NULL , full_name TEXT NOT NULL ); CREATE INDEX hockeyPlayer_full_name ON hockeyPlayer ( full_name ); INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( 15 , 'Ryan Getzlaf' ); From this SQLDelight will generate a Database Kotlin class with an associated Schema object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of: kotlin { // or sourceSets.iosMain, sourceSets.windowsMain, etc. sourceSets . nativeMain . dependencies { implementation \"com.squareup.sqldelight:native-driver:1.3.0\" } } val driver : SqlDriver = NativeSqliteDriver ( Database . Schema , \"test.db\" ) SQL statements inside a .sq file can be labeled to have a typesafe function generated for them available at runtime. selectAll : SELECT * FROM hockeyPlayer ; insert : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ( ? , ? ); insertFullPlayerObject : INSERT INTO hockeyPlayer ( player_number , full_name ) VALUES ? ; Files with labeled statements in them will have a queries file generated from them that matches the .sq file name - putting the above sql into Player.sq generates PlayerQueries.kt . To get a reference to PlayerQueries you need to wrap the driver we made above: // In reality the database and driver above should be created a single time // and passed around using your favourite dependency injection/service // locator/singleton pattern. val database = Database ( driver ) val playerQueries : PlayerQueries = database . playerQueries println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\")] playerQueries . insert ( player_number = 10 , full_name = \"Corey Perry\" ) println ( playerQueries . selectAll (). executeAsList ()) // Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")] val player = HockeyPlayer ( 10 , \"Ronald McDonald\" ) playerQueries . insertFullPlayerObject ( player ) And that's it! Check out the other pages on the sidebar for other functionality.","title":"Getting started on Kotlin Native with SQLDelight"},{"location":"native_sqlite/coroutines/","text":"Flow To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides: kotlin { sourceSets . commonMain . dependencies { implementation \"com.squareup.sqldelight:coroutines-extensions:1.2.1\" } } val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Coroutines"},{"location":"native_sqlite/coroutines/#flow","text":"To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides: kotlin { sourceSets . commonMain . dependencies { implementation \"com.squareup.sqldelight:coroutines-extensions:1.2.1\" } } val players : Flow < List < HockeyPlayer >> = playerQueries . selectAll () . asFlow () . mapToList () This flow emits the query result, and emits a new result every time the database changes for that query.","title":"Flow"},{"location":"native_sqlite/custom_projections/","text":"Projections By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"native_sqlite/custom_projections/#projections","text":"By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper. val selectAllNames = playerQueries . selectAll ( mapper = { player_number , full_name -> full_name . toUppercase () } ) println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"] In general you should be leveraging SQL to do custom projections whenever possible. selectNames : SELECT upper ( full_name ) FROM hockeyPlayer ; val selectAllNames = playerQueries . selectNames () println ( selectAllNames . executeAsList ()) // Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]","title":"Projections"},{"location":"native_sqlite/gradle/","text":"Gradle For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // The dialect version you would like to target // Defaults to \"sqlite:3.18\" dialect = \"sqlite:3.24\" } // For native targets, whether sqlite should be automatically linked. // Defaults to true. linkSqlite = false } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) dialect = \"sqlite:3.24\" } linkSqlite = false }","title":"Gradle"},{"location":"native_sqlite/gradle/#gradle","text":"For greater customization, you can declare databases explicitly using the Gradle DSL. build.gradle : sqldelight { // Database name MyDatabase { // Package name used for the generated MyDatabase.kt packageName = \"com.example.db\" // An array of folders where the plugin will read your '.sq' and '.sqm' // files. The folders are relative to the existing source set so if you // specify [\"db\"], the plugin will look into 'src/main/db'. // Defaults to [\"sqldelight\"] (src/main/sqldelight) sourceFolders = [ \"db\" ] // The directory where to store '.db' schema files relative to the root // of the project. These files are used to verify that migrations yield // a database with the latest schema. Defaults to null so the verification // tasks will not be created. schemaOutputDirectory = file ( \"src/main/sqldelight/databases\" ) // Optionally specify schema dependencies on other gradle projects dependency project ( ':OtherProject' ) // The dialect version you would like to target // Defaults to \"sqlite:3.18\" dialect = \"sqlite:3.24\" } // For native targets, whether sqlite should be automatically linked. // Defaults to true. linkSqlite = false } If you're using Kotlin for your Gradle files: build.gradle.kts sqldelight { database ( \"MyDatabase\" ) { packageName = \"com.example.db\" sourceFolders = listOf ( \"db\" ) schemaOutputDirectory = file ( \"build/dbs\" ) dependency ( project ( \":OtherProject\" )) dialect = \"sqlite:3.24\" } linkSqlite = false }","title":"Gradle"},{"location":"native_sqlite/intellij_plugin/","text":"IntelliJ Plugin The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight","title":"IntelliJ Plugin"},{"location":"native_sqlite/intellij_plugin/#intellij-plugin","text":"The IntelliJ plugin provides language-level features for .sq files, including: Syntax highlighting Refactoring/Find usages Code autocompletion Generate Queries files after edits Right click to copy as valid SQLite Compiler errors in IDE click through to file It can be installed from your IDE by navigating Preferences -> Plugins -> Marketplace -> Search for SQLDelight","title":"IntelliJ Plugin"},{"location":"native_sqlite/migrations/","text":"Migrations The .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. Versioning The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; These SQL statements are run by Database.Schema.migrate() . Verifying Migrations You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task, which is available once you specify a schemaOutputDirectory , as described in the gradle.md . You should probably do this before you create your first migration.","title":"Migrations"},{"location":"native_sqlite/migrations/#migrations","text":"The .sq file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date.","title":"Migrations"},{"location":"native_sqlite/migrations/#versioning","text":"The first version of the schema is 1. Migration files are named <version to upgrade from>.sqm . To migrate to version 2, put migration statements in 1.sqm : ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER ; ALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER ; These SQL statements are run by Database.Schema.migrate() .","title":"Versioning"},{"location":"native_sqlite/migrations/#verifying-migrations","text":"You can also place a .db file in the src/main/sqldelight folder of the same <version number>.db format. If there is a .db file present, a new verifySqlDelightMigration task will be added to the gradle project, and it will run as part of the test task, meaning your migrations will be verified against that .db file. It confirms that the migrations yield a database with the latest schema. To generate a .db file from your latest schema, run the generateSqlDelightSchema task, which is available once you specify a schemaOutputDirectory , as described in the gradle.md . You should probably do this before you create your first migration.","title":"Verifying Migrations"},{"location":"native_sqlite/query_arguments/","text":"Bind Args .sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments. Type Inference SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\" Named Arguments Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" ) Variable Arguments Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" )) Inserts INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Arguments"},{"location":"native_sqlite/query_arguments/#bind-args","text":".sq files use the exact same syntax as SQLite, including SQLite Bind Args . If a statement contains bind args, the associated method will require corresponding arguments.","title":"Bind Args"},{"location":"native_sqlite/query_arguments/#type-inference","text":"SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types. selectByNumber : SELECT * FROM hockeyPlayer WHERE player_number = ? ; val selectNumber10 = playerQueries . selectByNumber ( player_number = 10 ) println ( selectNumber10 . executeAsOne ()) // Prints \"Corey Perry\"","title":"Type Inference"},{"location":"native_sqlite/query_arguments/#named-arguments","text":"Named parameters or indexed parameters can be used. firstOrLastName : SELECT * FROM hockeyPlayer WHERE full_name LIKE ( '% ' || : name ) OR full_name LIKE (: name || ' %' ); playerQueries . firstOrLastName ( name = \"Ryan\" )","title":"Named Arguments"},{"location":"native_sqlite/query_arguments/#variable-arguments","text":"Sets of values can also be passed as an argument. selectByNames : SELECT * FROM hockeyPlayer WHERE full_name IN ? ; playerQueries . selectByNames ( listOf ( \"Alec\" , \"Jake\" , \"Matt\" ))","title":"Variable Arguments"},{"location":"native_sqlite/query_arguments/#inserts","text":"INSERT VALUES arguments can be bound to with the table's data class. insertPlayer : INSERT INTO hockeyPlayer VALUES ? ; val rickardRakell = HockeyPlayer ( full_name = \"Rickard Rakell\" , number = 67 ) playerQueries . insertPlayer ( rickardRakell )","title":"Inserts"},{"location":"native_sqlite/transactions/","text":"API If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithReturn function. val players = database . playerQueries . transactionWithReturn { database . playerQueries . selectAll (). executeAsList () } Rollback Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted = database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size } Callbacks You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \"${players.size} players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Transactions"},{"location":"native_sqlite/transactions/#api","text":"If you want to execute multiple statements under one transaction, use transaction function. val players = listOf < Player >() database . playerQueries . transaction { players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } To return a value from a transaction, use the transactionWithReturn function. val players = database . playerQueries . transactionWithReturn { database . playerQueries . selectAll (). executeAsList () }","title":"API"},{"location":"native_sqlite/transactions/#rollback","text":"Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return. database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback () database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } } val numberInserted = database . playerQueries . transaction { players . forEach { player -> if ( player . number == 0 ) rollback ( 0 ) database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } players . size }","title":"Rollback"},{"location":"native_sqlite/transactions/#callbacks","text":"You can register callbacks to occur after a transaction has completed or rolled back: database . playerQueries . transaction { afterRollback { log ( \"No players were inserted.\" ) } afterCommit { log ( \"${players.size} players were inserted.\" ) } players . forEach { player -> database . playerQueries . insert ( player_number = player . number , full_name = player . fullName ) } }","title":"Callbacks"},{"location":"native_sqlite/types/","text":"SQLite Types SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. SQLDelight natively supports Long, Double, String, ByteArray, Int, Short, Float, and Booleans. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray some_int INTEGER AS Int , -- Stored as INTEGER in db, retrieved as Int some_short INTEGER AS Short , -- Stored as INTEGER in db, retrieved as Short some_float REAL AS Float -- Stored as REAL in db, retrieved as Float ); Boolean columns are stored in the db as INTEGER , and so they can be given INTEGER column constraints. Use DEFAULT 0 to default to false, for example. CREATE TABLE hockey_player ( injured INTEGER AS Boolean DEFAULT 0 ) Custom Column Types If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) ) Enums As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Types"},{"location":"native_sqlite/types/#sqlite-types","text":"SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface. SQLDelight natively supports Long, Double, String, ByteArray, Int, Short, Float, and Booleans. CREATE TABLE some_types ( some_long INTEGER , -- Stored as INTEGER in db, retrieved as Long some_double REAL , -- Stored as REAL in db, retrieved as Double some_string TEXT , -- Stored as TEXT in db, retrieved as String some_blob BLOB , -- Stored as BLOB in db, retrieved as ByteArray some_int INTEGER AS Int , -- Stored as INTEGER in db, retrieved as Int some_short INTEGER AS Short , -- Stored as INTEGER in db, retrieved as Short some_float REAL AS Float -- Stored as REAL in db, retrieved as Float ); Boolean columns are stored in the db as INTEGER , and so they can be given INTEGER column constraints. Use DEFAULT 0 to default to false, for example. CREATE TABLE hockey_player ( injured INTEGER AS Boolean DEFAULT 0 )","title":"SQLite Types"},{"location":"native_sqlite/types/#custom-column-types","text":"If you'd like to retrieve columns as custom types you can specify a Kotlin type: import kotlin . collections . List ; CREATE TABLE hockeyPlayer ( cup_wins TEXT AS List < String > NOT NULL ); However, creating the Database will require you to provide a ColumnAdapter which knows how to map between the database type and your custom type: val listOfStringsAdapter = object : ColumnAdapter < List < String >, String > { override fun decode ( databaseValue : String ) = databaseValue . split ( \",\" ) override fun encode ( value : List < String >) = value . joinToString ( separator = \",\" ) } val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = hockeyPlayer . Adapter ( cup_winsAdapter = listOfStringsAdapter ) )","title":"Custom Column Types"},{"location":"native_sqlite/types/#enums","text":"As a convenience the SQLDelight runtime includes a ColumnAdapter for storing an enum as String data. import com . example . hockey . HockeyPlayer ; CREATE TABLE hockeyPlayer ( position TEXT AS HockeyPlayer . Position ) val queryWrapper : Database = Database ( driver = driver , hockeyPlayerAdapter = HockeyPlayer . Adapter ( positionAdapter = EnumColumnAdapter () ) )","title":"Enums"}]}